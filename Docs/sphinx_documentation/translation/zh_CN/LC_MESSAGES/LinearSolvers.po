# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/LinearSolvers.rst:9 242101c37c7b4b21bac735e649458a73
msgid "MLMG and Linear Operator Classes"
msgstr ""

#: ../../source/LinearSolvers.rst:11 8dac28221dfb451e97409f2aa155ab6b
msgid ""
"Multi-Level Multi-Grid or ``MLMG`` is a class for solving the linear "
"system using the geometric multigrid method.  The constructor of ``MLMG``"
" takes the reference to :cpp:`MLLinOp`, an abstract base class of various"
" linear operator classes, :cpp:`MLABecLaplacian`, :cpp:`MLPoisson`, "
":cpp:`MLNodeLaplacian`, etc.  We choose the type of linear operator class"
" according to the type the linear system to solve."
msgstr ""

#: ../../source/LinearSolvers.rst:19 a735a86e4f564c1baebffaa89d4e1202
msgid ""
":cpp:`MLABecLaplacian` for cell-centered canonical form (equation "
":eq:`eqn::abeclap`)."
msgstr ""

#: ../../source/LinearSolvers.rst:21 f4cd9dfb134f4496849caf1ba7a9ddb1
msgid ""
":cpp:`MLPoisson` for cell-centered constant coefficient Poisson's "
"equation :math:`\\nabla^2 \\phi = f`."
msgstr ""

#: ../../source/LinearSolvers.rst:24 a903f83134694fb39b8cc4454f214481
msgid ""
":cpp:`MLNodeLaplacian` for nodal variable coefficient Poisson's equation "
":math:`\\nabla \\cdot (\\sigma \\nabla \\phi) = f`."
msgstr ""

#: ../../source/LinearSolvers.rst:27 f37f4702dd054a978c55d07d430f5b1c
msgid ""
"The constructors of these linear operator classes are in the form like "
"below"
msgstr ""

#: ../../source/LinearSolvers.rst:41 be0cc5df5f5a4c5ba65f3f371d2d16df
msgid ""
"It takes :cpp:`Vectors` of :cpp:`Geometry`, :cpp:`BoxArray` and "
":cpp:`DistributionMapping`.  The arguments are :cpp:`Vectors` because "
"MLMG can do multi-level composite solves.  If you are using it for "
"single-level, you can do"
msgstr ""

#: ../../source/LinearSolvers.rst:53 3f410464602f4cdc8b0987d631f10dde
msgid ""
"to let the compiler construct :cpp:`Vectors` for you.  Recall that the "
"classes :cpp:`Vector`, :cpp:`Geometry`, :cpp:`BoxArray`, and "
":cpp:`DistributionMapping` are defined in chapter :ref:`Chap:Basics`.  "
"There are two new classes that are optional parameters.  :cpp:`LPInfo` is"
" a class for passing parameters.  :cpp:`FabFactory` is used in problems "
"with embedded boundaries (chapter :ref:`Chap:EB`)."
msgstr ""

#: ../../source/LinearSolvers.rst:60 c52a77b3b88d4b6abcc8f1196056bddd
msgid ""
"After the linear operator is built, we need to set up boundary "
"conditions.  This will be discussed later in section "
":ref:`sec:linearsolver:bc`."
msgstr ""

#: ../../source/LinearSolvers.rst:65 f41a44aceca54e86945a9f2cec51a80a
msgid "Coefficients"
msgstr ""

#: ../../source/LinearSolvers.rst:67 c5276d44083d45ef8c1a1c780e671516
msgid ""
"Next, we consider the coefficients for equation :eq:`eqn::abeclap`. For "
":cpp:`MLPoisson`, there are no coefficients to set so nothing needs to be"
" done. For :cpp:`MLABecLaplacian`, we need to call member functions "
":cpp:`setScalars`, :cpp:`setACoeffs`, and :cpp:`setBCoeffs`. The "
":cpp:`setScalars` function sets the scalar constants :math:`A` and "
":math:`B`"
msgstr ""

#: ../../source/LinearSolvers.rst:78 7449a95f08d14dec9a381d65cb304d5b
msgid ""
"For the general case where :math:`\\alpha` and :math:`\\beta` are scalar "
"fields, we use"
msgstr ""

#: ../../source/LinearSolvers.rst:86 3b35d2873af34437b39519dacb92eb52
msgid ""
"For the case where :math:`\\alpha` and/or :math:`\\beta` are scalar "
"constants, there is the option to use"
msgstr ""

#: ../../source/LinearSolvers.rst:95 fbfdfb995cb54979b12339af95c0ad16
msgid ""
"Note, however, that the solver behavior is the same regardless of which "
"functions you use to set the coefficients. These functions solely copy "
"the constant value(s) to a MultiFab internal to ``MLMG`` and so no "
"appreciable efficiency gains can be expected."
msgstr ""

#: ../../source/LinearSolvers.rst:99 24778b53dbb14977a5793fb680f2abea
msgid ""
"For :cpp:`MLNodeLaplacian`, one can set a variable :cpp:`sigma` with the "
"member function"
msgstr ""

#: ../../source/LinearSolvers.rst:108 0be792f694d748dba6ecbbb532ba2bd9
msgid "or a constant :cpp:`sigma` during declaration or definition"
msgstr ""

#: ../../source/LinearSolvers.rst:128 a1160e338d5945dea784b31d04def125
msgid ""
"Here, setting a constant :cpp:`sigma` alters the internal behavior of the"
" solver making it more efficient for this special case."
msgstr ""

#: ../../source/LinearSolvers.rst:131 4b91986db416449aa5d431787a5e4c4f
msgid ""
"The :cpp:`int amrlev` parameter should be zero for single-level solves.  "
"For multi-level solves, each level needs to be provided with ``alpha`` "
"and ``beta``, or ``sigma``.  For composite solves, :cpp:`amrlev` 0 will "
"mean the lowest level for the solver, which is not necessarily the lowest"
" level in the AMR hierarchy. This is so solves can be done on different "
"sections of the AMR hierarchy, e.g. on AMR levels 3 to 5."
msgstr ""

#: ../../source/LinearSolvers.rst:138 a1247425eb2e45bcb637539b061c5fec
msgid ""
"After boundary conditions and coefficients are prescribed, the linear "
"operator is ready for an MLMG object like below."
msgstr ""

#: ../../source/LinearSolvers.rst:147 a70256bfd4b3495aa4fa5e995d6f74b9
msgid ""
"Optional parameters can be set (see section "
":ref:`sec:linearsolver:pars`), and then we can use the ``MLMG`` member "
"function"
msgstr ""

#: ../../source/LinearSolvers.rst:158 9ad164cc3f824b45a07dd1c8b24e9735
msgid ""
"to solve the problem given an initial guess and a right-hand side. Zero "
"is a perfectly fine initial guess.  The two :cpp:`Reals` in the argument "
"list are the targeted relative and absolute error tolerances. The "
"relative error tolerance is hard-coded to be at least :math:`10^{-16}`. "
"Given the linear system :math:`Ax=b`, the solver will terminate when the "
"max-norm of the residual (:math:`b-Ax`) is less than "
":cpp:`std::max(a_tol_abs, a_tol_rel*max_norm)` where :cpp:`max_norm` is "
"the max-norm of the rhs, :math:`b`, if the flag :cpp:`always_use_bnorm` "
"is set to True or if the rhs max-norm is greater than or equal to the "
"max-norm error of the initial guess, otherwise :cpp:`max_norm` is equal "
"to the max-norm error of the initial guess.  Set the absolute tolerance "
"to zero if one does not have a good value for it.  The return value of "
":cpp:`solve` is the max-norm error."
msgstr ""

#: ../../source/LinearSolvers.rst:171 a1106ff5c4554425a8614ee45dd6f971
msgid "After the solver returns successfully, if needed, we can call"
msgstr ""

#: ../../source/LinearSolvers.rst:181 dc5ff48b54ec438b8150c909048724df
msgid ""
"to compute residual (i.e., :math:`f - L(\\phi)`) given the solution and "
"the right-hand side.  For cell-centered solvers, we can also call the "
"following functions to compute gradient :math:`\\nabla \\phi` and fluxes "
":math:`-\\beta \\nabla \\phi`."
msgstr ""

#: ../../source/LinearSolvers.rst:197 650eb92e102845bb9329420f401f17b6
msgid "Boundary Conditions"
msgstr ""

#: ../../source/LinearSolvers.rst:199 c20e23fb8878433f94bfafe32995dd12
msgid ""
"We now discuss how to set up boundary conditions for linear operators. In"
" the following, physical domain boundaries refer to the boundaries of the"
" physical domain, whereas coarse/fine boundaries refer to the boundaries "
"between AMR levels. The following steps must be followed in the exact "
"order."
msgstr ""

#: ../../source/LinearSolvers.rst:205 0ea1fcf18933498493ac9f2d2a0adbae
msgid ""
"1) For any type of solver, we first need to set physical domain boundary "
"types via the :cpp:`MLLinOp` member function"
msgstr ""

#: ../../source/LinearSolvers.rst:215 4f31e54edb4241c6b3c3a6757d3090e6
msgid "The supported BC types at the physical domain boundaries are"
msgstr ""

#: ../../source/LinearSolvers.rst:217 509c12e757ab4309999d8fc4db3ec146
msgid ":cpp:`LinOpBCType::Periodic` for periodic boundary."
msgstr ""

#: ../../source/LinearSolvers.rst:219 71cbe4ddb17c400385be97415adc7c1b
msgid ":cpp:`LinOpBCType::Dirichlet` for Dirichlet boundary condition."
msgstr ""

#: ../../source/LinearSolvers.rst:221 96b7aa371dbe47089af10fed30241909
msgid ":cpp:`LinOpBCType::Neumann` for homogeneous Neumann boundary condition."
msgstr ""

#: ../../source/LinearSolvers.rst:223 0277fadef6f44d4783f160b0bc6e23ab
msgid ""
":cpp:`LinOpBCType::inhomogNeumann` for inhomogeneous Neumann boundary "
"condition."
msgstr ""

#: ../../source/LinearSolvers.rst:225 f298107fcc154a509d208f1660d603fb
msgid ""
":cpp:`LinOpBCType::Robin` for Robin boundary conditions, :math:`a\\phi + "
"b\\frac{\\partial\\phi}{\\partial n} = f`."
msgstr ""

#: ../../source/LinearSolvers.rst:227 08c1ae1e90ba4fa3913565fad4d831d4
msgid ":cpp:`LinOpBCType::reflect_odd` for reflection with sign changed."
msgstr ""

#: ../../source/LinearSolvers.rst:229 4aaeb6dccb004aa9a33d5704ecafadcf
msgid ""
"2) Cell-centered solvers only: if we want to do a linear solve where the "
"boundary conditions on the coarsest AMR level of the solve come from a "
"coarser level (e.g. the base AMR level of the solve is > 0 and does not "
"cover the entire domain), we must explicitly provide the coarser data.  "
"Boundary conditions from a coarser level are always Dirichlet."
msgstr ""

#: ../../source/LinearSolvers.rst:236 49c47ac743b34b70a95a4aa16f5682f5
msgid ""
"Note that this step, if needed, must be performed before the step below. "
"The :cpp:`MLLinOp` member function for this step is"
msgstr ""

#: ../../source/LinearSolvers.rst:245 e55657489ff946eb80d228829db0dc00
msgid ""
"Here :cpp:`const MultiFab* crse` contains the Dirichlet boundary values "
"at the coarse resolution, and :cpp:`int crse_ratio` (e.g., 2) is the "
"refinement ratio between the coarsest solver level and the AMR level "
"below it.  The MultiFab :cpp:`crse` does not need to have ghost cells "
"itself. If the coarse grid bc's for the solve are identically zero, "
":cpp:`nullptr` can be passed instead of :cpp:`crse`."
msgstr ""

#: ../../source/LinearSolvers.rst:252 fb628d33e93940de97c72478e77e4b36
msgid ""
"3) Cell-centered solvers only: before the solve one must always call the "
":cpp:`MLLinOp` member function"
msgstr ""

#: ../../source/LinearSolvers.rst:264 dd374fb3ef32485e9031e0b9908f7f1d
msgid ""
"If we want to supply an inhomogeneous Dirichlet or inhomogeneous Neumann "
"boundary condition at the domain boundaries, we must supply those values "
"in ``MultiFab* levelbcdata``, which must have at least one ghost cell. "
"Note that the argument :cpp:`amrlev` is relative to the solve, not "
"necessarily the full AMR hierarchy; amrlev = 0 refers to the coarsest "
"level of the solve."
msgstr ""

#: ../../source/LinearSolvers.rst:271 b0b420bd2dfd4536b5b33907e494f50f
msgid ""
"If the boundary condition is Dirichlet the ghost cells outside the domain"
" boundary of ``levelbcdata`` must hold the value of the solution at the "
"domain boundary; if the boundary condition is Neumann those ghost cells "
"must hold the value of the gradient of the solution normal to the "
"boundary (e.g. it would hold dphi/dx on both the low and high faces in "
"the x-direction)."
msgstr ""

#: ../../source/LinearSolvers.rst:278 2a6ee55688db43908ad2c78bde95e5d8
msgid ""
"If the boundary conditions contain no inhomogeneous Dirichlet or Neumann "
"boundaries, we can pass :cpp:`nullptr` instead of a MultiFab."
msgstr ""

#: ../../source/LinearSolvers.rst:281 bcd3853846de4589a3ccd040b63e8f73
msgid ""
"We can use the solution array itself to hold these values; the values are"
" copied to internal arrays and will not be over-written when the solution"
" array itself is being updated by the solver. Note, however, that this "
"call does not provide an initial guess for the solve."
msgstr ""

#: ../../source/LinearSolvers.rst:286 c2e2712e8fdb413583b1a6b978b8eb37
msgid ""
"It should be emphasized that the data in ``levelbcdata`` for Dirichlet or"
" Neumann boundaries are assumed to be exactly on the face of the physical"
" domain; storing these values in the ghost cell of a cell-centered array "
"is a convenience of implementation."
msgstr ""

#: ../../source/LinearSolvers.rst:291 794e4895182b49b8b3fb8e152984e376
msgid ""
"For Robin boundary conditions, the ghost cells in ``MultiFab* "
"robinbc_a``, ``MultiFab* robinbc_b``, and ``MultiFab* robinbc_f`` store "
"the numerical values in the condition, :math:`a\\phi + "
"b\\frac{\\partial\\phi}{\\partial n} = f`."
msgstr ""

#: ../../source/LinearSolvers.rst:299 f65f770301e14914a1b57b4ca23ad6bf
msgid "Parameters"
msgstr ""

#: ../../source/LinearSolvers.rst:301 2b806f17e67241d0b4af608cf25f5ccc
msgid ""
"There are many parameters that can be set.  Here we discuss some commonly"
" used ones."
msgstr ""

#: ../../source/LinearSolvers.rst:304 90d05a0e0b75407aba5119480fe582d4
msgid ""
":cpp:`MLLinOp::setVerbose(int)`, :cpp:`MLMG::setVerbose(int)` and "
":cpp:`MLMG:setBottomVerbose(int)` control the verbosity of the linear "
"operator, multigrid solver and the bottom solver, respectively."
msgstr ""

#: ../../source/LinearSolvers.rst:308 01bf260d6b404c71a0b58f8568a78935
msgid ""
"The multigrid solver is an iterative solver.  The maximal number of "
"iterations can be changed with :cpp:`MLMG::setMaxIter(int)`.  We can also"
" do a fixed number of iterations with :cpp:`MLMG::setFixedIter(int)`.  By"
" default, V-cycle is used.  We can use :cpp:`MLMG::setMaxFmgIter(int)` to"
" control how many full multigrid cycles can be done before switching to "
"V-cycle."
msgstr ""

#: ../../source/LinearSolvers.rst:315 7ae4320b883f4200acbbccf106f84761
msgid ""
":cpp:`LPInfo::setMaxCoarseningLevel(int)` can be used to control the "
"maximal number of multigrid levels.  We usually should not call this "
"function.  However, we sometimes build the solver to simply apply the "
"operator (e.g., :math:`L(\\phi)`) without needing to solve the system. We"
" can do something as follows to avoid the cost of building coarsened "
"operators for the multigrid."
msgstr ""

#: ../../source/LinearSolvers.rst:333 b2d0d5a69fc24eb5acfb768b360eb2fc
msgid ""
"At the bottom of the multigrid cycles, we use a ``bottom solver`` which "
"may be different than the relaxation used at the other levels. The "
"default bottom solver is the biconjugate gradient stabilized method, but "
"can easily be changed with the :cpp:`MLMG` member method"
msgstr ""

#: ../../source/LinearSolvers.rst:343 4a5fe183892247dfb370619f77890644
msgid "Available choices are"
msgstr ""

#: ../../source/LinearSolvers.rst:345 a0001db54bbf466081250d8f1c9502ac
msgid ":cpp:`MLMG::BottomSolver::bicgstab`: The default."
msgstr ""

#: ../../source/LinearSolvers.rst:347 1314fcd7de524dedb4e5ab55f52fc02d
msgid ""
":cpp:`MLMG::BottomSolver::cg`: The conjugate gradient method.  The matrix"
" must be symmetric."
msgstr ""

#: ../../source/LinearSolvers.rst:350 74982a60bb804520bad71fb3da301bf9
msgid ":cpp:`MLMG::BottomSolver::smoother`: Smoother such as Gauss-Seidel."
msgstr ""

#: ../../source/LinearSolvers.rst:352 9d999b27eb724832a24c289366df7c6b
msgid ""
":cpp:`MLMG::BottomSolver::bicgcg`: Start with bicgstab. Switch to cg if "
"bicgstab fails.  The matrix must be symmetric."
msgstr ""

#: ../../source/LinearSolvers.rst:355 b802f1bcff8d40469ad7cff38575e356
msgid ""
":cpp:`MLMG::BottomSolver::cgbicg`: Start with cg. Switch to bicgstab if "
"cg fails.  The matrix must be symmetric."
msgstr ""

#: ../../source/LinearSolvers.rst:358 96df24becbea4046b004f7ea8ad0c205
msgid ""
":cpp:`MLMG::BottomSolver::hypre`: One of the solvers available through "
"hypre; see the section below on External Solvers"
msgstr ""

#: ../../source/LinearSolvers.rst:361 b213d104594a4a26a2a9bf6490df9a33
msgid ":cpp:`MLMG::BottomSolver::petsc`: Currently for cell-centered only."
msgstr ""

#: ../../source/LinearSolvers.rst:363 3fcf51bdb4f74167b5e07b06fc859af6
msgid ""
":cpp:`LPInfo::setAgglomeration(bool)` (by default true) can be used "
"continue to coarsen the multigrid by copying what would have been the "
"bottom solver to a new :cpp:`MultiFab` with a new :cpp:`BoxArray` with "
"fewer, larger grids, to allow for additional coarsening."
msgstr ""

#: ../../source/LinearSolvers.rst:368 2cf4af3bfadb435ba7b40259a89e3148
msgid ""
":cpp:`LPInfo::setConsolidation(bool)` (by default true) can be used "
"continue to transfer a multigrid problem to fewer MPI ranks. There are "
"more setting such as :cpp:`LPInfo::setConsolidationGridSize(int)`, "
":cpp:`LPInfo::setConsolidationRatio(int)`, and "
":cpp:`LPInfo::setConsolidationStrategy(int)`, to give control over how "
"this process works."
msgstr ""

#: ../../source/LinearSolvers.rst:376 3833ff0ab1de4343b3e93f251b2d649a
msgid ""
":cpp:`MLMG::setThrowException(bool)` controls whether multigrid failure "
"results in aborting (default) or throwing an exception, whereby control "
"will return to the calling application. The application code must catch "
"the exception:"
msgstr ""

#: ../../source/LinearSolvers.rst:392 3591be698b9e4ef49d5c51f500c1309a
msgid ""
"Note that exceptions that are not caught are passed up the calling chain "
"so that application codes using specialized solvers relying on MLMG can "
"still catch the exception. For example, using AMReX-Hydro's "
":cpp:`NodalProjector`"
msgstr ""

#: ../../source/LinearSolvers.rst:408 1369a5dca0c24274af2a7aec7bc04aa1
msgid "Boundary Stencils for Cell-Centered Solvers"
msgstr ""

#: ../../source/LinearSolvers.rst:410 a603f197cc8d4d40b1100a455149de6a
msgid "We have the option using the :cpp:`MLMG` member method"
msgstr ""

#: ../../source/LinearSolvers.rst:418 e8676652f74b4001a571a29c685ad6c2
msgid ""
"to set the order of the cell-centered linear operator stencil at physical"
" boundaries with Dirichlet boundary conditions and at coarse-fine "
"boundaries.  In both of these cases, the boundary value is not defined at"
" the center of the ghost cell. The order determines the number of "
"interior cells that are used in the extrapolation of the boundary value "
"from the cell face to the center of the ghost cell, where the "
"extrapolated value is then used in the regular stencil.  For example, "
":cpp:`maxorder = 2` uses the boundary value and the first interior value "
"to extrapolate to the ghost cell center; :cpp:`maxorder = 3` uses the "
"boundary value and the first two interior values."
msgstr ""

#: ../../source/LinearSolvers.rst:429 121b876c2af1496a843a214f62ba162e
msgid "Curvilinear Coordinates"
msgstr ""

#: ../../source/LinearSolvers.rst:431 f7f517968ce14267b48cf9c956b16511
msgid ""
"Some of the linear solvers support curvilinear coordinates including 1D "
"spherical and 2d cylindrical :math:`(r,z)`.  In those cases, the "
"divergence operator has extra metric terms.  If one does not want the "
"solver to include the metric terms because they have been handled in "
"other ways, one can turn them off with a setter function. For the cell-"
"centered linear solvers `MLABecLaplacian` and `MLPoisson`, one can call "
":cpp:`setMetricTerm(bool)` with :cpp:`false` on the :cpp:`LPInfo` object "
"passed to the constructor of linear operators. For the node-based "
"`MLNodeLaplacian`, one can call :cpp:`setRZCorrection (bool)` with "
":cpp:`false` on the `MLNodeLaplacian` object."
msgstr ""

#: ../../source/LinearSolvers.rst:443 b62911cfcebc4b009b0ee796c1348d20
msgid ""
"`MLABecLaplacian` and `MLPoisson` support both spherical and cylindrical "
"coordinates, while `MLNodeLaplacian` supports only cylindrical at this "
"time. Note that to use cylindrical coordinates with `MLNodeLaplacian`, "
"the application code must scale ``sigma`` by the radial coordinate before"
" calling :cpp:`setSigma()`."
msgstr ""

#: ../../source/LinearSolvers.rst:450 0ccd2d2af6d5434797b4460214da72e2
msgid "Embedded Boundaries"
msgstr ""

#: ../../source/LinearSolvers.rst:452 a58a69c967d4421fa0fe5481ccf145ed
msgid ""
"AMReX supports multi-level solvers for use with embedded boundaries. "
"These include 1) cell-centered solvers with homogeneous Neumann, "
"homogeneous Dirichlet, or inhomogeneous Dirichlet boundary conditions on "
"the EB faces, and 2) nodal solvers with homogeneous Neumann boundary "
"conditions, or inflow velocity conditions on the EB faces."
msgstr ""

#: ../../source/LinearSolvers.rst:459 d54cfa4b57124e7596950f7fd584ccbf
msgid ""
"To use a cell-centered solver with EB, one builds a linear operator "
":cpp:`MLEBABecLap` with :cpp:`EBFArrayBoxFactory` (instead of a "
":cpp:`MLABecLaplacian`)"
msgstr ""

#: ../../source/LinearSolvers.rst:472 4758b9becf364f27b6c630daad4292a5
msgid ""
"The usage of this EB-specific class is essentially the same as "
":cpp:`MLABecLaplacian`."
msgstr ""

#: ../../source/LinearSolvers.rst:475 42f4cf63ae504c0faba0dfbd40e52a7c
msgid "The default boundary condition on EB faces is homogeneous Neumann."
msgstr ""

#: ../../source/LinearSolvers.rst:477 e986d9a79cca492b933068726d0c8f27
msgid "To set homogeneous Dirichlet boundary conditions, call"
msgstr ""

#: ../../source/LinearSolvers.rst:485 8989ec4c437640a3ba61cfca7c1cf06e
msgid ""
"where coeff can be a real number (i.e. the value is the same at every "
"cell) or is the MultiFab holding the coefficient of the gradient at each "
"cell with an EB face."
msgstr ""

#: ../../source/LinearSolvers.rst:488 ddab283194d641038f7e6829186498e3
msgid "To set inhomogeneous Dirichlet boundary conditions, call"
msgstr ""

#: ../../source/LinearSolvers.rst:496 906db0176e464761859608c24194f7b8
msgid ""
"where phi_on_eb is the MultiFab holding the Dirichlet values in every cut"
" cell, and coeff again is a real number (i.e. the value is the same at "
"every cell) or a MultiFab holding the coefficient of the gradient at each"
" cell with an EB face."
msgstr ""

#: ../../source/LinearSolvers.rst:500 2e4630ad84a4434e9b6373ea8528426d
msgid ""
"Currently there are options to define the face-based coefficients on face"
" centers vs face centroids, and to interpret the solution variable as "
"being defined on cell centers vs cell centroids."
msgstr ""

#: ../../source/LinearSolvers.rst:504 8b9f0ab8d3b944f5bd9e190b474141ca
msgid ""
"The default is for the solution variable to be defined at cell centers; "
"to tell the solver to interpret the solution variable as living at cell "
"centroids, you must set"
msgstr ""

#: ../../source/LinearSolvers.rst:514 c0cb927aab0c479386231bae1e232a00
msgid ""
"The default is for the face-based coefficients to be defined at face "
"centers; to tell the that the face-based coefficients should be "
"interpreted as living at face centroids, modify the setBCoeffs command to"
" be"
msgstr ""

#: ../../source/LinearSolvers.rst:525 790583e5ce17464bb3ff758af45bb061
msgid "External Solvers"
msgstr ""

#: ../../source/LinearSolvers.rst:527 098ea741d5ff4f85b803e2109f80bf3b
msgid ""
"AMReX provides interfaces to the `hypre "
"<https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-"
"multigrid-methods>`_ preconditioners and solvers, including BoomerAMG, "
"GMRES (all variants), PCG, and BICGStab as solvers, and BoomerAMG and "
"Euclid as preconditioners.  These can be called as as bottom solvers for "
"both cell-centered and node-based problems."
msgstr ""

#: ../../source/LinearSolvers.rst:531 d23e5e4e0f694acb8d897017b14a702d
msgid ""
"If it is built with Hypre support, AMReX initializes Hypre by default in "
"`amrex::Initialize`.  If it is built with CUDA, AMReX will also set up "
"Hypre to run on device by default.  The user can choose to disable the "
"Hypre initialization by AMReX with :cpp:`ParmParse` parameter "
"``amrex.init_hypre=[0|1]``."
msgstr ""

#: ../../source/LinearSolvers.rst:537 ff72a950efe9477fab1f0f4f29ecd52d
msgid ""
"By default the AMReX linear solver code always tries to geometrically "
"coarsen the problem as much as possible.  However, as we have mentioned, "
"we can call :cpp:`setMaxCoarseningLevel(0)` on the :cpp:`LPInfo` object "
"passed to the constructor of a linear operator to disable the coarsening "
"completely.  In that case the bottom solver is solving the residual "
"correction form of the original problem. To build Hypre, follow the next "
"steps:"
msgstr ""

#: ../../source/LinearSolvers.rst:556 e5ae210a49a64a1a83cabc7fbaee91d2
msgid ""
"To use hypre, one must include ``amrex/Src/Extern/HYPRE`` in the build "
"system. For examples of using hypre, we refer the reader to "
"`ABecLaplacian`_ or `NodeTensorLap`_."
msgstr ""

#: ../../source/LinearSolvers.rst:564 33966b057a344fa2a46c3521175351e8
msgid ""
"The following parameter should be set to True if the problem to be solved"
" has a singular matrix. In this case, the solution is only defined to "
"within a constant.  Setting this parameter to True replaces one row in "
"the matrix sent to hypre from AMReX by a row that sets the value at one "
"cell to 0."
msgstr ""

#: ../../source/LinearSolvers.rst:568 4ffe66482c544da08bdaa6c27cd769ee
msgid ":cpp:`hypre.adjust_singular_matrix`:   Default is false."
msgstr ""

#: ../../source/LinearSolvers.rst:571 643bae9307684327a4fded7433f9ce18
msgid ""
"The following parameters can be set in the inputs file to control the "
"choice of preconditioner and smoother:"
msgstr ""

#: ../../source/LinearSolvers.rst:573 ea4e31107df0465dbae0ef2bf29d74da
msgid ":cpp:`hypre.hypre_solver`:   Default is BoomerAMG."
msgstr ""

#: ../../source/LinearSolvers.rst:575 dd80e2fc7d2f4f3496e9167cf5a6da0f
msgid ""
":cpp:`hypre.hypre_preconditioner`: Default is none;  otherwise the type "
"must be specified."
msgstr ""

#: ../../source/LinearSolvers.rst:577 41fae923b8464704b1d88e196c8f6faf
msgid ""
":cpp:`hypre.recompute_preconditioner`: Default true.  Option to recompute"
" the preconditioner."
msgstr ""

#: ../../source/LinearSolvers.rst:579 0199303a5bb8444883a5539c1b330217
msgid ""
":cpp:`hypre.write_matrix_files`: Default false.   Option to write out "
"matrix into text files."
msgstr ""

#: ../../source/LinearSolvers.rst:581 460fa19f457b4bf19b39a5b2a15c2cf0
msgid ""
":cpp:`hypre.overwrite_existing_matrix_files`: Default false.   Option to "
"over-write existing matrix files."
msgstr ""

#: ../../source/LinearSolvers.rst:584 01cb3f59f36048b288fd88c671cceba1
msgid ""
"The following parameters can be set in the inputs file to control the "
"BoomerAMG solver specifically:"
msgstr ""

#: ../../source/LinearSolvers.rst:586 8b8d6a11fa9a40b4a5470fed894d77e6
msgid ""
":cpp:`hypre.bamg_verbose`: verbosity of BoomerAMG preconditioner. Default"
" 0. See `HYPRE_BoomerAMGSetPrintLevel`"
msgstr ""

#: ../../source/LinearSolvers.rst:588 154053b3ccb1486e8815a023c971f3f9
msgid ":cpp:`hypre.bamg_logging`: Default 0. See `HYPRE_BoomerAMGSetLogging`"
msgstr ""

#: ../../source/LinearSolvers.rst:590 cbc345b6cda14c598954148522ad106d
msgid ""
":cpp:`hypre.bamg_coarsen_type`: Default 6.  See "
"`HYPRE_BoomerAMGSetCoarsenType`"
msgstr ""

#: ../../source/LinearSolvers.rst:592 ebce359106d64e3ea3f20f40e9b8954a
msgid ""
":cpp:`hypre.bamg_cycle_type`: Default 1.  See "
"`HYPRE_BoomerAMGSetCycleType`"
msgstr ""

#: ../../source/LinearSolvers.rst:594 75c51ada71fd4d25b83f8a0c7f92545f
msgid ""
":cpp:`hypre.bamg_relax_type`: Default 6.  See "
"`HYPRE_BoomerAMGSetRelaxType`"
msgstr ""

#: ../../source/LinearSolvers.rst:596 f3d94e132f0842abbf509c70eb2a6625
msgid ""
":cpp:`hypre.bamg_relax_order`: Default 1.  See "
"`HYPRE_BoomerAMGSetRelaxOrder`"
msgstr ""

#: ../../source/LinearSolvers.rst:598 11dbf2221be4437089ef89026235c70d
msgid ""
":cpp:`hypre.bamg_num_sweeps`: Default 2.  See "
"`HYPRE_BoomerAMGSetNumSweeps`"
msgstr ""

#: ../../source/LinearSolvers.rst:600 8ae52a425dbf46aaa7ed81f7060606ba
msgid ""
":cpp:`hypre.bamg_max_levels`: Default 20.  See "
"`HYPRE_BoomerAMGSetMaxLevels`"
msgstr ""

#: ../../source/LinearSolvers.rst:602 228df07f0aee4dbfad3aa12f75438138
msgid ""
":cpp:`hypre.bamg_strong_threshold`: Default 0.25 for 2D, 0.57 for 3D.  "
"See `HYPRE_BoomerAMGSetStrongThreshold`"
msgstr ""

#: ../../source/LinearSolvers.rst:604 460fa58d84c44ca390e68f658452c898
msgid ""
":cpp:`hypre.bamg_interp_type`:  Default 0.  See "
"`HYPRE_BoomerAMGSetInterpType`"
msgstr ""

#: ../../source/LinearSolvers.rst:606 d2906b9222ae4ac49996d6cbdade2a65
msgid ""
"The user is referred to the `hypre <https://computing.llnl.gov/projects"
"/hypre-scalable-linear-solvers-multigrid-methods>`_ Hypre Reference "
"Manual for full details on the usage of the parameters described briefly "
"above."
msgstr ""

#: ../../source/LinearSolvers.rst:609 182b8cf14bed4db5a0a5bba46537fe50
msgid ""
"AMReX can also use `PETSc <https://www.mcs.anl.gov/petsc/>`_ as a bottom "
"solver for cell-centered problems. To build PETSc, follow the next steps:"
msgstr ""

#: ../../source/LinearSolvers.rst:624 fac8388d977046a0966405daa013c6c6
msgid ""
"To use PETSc, one must include ``amrex/Src/Extern/PETSc`` in the build "
"system.  For an example of using PETSc, we refer the reader to the "
"tutorial, `ABecLaplacian`_."
msgstr ""

#: ../../source/LinearSolvers.rst:629 f3f7f41e064b455f9671c7adb28d7795
msgid "Tensor Solve"
msgstr ""

#: ../../source/LinearSolvers.rst:631 1599126a19b64fd8a23bf1ee4b2ae596
msgid ""
"Application codes that solve the Navier-Stokes equations need to evaluate"
" the viscous term;  solving for this term implicitly requires a multi-"
"component solve with cross terms.  Because this is a commonly used motif,"
" we provide a tensor solve for cell-centered velocity components."
msgstr ""

#: ../../source/LinearSolvers.rst:636 c1901869c1b04b6a87ae3da36cdaf77c
msgid ""
"Consider a velocity field :math:`U = (u,v,w)` with all components co-"
"located on cell centers.  The viscous term can be written in vector form "
"as"
msgstr ""

#: ../../source/LinearSolvers.rst:639 2ff5f0af214b4f34a17f7aef323edac5
msgid ""
"\\nabla \\cdot (\\eta \\nabla U) + \\nabla \\cdot (\\eta (\\nabla U)^T ) "
"+ \\nabla \\cdot ( (\\kappa - \\frac{2}{3} \\eta) (\\nabla \\cdot U) )"
msgstr ""

#: ../../source/LinearSolvers.rst:643 b08be6c5bb374e699e2bb31d4f661b2c
msgid "and in 3-d Cartesian component form as"
msgstr ""

#: ../../source/LinearSolvers.rst:645 22a69f98880a472baf1a87be3ebbcc3d
msgid ""
"( (\\eta u_x)_x + (\\eta u_y)_y + (\\eta u_z)_z ) + ( (\\eta u_x)_x + "
"(\\eta v_x)_y + (\\eta w_x)_z ) +  ( (\\kappa - \\frac{2}{3} \\eta) "
"(u_x+v_y+w_z) )_x\n"
"\n"
"( (\\eta v_x)_x + (\\eta v_y)_y + (\\eta v_z)_z ) + ( (\\eta u_y)_x + "
"(\\eta v_y)_y + (\\eta w_y)_z ) +  ( (\\kappa - \\frac{2}{3} \\eta) "
"(u_x+v_y+w_z) )_y\n"
"\n"
"( (\\eta w_x)_x + (\\eta w_y)_y + (\\eta w_z)_z ) + ( (\\eta u_z)_x + "
"(\\eta v_z)_y + (\\eta w_z)_z ) +  ( (\\kappa - \\frac{2}{3} \\eta) "
"(u_x+v_y+w_z) )_z"
msgstr ""

#: ../../source/LinearSolvers.rst:654 7b3b2b3efacc49409dd33d1af0e02746
msgid ""
"Here :math:`\\eta` is the dynamic viscosity and :math:`\\kappa` is the "
"bulk viscosity."
msgstr ""

#: ../../source/LinearSolvers.rst:656 63f19742d1c24f72aa02a9ed2ad0dc58
msgid ""
"We evaluate the following terms from the above using the "
"``MLABecLaplacian`` and ``MLEBABecLaplacian`` operators;"
msgstr ""

#: ../../source/LinearSolvers.rst:658 0397cdd3f03a445d8dc1c55db48184c3
msgid ""
"( (\\frac{4}{3} \\eta + \\kappa) u_x)_x + (              \\eta           "
"u_y)_y + (\\eta u_z)_z\n"
"\n"
"              (\\eta           v_x)_x + ( (\\frac{4}{3} \\eta + \\kappa) "
"v_y)_y + (\\eta v_z)_z\n"
"\n"
" (\\eta w_x)_x                        + (              \\eta           "
"w_y)_y + ( (\\frac{4}{3} \\eta + \\kappa) w_z)_z"
msgstr ""

#: ../../source/LinearSolvers.rst:666 2933960cfe774a62bb920f4d546cfbd0
msgid ""
"the following cross-terms are evaluated separately using the "
"``MLTensorOp`` and ``MLEBTensorOp`` operators."
msgstr ""

#: ../../source/LinearSolvers.rst:668 869d59e38ef945578c2d6e42989bd246
msgid ""
"( (\\kappa - \\frac{2}{3} \\eta) (v_y + w_z) )_x + (\\eta v_x)_y  + "
"(\\eta w_x)_z\n"
"\n"
"(\\eta u_y)_x + ( (\\kappa - \\frac{2}{3} \\eta) (u_x + w_z) )_y  + "
"(\\eta w_y)_z\n"
"\n"
"(\\eta u_z)_x + (\\eta v_z)_y - ( (\\kappa - \\frac{2}{3} \\eta) (u_x + "
"v_y) )_z"
msgstr ""

#: ../../source/LinearSolvers.rst:676 b208b8275c9444b9b043ed895e90957b
msgid ""
"The code below is an example of how to set up the solver to compute the "
"viscous term `divtau` explicitly:"
msgstr ""

#: ../../source/LinearSolvers.rst:745 39332a67277040519224700ff17249b0
msgid "Multi-Component Operators"
msgstr ""

#: ../../source/LinearSolvers.rst:747 db09c8dbd1484d1bb76c0fcb972c6885
msgid ""
"This section discusses solving linear systems in which the solution "
"variable :math:`\\mathbf{\\phi}` has multiple components. An example "
"(implemented in the ``MultiComponent`` tutorial) might be:"
msgstr ""

#: ../../source/LinearSolvers.rst:750 6b22b8f8d2984b72b479ab9d74d2c6de
msgid "D(\\mathbf{\\phi})_i = \\sum_{i=1}^N \\alpha_{ij} \\nabla^2 \\phi_j"
msgstr ""

#: ../../source/LinearSolvers.rst:754 0b757b363a9f4610b51e95729c1eabda
msgid ""
"(Note: only operators of the form "
":math:`D:\\mathbb{R}^n\\to\\mathbb{R}^n` are currently allowed.)"
msgstr ""

#: ../../source/LinearSolvers.rst:756 bdda8d89b93a4adeb6f57eb726b1018f
msgid ""
"To implement a multi-component *cell-based* operator, inherit from the "
"``MLCellLinOp`` class. Override the ``getNComp`` function to return the "
"number of components (``N``)that the operator will use. The solution and "
"rhs fabs must also have at least one ghost node. ``Fapply``, ``Fsmooth``,"
" ``Fflux`` must be implemented such that the solution and rhs fabs all "
"have ``N`` components."
msgstr ""

#: ../../source/LinearSolvers.rst:761 81a562015975423f9b577265ce7fef49
msgid ""
"Implementing a multi-component *node-based* operator is slightly "
"different. A MC nodal operator must specify that the reflux-free "
"coarse/fine strategy is being used by the solver."
msgstr ""

#: ../../source/LinearSolvers.rst:768 43981ebb3aba470c86da1df738cfaf34
msgid ""
"The reflux-free method circumvents the need to implement a special "
"``reflux`` at the coarse-fine boundary. This is accomplished by using "
"ghost nodes. Each AMR level must have 2 layers of ghost nodes. The second"
" (outermost) layer of nodes is treated as constant by the relaxation, "
"essentially acting as a Dirichlet boundary. The first layer of nodes is "
"evolved using the relaxation, in the same manner as the rest of the "
"solution. When the residual is restricted onto the coarse level (in "
"``reflux``) this allows the residual at the coarse-fine boundary to be "
"interpolated using the first layer of ghost nodes. "
":numref:`fig::refluxfreecoarsefine` illustrates the how the coarse-fine "
"update takes place."
msgstr ""

#: ../../source/LinearSolvers.rst:782 9a5d197f23d14017b04f279b9dd9f023
msgid ""
"Reflux-free coarse-fine boundary update. Level 2 ghost nodes (small dark "
"blue) are interpolated from coarse boundary. Level 1 ghost nodes are "
"updated during the relaxation along with all the other interior fine "
"nodes. Coarse nodes (large blue) on the coarse/fine boundary are updated "
"by restricting with interior nodes and the first level of ghost nodes. "
"Coarse nodes underneath level 2 ghost nodes are not updated. The "
"remaining coarse nodes are updates by restriction."
msgstr ""

#: ../../source/LinearSolvers.rst:790 a3deed5a99894a39975d4cb4019a086a
msgid ""
"The MC nodal operator can inherit from the ``MCNodeLinOp`` class. "
"``Fapply``, ``Fsmooth``, and ``Fflux`` must update level 1 ghost nodes "
"that are inside the domain. `interpolation` and `restriction` can be "
"implemented as usual. `reflux` is a straightforward restriction from fine"
" to coarse, using level 1 ghost nodes for restriction as described above."
msgstr ""

#: ../../source/LinearSolvers.rst:795 dccf39655b234fbaa21426e0bd70721c
msgid ""
"See ``amrex-tutorials/ExampleCodes/LinearSolvers/MultiComponent`` for a "
"complete working example."
msgstr ""

