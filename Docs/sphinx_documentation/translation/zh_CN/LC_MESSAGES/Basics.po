# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/Basics.rst:10 6da7854021b84184a3db529e60416242
msgid "Dimensionality"
msgstr "维度"

#: ../../source/Basics.rst:12 9d6ca061b6144d43969b06e746395b05
msgid ""
"As we have mentioned in :ref:`Chap:BuildingAMReX`, the dimensionality of AMReX must be set at compile time. A macro, "
"``AMREX_SPACEDIM``, is defined to be the number of spatial dimensions. C++ codes can also use the "
":cpp:`amrex::SpaceDim` variable. Fortran codes can use either the macro and preprocessing or do"
msgstr ""
"正如我们在 :ref:`Chap:BuildingAMReX` 中提到的，AMReX 的维度必须在编译时设置。一个名为 ``AMREX_SPACEDIM`` 的宏被定义为空间维度的数量。C++ 代码也可以使用 "
":cpp:`amrex::SpaceDim` 变量。Fortran 代码可以使用宏和预处理，或者可以使用"

#: ../../source/Basics.rst:24 20a31c161c8d46b19c3e74934e6bf346
msgid "The coordinate directions are zero based."
msgstr "坐标方向从零开始计数。"

#: ../../source/Basics.rst:29 626c8d609cf04d59a2e1c7093e6e1329
msgid "Vector, Array, GpuArray, Array1D, Array2D, and Array3D"
msgstr "向量，数组，GPU数组，一维数组，二维数组和三维数组"

#: ../../source/Basics.rst:31 561aadc140ec4e8194cb02a132f25d36
msgid ""
":cpp:`Vector` class in ``AMReX_Vector.H`` is derived from :cpp:`std::vector`. The main difference between :cpp:`Vector` "
"and :cpp:`std::vector` is that :cpp:`Vector::operator[]` provides bound checking when compiled with :cpp:`DEBUG=TRUE`."
msgstr ""
"在 `AMReX_Vector.H` 中，`Vector` 类是从 `std::vector` 派生而来的。`Vector` 和 `std::vector` 的主要区别在于，当以 `DEBUG=TRUE` "
"编译时，`Vector::operator[]` 提供了边界检查功能。"

#: ../../source/Basics.rst:36 4501ae1ea16141eda0a29fe3d5b5b901
msgid ""
":cpp:`Array` class in ``AMReX_Array.H`` is simply an alias to :cpp:`std::array`. AMReX also provides :cpp:`GpuArray`, a "
"trivial type that works on both host and device. (It was added when the minimal requirement for C++ standard was C++11, "
"for which :cpp:`std::array` does not work on device.) It also works when compiled just for CPU.  Besides "
":cpp:`GpuArray`, AMReX also provides GPU safe :cpp:`Array1D`, :cpp:`Array2D` and :cpp:`Array3D` that are 1, 2 and "
"3-dimensional fixed size arrays, respectively.  These three class templates can have non-zero based indexing."
msgstr ""
"在 `AMReX_Array.H` 中，`Array` 类是对 `std::array` 的简单别名。AMReX 还提供了 `GpuArray`，这是一个在主机和设备上都可以使用的简单类型。当 C++ 标准的最低要求是 C++11 "
"时（在此标准下，`std::array` 无法在设备上使用），我们添加了 `GpuArray`。它在仅编译为 CPU 时也可以使用。除了 `GpuArray`，AMReX 还提供了 GPU 安全的 `Array1D`、`Array2D` "
"和 `Array3D`，它们分别是一维、二维和三维的固定大小数组。这三个类模板支持非零基索引。"

#: ../../source/Basics.rst:46 cb8fbc9cac2241b28ead69970d3d27f5
msgid "Real"
msgstr "真实的"

#: ../../source/Basics.rst:48 5186ea0d618542ff993b92ab1a57196b
msgid ""
"AMReX can be compiled to use either double precision (which is the default) or single precision. :cpp:`amrex::Real` is "
"typedef'd to either :cpp:`double` or :cpp:`float`. C codes can use :cpp:`amrex_real`. They are defined in "
":cpp:`AMReX_REAL.H`. The data type is accessible in Fortran codes via"
msgstr ""
"AMReX可以编译为使用双精度（默认）或单精度。:cpp:`amrex::Real`被定义为:cpp:`double`或:cpp:`float`的typedef。C代码可以使用:cpp:`amrex_real`。它们在:cpp:`"
"AMReX_REAL.H`中定义。Fortran代码可以通过访问该数据类型。"

#: ../../source/Basics.rst:59 5814cdea24aa445d9db96477df2fe9d8
msgid ""
"In C++, AMReX also provides a user literal :cpp:`_rt` so that one can have a proper type for constants (e.g., "
":cpp:`2.7_rt`)."
msgstr "在C++中，AMReX还提供了一个用户字面量:cpp:`_rt`，以便用户可以为常量提供适当的类型（例如，:cpp:`2.7_rt`）。"

#: ../../source/Basics.rst:63 9abe29e59cda4af5a8c72f9baef712bb
msgid "Long"
msgstr "长"

#: ../../source/Basics.rst:65 8cf08fe600ad4686a9b1c80febb3a0e2
msgid ""
"AMReX defines a 64 bit integer type :cpp:`amrex::Long` that is an alias to :cpp:`long` on Unix-like systems and "
":cpp:`long long` on Windows.  In C, the type alias is :cpp:`amrex_long`.  In Fortran, one can use :cpp:`amrex_long` "
"defined in :cpp:`amrex_fort_module`."
msgstr ""
"AMReX定义了一个64位整数类型：cpp:`amrex::Long`，在类Unix系统上是cpp:`long`的别名，在Windows上是cpp:`long "
"long`的别名。在C语言中，类型别名是cpp:`amrex_long`。在Fortran中，可以使用cpp:`amrex_fort_module`中定义的cpp:`amrex_long`。"

#: ../../source/Basics.rst:73 33da9e23b2194fae85b2ac67388459d6
msgid "ParallelDescriptor"
msgstr "并行描述符"

#: ../../source/Basics.rst:75 755fc51051404d02b23c004662d7fc8a
msgid ""
"AMReX users do not need to use MPI directly. Parallel communication is often handled by the data abstraction classes "
"(e.g.,MultiFab; section on :ref:`sec:basics:multifab`). In addition, AMReX has provided namespace "
":cpp:`ParallelDescriptor` in ``AMReX_ParallelDescriptor.H.`` The frequently used functions are"
msgstr ""
"AMReX用户无需直接使用MPI。并行通信通常由数据抽象类（例如MultiFab；参见:ref:`sec:basics:multifab`部分）处理。此外，AMReX在``AMReX_ParallelDescriptor.H``"
"中提供了命名空间:cpp:`ParallelDescriptor`。常用的函数有："

#: ../../source/Basics.rst:105 5ebe75309c46431db5e141a95627b079
msgid ""
"Additionally, ``amrex_paralleldescriptor_module`` in ``Src/Base/AMReX_ParallelDescriptor_F.F90`` provides a number of "
"functions for Fortran."
msgstr "另外，在 ``Src/Base/AMReX_ParallelDescriptor_F.F90`` 中的 ``amrex_paralleldescriptor_module`` 提供了一些用于Fortran的函数。"

#: ../../source/Basics.rst:110 2ac2657f49274b73aabb603dc5d56cc9
msgid "ParallelContext"
msgstr "并行上下文"

#: ../../source/Basics.rst:112 dc76263c94fd4993bf2358d1257b232e
msgid ""
"Users can also use groups of MPI subcommunicators to perform simultaneous physics calculations.  These comms are "
"managed by AMReX's :cpp:`ParallelContext` in ``AMReX_ParallelContext.H.``  It maintains a stack of :cpp:`MPI_Comm` "
"handlers. A global comm is placed in the :cpp:`ParallelContext` stack during AMReX's initialization and additional "
"subcommunicators can be handled by adding comms with :cpp:`push(MPI_Comm)` and removed using :cpp:`pop()`.  This "
"creates a hierarchy of :cpp:`MPI_Comm` objects that can be used to split work as the user sees fit.   Note that "
"``ParallelDescriptor`` by default uses AMReX's base comm, independent of the status of the ``ParallelContext`` stack."
msgstr ""
"用户还可以使用MPI子通信器组来执行同时的物理计算。这些通信器由AMReX的`ParallelContext`在`AMReX_ParallelContext.H`中进行管理。它维护了一个`MPI_Comm`"
"处理器的堆栈。在AMReX的初始化过程中，全局通信器被放置在`ParallelContext`的堆栈中，可以通过使用`push(MPI_Comm)`添加通信器和使用`pop()`移除通信器来处理额外的子通信器。这样创建了一系列的`MPI_"
"Comm`对象，用户可以根据需要将工作分割。需要注意的是，默认情况下，`ParallelDescriptor`使用的是AMReX的基本通信器，与`ParallelContext`堆栈的状态无关。"

#: ../../source/Basics.rst:124 f7426ac6905044229b35e37163c4d19a
msgid ""
":cpp:`ParallelContext` also tracks and returns information about the local (most recently added) and global "
":cpp:`MPI_Comm`.  The most common access functions are given below.  See ``AMReX_ParallelContext.H.`` for a full "
"listing of the available functions."
msgstr ""
":cpp:`ParallelContext` 还会跟踪并返回有关本地（最近添加的）和全局 :cpp:`MPI_Comm` 的信息。下面是最常用的访问函数。有关可用函数的完整列表，请参阅 "
"``AMReX_ParallelContext.H.``。"

#: ../../source/Basics.rst:170 43573e033f3c4eea8e0595c92fa00d7b
msgid "Print"
msgstr "打印"

#: ../../source/Basics.rst:172 b436a77128f24f418335d953d8cf24e9
msgid ""
"AMReX provides classes in ``AMReX_Print.H`` for printing messages to standard output or any C++ :cpp:`ostream`. The "
"main reason one should use them instead of :cpp:`std::cout` is that messages from multiple processes or threads do not "
"get mixed up. Below are some examples."
msgstr "AMReX在``AMReX_Print.H``中提供了一些类，用于将消息打印到标准输出或任何C++的:cpp:`ostream`。使用它们而不是:cpp:`std::cout`的主要原因是多个进程或线程的消息不会混在一起。以下是一些示例。"

#: ../../source/Basics.rst:199 2a5c1694dc844f57a9166c523db5dbf7
msgid ""
"It should be emphasized that :cpp:`Print()` without any argument only prints on the I/O process.  A common mistake in "
"using it for debug printing is one forgets that for non-I/O processes to print we should use :cpp:`AllPrint()` or "
":cpp:`Print(rank)`."
msgstr "需要强调的是，如果没有任何参数，:cpp:`Print()` 只会在 I/O 进程上打印输出。在使用它进行调试打印时，常见的错误是忘记对非 I/O 进程使用 :cpp:`AllPrint()` 或 :cpp:`Print(rank)`。"

#: ../../source/Basics.rst:207 21a3577c040f4a1f975e1b31499c8d79
msgid "ParmParse"
msgstr "ParmParse"

#: ../../source/Basics.rst:209 11d160c5b2554687a887230d36cdaead
msgid ""
":cpp:`ParmParse` in AMReX_ParmParse.H is a class providing a database for the storage and retrieval of command-line and "
"input-file arguments. When :cpp:`amrex::Initialize(int& argc, char**& argv)` is called, the first command-line argument "
"after the executable name (if there is one, and it does not contain the character '=' or start with '\\-') is taken to "
"be the inputs file, and the contents of the file are used to initialize the :cpp:`ParmParse` database. The rest of the "
"command-line arguments are also parsed by :cpp:`ParmParse`, with the exception of those following a '\\-\\-' which "
"signals command line sharing (see section :ref:`sec:basics:parmparse:sharingCL` )."
msgstr ""
"在AMReX_ParmParse.H中，`ParmParse`是一个类，用于存储和检索命令行和输入文件参数的数据库。当调用`amrex::Initialize(int& argc, char**& "
"argv)`时，可执行文件名称后的第一个命令行参数（如果有的话，并且不包含字符'='或以'-'开头）被视为输入文件，并使用文件内容来初始化`ParmParse`数据库。其余的命令行参数也会被`ParmParse`解析，除非在'--'"
"之后，这表示命令行共享（参见第:ref:`sec:basics:parmparse:sharingCL`节）。"

#: ../../source/Basics.rst:220 3e5be38dcdf249a6ab8b6c5253b164c4
msgid "Inputs File"
msgstr "输入文件"

#: ../../source/Basics.rst:222 b1e2ef7dabcc4a49978a20052f556807
msgid ""
"The format of the inputs file is a series of definitions in the form of ``prefix.name = value value ....`` For each "
"line, text after # are comments. Here is an example inputs file."
msgstr "输入文件的格式是一系列以``prefix.name = value value ....``形式的定义。每行的#后面的文本是注释。以下是一个输入文件的示例。"

#: ../../source/Basics.rst:239 392f0013e5f244beb6756e7b45983b88
msgid "The following code shows how to use :cpp:`ParmParse` to get/query the values."
msgstr "下面的代码展示了如何使用 `ParmParse` 来获取/查询值。"

#: ../../source/Basics.rst:272 3031bddd2a4b4e2cbb3184c0cd94f951
msgid ""
"Note that when there are multiple definitions for a parameter :cpp:`ParmParse` by default returns the last one. The "
"difference between :cpp:`query` and :cpp:`get` should also be noted. It is a runtime error if :cpp:`get` fails to get "
"the value, whereas :cpp:`query` returns an error code without generating a runtime error that will abort the run."
msgstr ""
"请注意，当一个参数有多个定义时，默认情况下，:cpp:`ParmParse` 会返回最后一个定义。还需要注意 :cpp:`query` 和 :cpp:`get` 之间的区别。如果 :cpp:`get` 无法获取值，将会引发运行时错误，而 "
":cpp:`query` 则会返回一个错误代码，而不会生成会中止运行的运行时错误。"

#: ../../source/Basics.rst:279 70005ea540674164a8c620147e1b8c91
msgid "Overriding Parameters with Command-Line Arguments"
msgstr "使用命令行参数覆盖参数设置"

#: ../../source/Basics.rst:281 8be30b0101d447d7a5cf424aee7638ad
msgid ""
"It is sometimes convenient to override parameters with command-line arguments without modifying the inputs file. The "
"command-line arguments after the inputs file are added later than the file to the database and are therefore used by "
"default. For example, to change the value of :cpp:`ncells` and :cpp:`hydro.cfl`, one can run with:"
msgstr "有时候，通过命令行参数覆盖参数而无需修改输入文件是很方便的。输入文件后的命令行参数会在文件之后添加到数据库中，并且默认情况下会被使用。例如，要更改 `ncells` 和 `hydro.cfl` 的值，可以运行以下命令："

#: ../../source/Basics.rst:296 28109f09ba494e56bd6446dab0926d2c
msgid "Setting Parameter Values Inside Functions"
msgstr "在函数内部设置参数值"

#: ../../source/Basics.rst:298 eb72a6c7936042a18309525073482f93
msgid ""
"An application code may want to set values or defaults that differ from the those in AMReX in a function. This is "
"accomplished in two steps:"
msgstr "一个应用程序代码可能希望在函数中设置与AMReX中不同的值或默认值。这可以通过以下两个步骤来实现："

#: ../../source/Basics.rst:301 73a777887fe64aaa912157c959b4fbbd
msgid "First, define a function that sets the variable(s)."
msgstr "首先，定义一个函数来设置变量（或变量）。"

#: ../../source/Basics.rst:303 a06ae6061ffe47548bae33a3da39edc5
msgid "Second, pass the name of that function to :cpp:`amrex::Initialize`."
msgstr "其次，将该函数的名称传递给 :cpp:`amrex::Initialize`。"

#: ../../source/Basics.rst:305 842ad903c2154c2fa3c1314b56d66b06
msgid ""
"The example function below sets variable values using two different approaches to highlight subtle differences in "
"implementation:"
msgstr "下面的示例函数使用两种不同的方法设置变量值，以突出实现上的细微差别："

#: ../../source/Basics.rst:322 97ac77b1af624dd79c5564ae9960413e
msgid ""
"First this function, :cpp:`add_par`, declares a ``ParmParse`` object that will be used to set variables. In the next "
"section of code, we check if the value for ``variable_one`` has already been set elsewhere before writing to it. This "
"approach prevents the function from overriding a value set in the inputs file or at the command line. In the next "
"section, we write a value to ``variable_two`` without a conditional statement. In this case, we will ignore values for "
"``variable_two`` set in the inputs file or as a command line argument ---effectively overriding them with the value set "
"here in the function."
msgstr ""
"首先，这个函数`:cpp:`add_par`会声明一个``ParmParse``对象，用于设置变量。在代码的下一个部分，我们会检查``variable_one``"
"的值是否已经在其他地方设置过，然后再进行赋值。这种方法可以防止函数覆盖在输入文件或命令行中设置的值。在接下来的部分，我们会直接给``variable_two``赋值，而不使用条件语句。在这种情况下，我们会忽略在输入文件或命令行中设置的``"
"variable_two``的值，而是使用函数中设置的值来覆盖它们。"

#: ../../source/Basics.rst:332 785bf07d62134fd983ac5e9f168a5a6b
msgid ""
"In the second step, we pass the name of the function we defined to ``amrex::Initialize``. In the example above the "
"function was called ``add_par``, and therefore we write,"
msgstr "在第二步中，我们将我们定义的函数的名称传递给``amrex::Initialize``。在上面的示例中，函数被称为``add_par``，因此我们写成："

#: ../../source/Basics.rst:339 d95984dfe77841d1a94177d3cbdabfb6
msgid "Now AMReX will use the user defined function to appropriately set the desired values."
msgstr "现在，AMReX将使用用户定义的函数来适当地设置所需的值。"

#: ../../source/Basics.rst:344 869b35d050e940a8b3ab43f33dea0432
msgid "Sharing the Command Line"
msgstr "分享命令行"

#: ../../source/Basics.rst:346 6a59f2bd009845d0993c4d722cfc751e
msgid ""
"In some cases we want AMReX to only read some of the command line arguments -- this happens, for example, when we are "
"going to use AMReX in cooperation with another code package and that code also takes arguments."
msgstr "在某些情况下，我们希望AMReX仅读取部分命令行参数 -- 例如，当我们打算与另一个代码包合作使用AMReX，并且该代码包也接受参数时，就会发生这种情况。"

#: ../../source/Basics.rst:350 7ab27084f0ff4f739eb4b4ffb7b5520b
msgid "Consider:"
msgstr "请考虑以下内容："

#: ../../source/Basics.rst:358 8149f453f7444dedbe4d47a9d3fb0fb6
msgid ""
"In this example, AMReX will parse the inputs file and the optional AMReX command line arguments, but will ignore "
"arguments after the double dashes."
msgstr "在这个示例中，AMReX将解析输入文件和可选的AMReX命令行参数，但会忽略双破折号后的参数。"

#: ../../source/Basics.rst:362 954b584418934c329cd0a6243b3d3ee2
msgid "Command Line Flags"
msgstr "命令行标志"

#: ../../source/Basics.rst:364 f67cf31905854fcaa480186f78ccf4b6
msgid ""
"AMReX allows application codes to parse flags such as ``-h`` or ``--help`` while still making use of ParmParse for "
"parsing other runtime parameters but only if it is the first argument after the executable. If the first argument "
"following the executable name begins with a dash, AMReX will initialize without reading any parameters and the "
"application code may then parse the command line and handle those cases. Several built in functions are available to "
"help do this. They are briefly introduced in the table below."
msgstr ""
"AMReX允许应用程序代码解析诸如``-h``或``--help``"
"之类的标志，同时仍然利用ParmParse来解析其他运行时参数，但前提是它是可执行文件之后的第一个参数。如果紧跟可执行文件名称的第一个参数以破折号开头，AMReX将在不读取任何参数的情况下进行初始化，然后应用程序代码可以解析命令行并处理这些"
"情况。有几个内置函数可用于帮助实现此功能。它们在下表中简要介绍如下。"

#: ../../source/Basics.rst:372 f8cce65caed64065b13c8f0c511990f2
msgid "AMReX functions for parsing the command line."
msgstr "AMReX函数用于解析命令行。"

#: ../../source/Basics.rst:375 7d16e8aa986b4426a0ae81bb71f44eac
msgid "Function"
msgstr "功能"

#: ../../source/Basics.rst:375 84ece13d107a4168a40137b77b977330
msgid "Type"
msgstr "输入"

#: ../../source/Basics.rst:375 1e13f6a205084eb6aa18d5a7003a0b6d
msgid "Purpose"
msgstr "目的"

#: ../../source/Basics.rst:377 8adc957ea8544c7e8abd673b36aa465a
msgid "``amrex::get_command()``"
msgstr "``amrex::get_command()``"

#: ../../source/Basics.rst:377 ../../source/Basics.rst:382
#: 25f1dcba813d4c7d81c6d7f66c0b9441 d14c58fd80364f059bf6d7990b729cc2
msgid "String"
msgstr "字符串"

#: ../../source/Basics.rst:377 b3410c2395fe44ec9681370a70fabebc
msgid "Get the entire command line."
msgstr "获取完整的命令行。"

#: ../../source/Basics.rst:379 8af32b4a88984a2dacd0b3a71290ca4c
msgid "``amrex::get_argument_count()``"
msgstr ""
"``amrex::get_argument_count()``\n"
"\n"
"``amrex::get_argument_count()``"

#: ../../source/Basics.rst:379 3e5b294d589243718610cdba87be30ec
msgid "Int"
msgstr "Int"

#: ../../source/Basics.rst:379 03271f130c0141b9bffed4358ab42b0c
msgid "Get the number of command line arguments after the executable."
msgstr "获取可执行文件后的命令行参数数量。"

#: ../../source/Basics.rst:382 cd55592fe704444c96a7f9453c0fa1d6
msgid "``amrex:get_command_argument(int n)``"
msgstr ""
"``amrex:get_command_argument(int n)``\n"
"\n"
"``amrex:get_command_argument(int n)``"

#: ../../source/Basics.rst:382 58ec24cb13904767933317c1c3ffd259
msgid "Returns the n-th argument after the executable."
msgstr "返回可执行文件后的第 n 个参数。"

#: ../../source/Basics.rst:392 28214fe0218a49689a5c2fbfd8a8eb72
msgid "Parser"
msgstr "解析器"

#: ../../source/Basics.rst:394 9eb7141bf87c48fd9f9d0aa464cba77e
msgid ""
"AMReX provides a parser in ``AMReX_Parser.H`` that can be used at runtime to evaluate mathematical expressions given in "
"the form of string.  It supports ``+``, ``-``, ``*``, ``/``, ``**`` (power), ``^`` (power), ``sqrt``, ``exp``, ``log``, "
"``log10``, ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``atan2``, ``sinh``, ``cosh``, ``tanh``, ``asinh``, "
"``acosh``, ``atanh``, ``abs``, ``floor``, ``ceil`` and ``fmod``. The minimum and maximum of two numbers can be computed "
"with ``min`` and ``max``, respectively.  It supports the Heaviside step function, ``heaviside(x1,x2)`` that gives "
"``0``, ``x2``, ``1``, for ``x1 < 0``, ``x1 = 0`` and ``x1 > 0``, respectively. It supports the Bessel function of the "
"first kind of order ``n`` ``jn(n,x)``. Complete elliptic integrals of the first and second kind, ``comp_ellint_1`` and "
"``comp_ellint_2``, are supported only for gcc and CPUs. There is ``if(a,b,c)`` that gives ``b`` or ``c`` depending on "
"the value of ``a``.  A number of comparison operators are supported, including ``<``, ``>``, ``==``, ``!=``, ``<=``, "
"and ``>=``.  The Boolean results from comparison can be combined by ``and`` and ``or``, and they hold the value ``1`` "
"for true and ``0`` for false.  The precedence of the operators follows the convention of the C and C++ programming "
"languages.  Here is an example of using the parser."
msgstr ""
"AMReX在``AMReX_Parser.H``中提供了一个解析器，可以在运行时使用字符串形式的数学表达式进行求值。它支持``+``、``-``、``*``、``/``、``**``（幂）、``^``（幂）、``sqrt``、``exp``"
"、``log``、``log10``、``sin``、``cos``、``tan``、``asin``、``acos``、``atan``、``atan2``、``sinh``、``cosh``、``tanh``、``asinh``、``"
"acosh``、``atanh``、``abs``、``floor``、``ceil``和``fmod``等运算符。可以使用``min``和``max``分别计算两个数的最小值和最大值。它支持阶跃函数``heaviside(x1,x2)``"
"，当``x1 < 0``时返回``0``，当``x1 = 0``时返回``x2``，当``x1 > "
"0``时返回``1``。它支持一阶贝塞尔函数``jn(n,x)``。只有在gcc和CPU上才支持完整的第一类和第二类完全椭圆积分``comp_ellint_1``和``comp_ellint_2``。还有一个条件表达式``if(a,b,c)"
"``，根据``a``的值返回``b``或``c``。支持多个比较运算符，包括``<``、``>``、``==``、``!=``、``<=``和``>=``。比较的布尔结果可以通过``and``和``or``进行组合，``1``表示真，``0"
"``表示假。运算符的优先级遵循C和C++编程语言的约定。以下是使用解析器的示例。"

#: ../../source/Basics.rst:435 a1ea9ec710a64447ae7a59576b2e32bc
msgid "Local automatic variables can be defined in the expression.  For example,"
msgstr "在表达式中可以定义本地自动变量。例如，"

#: ../../source/Basics.rst:446 3af822b55f4f48139ac4e267680100f8
msgid ""
"Note that an assignment to an automatic variable must be terminated with ``;``, and one should avoid name conflict "
"between the local variables and the constants set by :cpp:`setConstant` and the variables registered by "
":cpp:`registerVariables`."
msgstr "请注意，对于自动变量的赋值必须以“;”结尾，并且应避免局部变量与由`setConstant`设置的常量以及由`registerVariables`注册的变量之间的名称冲突。"

#: ../../source/Basics.rst:451 fddb36de664743a5b50c0c81d3cb18ab
msgid ""
"Besides :cpp:`amrex::Parser` for floating point numbers, AMReX also provides :cpp:`amrex::IParser` for integers.  The "
"two parsers have a lot of similarity, but floating point number specific functions (e.g., ``sqrt``, ``sin``, etc.) are "
"not supported in ``IParser``.  In addition to ``/`` whose result truncates towards zero, the integer parser also "
"supports ``//`` whose result truncates towards negative infinity."
msgstr ""
"除了用于浮点数的`amrex::Parser`之外，AMReX还提供了用于整数的`amrex::IParser`。这两个解析器有很多相似之处，但是整数解析器`IParser`不支持特定于浮点数的函数（例如`sqrt`，`sin`"
"等）。除了结果向零截断的`/`运算符外，整数解析器还支持结果向负无穷截断的`//`运算符。"

#: ../../source/Basics.rst:461 b064ce7c98ec4d77931072e3c3eabc1a
msgid "Initialize and Finalize"
msgstr "初始化和完成"

#: ../../source/Basics.rst:463 70ea8f59a19b49a4b8fc4e5eb24d0a0c
msgid ""
"As we have mentioned, :cpp:`Initialize` must be called to initialize the execution environment for AMReX and "
":cpp:`Finalize` must be paired with :cpp:`Initialize` to release the resources used by AMReX.  There are two versions "
"of :cpp:`Initialize`."
msgstr ""
"正如我们之前提到的，必须调用 :cpp:`Initialize` 来初始化 AMReX 的执行环境，并且 :cpp:`Finalize` 必须与 :cpp:`Initialize` 成对使用，以释放 AMReX "
"使用的资源。:cpp:`Initialize` 有两个版本。"

#: ../../source/Basics.rst:484 c6915d4b5de14a6598f4e57d12466dda
msgid ""
":cpp:`Initialize` tests if MPI has been initialized.  If MPI has been initialized, AMReX will duplicate the "
"``MPI_Comm`` argument.  If not, AMReX will initialize MPI and ignore the ``MPI_Comm`` argument."
msgstr ":cpp:`Initialize`函数用于检查MPI是否已经初始化。如果MPI已经初始化，AMReX将复制``MPI_Comm``参数。如果尚未初始化，AMReX将初始化MPI并忽略``MPI_Comm``参数。"

#: ../../source/Basics.rst:488 0a9f109007d041cfa0d0301c09e4dc3e
msgid ""
"Both versions have two optional :cpp:`std::ostream` parameters, one for standard output in :cpp:`Print` (section "
":ref:`sec:basics:print`) and the other for standard error, and they can be accessed with functions :cpp:`OutStream()` "
"and :cpp:`ErrorStream()`.  Both versions can also take an optional error handler function.  If it is provided by the "
"user, AMReX will use it to handle errors and signals. Otherwise, AMReX will use its own function for error and signal "
"handling."
msgstr ""
"两个版本都有两个可选的 `std::ostream` 参数，一个用于 `Print`（第 `sec:basics:print` 节）中的标准输出，另一个用于标准错误输出，并且可以通过 `OutStream()` 和 "
"`ErrorStream()` 函数进行访问。两个版本还可以接受一个可选的错误处理函数。如果用户提供了错误处理函数，AMReX 将使用它来处理错误和信号。否则，AMReX 将使用自己的函数来处理错误和信号。"

#: ../../source/Basics.rst:497 c04ac053c195473ca82081492b777884
msgid ""
"The first version of :cpp:`Initialize` does not parse the command line options, whereas the second version will build "
"ParmParse database (section :ref:`sec:basics:parmparse`) unless ``build_parm_parse`` parameter is :cpp:`false`.  In the "
"second version, one can pass a function that adds ParmParse parameters to the database instead of reading from command "
"line or input file."
msgstr ""
"第一个版本的 `Initialize` 函数不解析命令行选项，而第二个版本会构建 ParmParse 数据库（参见 :ref:`sec:basics:parmparse`），除非 `build_parm_parse` 参数为 "
"`false`。在第二个版本中，可以传递一个函数来向数据库添加 ParmParse 参数，而不是从命令行或输入文件中读取。"

#: ../../source/Basics.rst:504 61f92bbb4a044dda8da19f92ae10d048
msgid ""
"Because many AMReX classes and functions (including destructors inserted by the compiler) do not function properly "
"after :cpp:`amrex:Finalize` is called, it's best to put the codes between :cpp:`amrex::Initialize` and "
":cpp:`amrex::Finalize` into its scope (e.g., a pair of curly braces or a separate function) to make sure resources are "
"properly freed."
msgstr ""
"由于许多 AMReX 类和函数（包括编译器插入的析构函数）在调用 :cpp:`amrex:Finalize` 后无法正常工作，最好将代码放在 :cpp:`amrex::Initialize` 和 "
":cpp:`amrex::Finalize` 之间的作用域内（例如一对花括号或一个单独的函数），以确保资源被正确释放。"

#: ../../source/Basics.rst:515 7091e6e62ff1441aa162cee70c579412
msgid "Example of AMR Grids"
msgstr "AMR网格的示例"

#: ../../source/Basics.rst:517 07d1cdc9221a452c8f9b3899b392ced5
msgid ""
"In block-structured AMR, there is a hierarchy of logically rectangular grids. The computational domain on each AMR "
"level is decomposed into a union of rectangular domains. :numref:`fig:basics:amrgrids` below shows an example of AMR "
"with three total levels.  In the AMReX numbering convention, the coarsest level is level 0. The coarsest grid (*black*) "
"covers the domain with :math:`16^2` cells. Bold lines represent grid boundaries. There are two intermediate resolution "
"grids (*blue*) at level 1 and the cells are a factor of two finer than those at level 0. The two finest grids (*red*) "
"are at level 2 and the cells are a factor of two finer than the level 1 cells. There are 1, 2 and 2 Boxes on levels 0, "
"1, and 2, respectively. Note that there is no direct parent-child connection. In this chapter, we will focus on single "
"levels."
msgstr ""
"在块结构的AMR中，存在一系列逻辑上矩形的网格层次结构。每个AMR级别上的计算域被分解为一组矩形域的并集。下面的:numref:`fig:basics:amrgrids`"
"示例展示了具有三个总级别的AMR。按照AMReX的编号约定，最粗糙的级别为级别0。最粗糙的网格（黑色）覆盖了具有:math:`16^2`个单元的域。粗线表示网格边界。在级别1上有两个中等分辨率的网格（蓝色），其单元比级别0"
"上的单元细一倍。最细的两个网格（红色）位于级别2上，其单元比级别1上的单元细一倍。在级别0、1和2上分别有1、2和2个方块。请注意，这里没有直接的父子连接。在本章中，我们将重点关注单个级别。"

#: ../../source/Basics.rst:538 78fa48afb77b4492979a26c30666451b
msgid "Example of AMR grids. There are three levels in total. There are 1, 2 and 2 Boxes on levels 0, 1, and 2, respectively."
msgstr "AMR网格的示例。总共有三个层级。在层级0、1和2上分别有1、2和2个方块。"

#: ../../source/Basics.rst:549 3d46061863924c4e99081e9e0e13fde5
msgid "Box, IntVect and IndexType"
msgstr "盒子，整数向量和索引类型"

#: ../../source/Basics.rst:551 c443d859dbda47edbbca03616734428e
msgid ""
":cpp:`Box` in AMReX_Box.H is the data structure for representing a rectangular domain in indexing space.  In "
":numref:`fig:basics:amrgrids`, there are 1, 2 and 2 Boxes on levels 0, 1 and 2, respectively.  :cpp:`Box` is a "
"dimension-dependent class. It has lower and upper corners (represented by :cpp:`IntVect`) and an index type "
"(represented by :cpp:`IndexType`). A :cpp:`Box` contains no floating-point data."
msgstr ""
"在 AMReX_Box.H 中，`Box` 是用于表示索引空间中矩形域的数据结构。在图 1.2 中，分别在级别 0、1 和 2 上有 1、2 和 2 个 `Box`。`Box` 是一个依赖于维度的类。它具有下界和上界角点（由 "
"`IntVect` 表示），以及索引类型（由 `IndexType` 表示）。`Box` 不包含任何浮点数据。"

#: ../../source/Basics.rst:559 9baaae8f156f481484c6997120179d98
msgid "IntVect"
msgstr "整数向量"

#: ../../source/Basics.rst:561 915ac27cc3e349b4b349333bcf047a58
msgid ""
":cpp:`IntVec` is a dimension-dependent class representing an integer vector in :cpp:`AMREX_SPACEDIM`-dimensional space. "
"An :cpp:`IntVect` can be constructed as follows,"
msgstr "`IntVec`是一个与维度相关的类，表示一个在`AMREX_SPACEDIM`维空间中的整数向量。可以按照以下方式构造一个`IntVect`对象："

#: ../../source/Basics.rst:571 638ad78f0fef4fd1af0a1701bac1dd5c
msgid ""
"Here :cpp:`AMREX_D_DECL` is a macro that expands :cpp:`AMREX_D_DECL(19,0,5)` to either :cpp:`19` or :cpp:`19, 0` or "
":cpp:`19, 0, 5` depending on the number of dimensions. The data can be accessed via :cpp:`operator[]`, and the internal "
"data pointer can be returned by function :cpp:`getVect`. For example"
msgstr ""
"在这里，`AMREX_D_DECL` 是一个宏，将 `AMREX_D_DECL(19,0,5)` 展开为 `19` 或 `19, 0` 或 `19, 0, 5`，取决于维度的数量。数据可以通过 `operator[]` "
"访问，内部数据指针可以通过 `getVect` 函数返回。例如，"

#: ../../source/Basics.rst:585 510a19e69c4145a2bcd7399ac23f6788
msgid ""
"The class has a static function :cpp:`TheZeroVector()` returning the zero vector, :cpp:`TheUnitVector()` returning the "
"unit vector, and :cpp:`TheDimensionVector (int dir)` returning a reference to a constant :cpp:`IntVect` that is zero "
"except in the :cpp:`dir`-direction. Note the direction is zero-based. :cpp:`IntVect` has a number of relational "
"operators, :cpp:`==`, :cpp:`!=`, :cpp:`<`, :cpp:`<=`, :cpp:`>` , and :cpp:`>=` that can be used for lexicographical "
"comparison (e.g., key of :cpp:`std::map`), and a class :cpp:`IntVect::shift_hasher` that can be used as a hash function "
"(e.g., for :cpp:`std::unordered_map`). It also has various arithmetic operators. For example,"
msgstr ""
"该类具有一个静态函数：cpp:`TheZeroVector()` 返回零向量，cpp:`TheUnitVector()` 返回单位向量，以及 cpp:`TheDimensionVector(int dir)` 返回一个常量引用 "
"cpp:`IntVect`，该向量在除了 cpp:`dir`-方向以外都为零。请注意，方向是从零开始计数的。cpp:`IntVect` "
"还具有一些关系运算符，cpp:`==`、cpp:`!=`、cpp:`<`、cpp:`<=`、cpp:`>` 和 cpp:`>=`，可用于词典排序比较（例如，cpp:`std::map` 的键），以及一个类 "
"cpp:`IntVect::shift_hasher`，可用作哈希函数（例如，对于 cpp:`std::unordered_map`）。它还具有各种算术运算符。例如，"

#: ../../source/Basics.rst:605 7b6ad6acb0294b30a7013aa2b669621d
msgid ""
"In AMR codes, one often needs to do refinement and coarsening on :cpp:`IntVect`. The refinement operation can be done "
"with the multiplication operation. However, the coarsening requires care because of the rounding towards zero behavior "
"of integer division in Fortran, C and C++. For example :cpp:`int i = -1/2` gives :cpp:`i = 0`, and what we want is "
"usually :cpp:`i = -1`. Thus, one should use the coarsen functions:"
msgstr ""
"在AMR代码中，经常需要对`IntVect`进行细化和粗化操作。细化操作可以通过乘法运算来实现。然而，由于Fortran、C和C++中整数除法向零舍入的行为，粗化操作需要特别注意。例如，:cpp:`int i = "
"-1/2`会得到:cpp:`i = 0`，而我们通常希望得到:cpp:`i = -1`。因此，应该使用粗化函数："

#: ../../source/Basics.rst:623 8bac8f1b220f48c88ae8d9821ae80ff8
msgid "Finally, we note that :cpp:`operator<<` is overloaded for :cpp:`IntVect` and therefore one can call"
msgstr "最后，我们注意到：cpp:`operator<<`已经针对cpp:`IntVect`进行了重载，因此可以调用。"

#: ../../source/Basics.rst:634 1f1e91188e274959af55dc0428d5636e
msgid "IndexType"
msgstr "索引类型"

#: ../../source/Basics.rst:636 c6ee7c144f524effa29999e31d89bd72
msgid ""
"This class defines an index as being cell based or node based in each dimension. The default constructor defines a cell "
"based type in all directions. One can also construct an :cpp:`IndexType` with an :cpp:`IntVect` with zero and one "
"representing cell and node, respectively."
msgstr "这个类定义了每个维度中索引是基于单元格还是基于节点的。默认构造函数在所有方向上定义了基于单元格的类型。还可以使用一个 `IntVect` 构造一个 `IndexType`，其中零和一分别表示单元格和节点。"

#: ../../source/Basics.rst:649 744415096bdd4e5eafa322468c96658d
msgid "The class provides various functions including"
msgstr "该类提供了各种功能，包括："

#: ../../source/Basics.rst:667 cd10fd48cc1e420db79be7517430bdee
msgid ""
"Index type is a very important concept in AMReX. It is a way of representing the notion of indices :math:`i` and "
":math:`i+1/2`."
msgstr "索引类型是AMReX中非常重要的概念。它是表示索引 :math:`i` 和 :math:`i+1/2` 的一种方式。"

#: ../../source/Basics.rst:671 75eb4f3c5fa44c1887e6b03e104eb01e
msgid "Box"
msgstr "盒子"

#: ../../source/Basics.rst:673 0358af315ca048cb92308089c44f6903
msgid ""
"A ``Box`` is an abstraction for defining discrete regions of :cpp:`AMREX_SPACEDIM`-dimensional indexing space. Boxes "
"have an :cpp:`IndexType` and two :cpp:`IntVect`\\ s representing the lower and upper corners. Boxes can exist in "
"positive and negative indexing space. Typical ways of defining a :cpp:`Box` are"
msgstr ""
"一个 \"Box\" 是用于定义 :cpp:`AMREX_SPACEDIM` 维索引空间中离散区域的抽象概念。Box 具有一个 :cpp:`IndexType` 和两个 :cpp:`IntVect`，分别表示下界和上界的角点。Box "
"可以存在于正索引空间和负索引空间。定义一个 :cpp:`Box` 的典型方式有："

#: ../../source/Basics.rst:691 d7b595e0c9b3444793eaa682cefe3b5c
msgid "Depending the dimensionality, the output of the code above is"
msgstr "根据维度的不同，上述代码的输出结果是"

#: ../../source/Basics.rst:698 1885b5b7e8d34d069587330395bba27b
msgid ""
"For simplicity, we will assume it is 3D for the rest of this section.  In the output, three integer tuples for each box "
"are the lower corner indices, upper corner indices, and the index types. Note that 0 and 1 denote cell and node, "
"respectively. For each tuple like :cpp:`(64,64,64)`, the 3 numbers are for 3 directions. The two Boxes in the code "
"above represent different indexing views of the same domain of :math:`64^3` cells. Note that in AMReX convention, the "
"lower side of a cell has the same integer value as the cell centered index. That is if we consider a cell based index "
"represent :math:`i`, the nodal index with the same integer value represents :math:`i-1/2`. "
":numref:`fig:basics:indextypes` shows some of the different index types for 2D."
msgstr ""
"为简单起见，在本节的其余部分我们将假设为3D。在输出中，每个盒子的三个整数元组分别表示下角索引、上角索引和索引类型。请注意，0和1分别表示单元格和节点。对于像：cpp:`(64,64,64)` "
"这样的元组，3个数字分别表示3个方向。代码中的两个盒子表示同一个域的不同索引视图，该域包含 :math:`64^3` 个单元格。请注意，在 AMReX "
"约定中，单元格的下侧具有与单元格中心索引相同的整数值。也就是说，如果我们将基于单元格的索引表示为 :math:`i`，具有相同整数值的节点索引表示为 "
":math:`i-1/2`。:numref:`fig:basics:indextypes` 展示了2D中的一些不同索引类型。"

#: ../../source/Basics.rst:718 9ca64ba10bb44ed790015ecb09e34b8a
msgid ""
"Some of the different index types in two dimensions: (a) cell-centered, (b) :math:`x`-face-centered (i.e., nodal in "
":math:`x`-direction only), and (c) corner/nodal, i.e., nodal in all dimensions."
msgstr "在二维中有几种不同的索引类型：(a) 以单元为中心的索引，(b) :math:`x`-面为中心的索引（即仅在 :math:`x`-方向上为节点），以及 (c) 角点/节点索引，即在所有维度上都为节点。"

#: ../../source/Basics.rst:726 4d3744687ee345c9b649c06727a3053d
msgid "There are a number of ways of converting a :cpp:`Box` from one type to another."
msgstr "有多种方法可以将一个 `Box` 从一种类型转换为另一种类型。"

#: ../../source/Basics.rst:752 5105c2323b87432ab3cc71d693094881
msgid "The internal data of :cpp:`Box` can be accessed via various member functions. Examples are"
msgstr "可以通过各种成员函数访问 :cpp:`Box` 的内部数据。以下是一些示例："

#: ../../source/Basics.rst:764 9da3aa7a43a047d68fb25db650a2c0be
msgid ""
"Boxes can be refined and coarsened. Refinement or coarsening does not change the index type. Some examples are shown "
"below."
msgstr "箱子可以细化和粗化。细化或粗化不会改变索引类型。下面是一些示例。"

#: ../../source/Basics.rst:791 939db322835448e4b583240ade5fea13
msgid ""
"Note that the behavior of refinement and coarsening depends on the index type.  A refined :cpp:`Box` covers the same "
"physical domain as the original :cpp:`Box`, and a coarsened :cpp:`Box` also covers the same physical domain if the "
"original :cpp:`Box` is coarsenable. :cpp:`Box uncoarsenable` in the example above is considered uncoarsenable because "
"its coarsened version does not cover the same physical domain in the AMR context."
msgstr ""
"请注意，细化和粗化的行为取决于索引类型。细化的 `Box` 覆盖与原始 `Box` 相同的物理域，而粗化的 `Box` 仅在原始 `Box` 可粗化的情况下覆盖相同的物理域。在上面的示例中，`Box uncoarsenable` "
"被认为是不可粗化的，因为它的粗化版本在自适应网格细化（AMR）的上下文中不覆盖相同的物理域。"

#: ../../source/Basics.rst:799 a31548d858cc4937828f6568783487ba
msgid ""
"Boxes can grow in one or all directions.  There are a number of grow functions. Some are member functions of the "
":cpp:`Box` class and others are free functions in the :cpp:`amrex` namespace."
msgstr "盒子可以在一个或所有方向上增长。有许多增长函数可用。其中一些是 :cpp:`Box` 类的成员函数，而其他一些是在 :cpp:`amrex` 命名空间中的自由函数。"

#: ../../source/Basics.rst:803 4a6202674578413a89bb9baea318a674
msgid ""
"The :cpp:`Box` class provides the following member functions testing if a :cpp:`Box` or :cpp:`IntVect` is contained "
"within this :cpp:`Box`. Note that it is a runtime error if the two Boxes have different types."
msgstr "`Box` 类提供了以下成员函数，用于测试一个 `Box` 或 `IntVect` 是否包含在这个 `Box` 内。请注意，如果两个 `Box` 具有不同的类型，这将导致运行时错误。"

#: ../../source/Basics.rst:816 4883a03eedbd4ee09f18e8e96b37e4aa
msgid "Another very common operation is the intersection of two Boxes like in the following examples."
msgstr "另一个非常常见的操作是两个盒子的交集，就像以下示例中所示。"

#: ../../source/Basics.rst:843 850a4095012c45c29d769f161b59eb0e
msgid "Dim3 and XDim3"
msgstr "Dim3 和 XDim3"

#: ../../source/Basics.rst:845 97a74186ad2242389eaa89f8037fd17f
msgid ":cpp:`Dim3` and :cpp:`XDim3` are plain structs with three fields,"
msgstr ":cpp:`Dim3`和:cpp:`XDim3`是具有三个字段的普通结构体，"

#: ../../source/Basics.rst:854 926030aed81841669b63a31ffced8061
msgid "One can convert an :cpp:`IntVect` to :cpp:`Dim3`,"
msgstr "可以将 `IntVect` 转换为 `Dim3`。"

#: ../../source/Basics.rst:863 ce0332f0b7c041248461b8a81d59bcf4
msgid ""
":cpp:`Dim3` always has three fields even when AMReX is built for 1D or 2D.  For the example above, the extra fields are "
"set to zero.  Given a :cpp:`Box`, one can get its lower and upper bounds and use them to write dimension agnostic loops."
msgstr "即使在构建为1D或2D的情况下，`Dim3`始终具有三个字段。对于上述示例，额外的字段被设置为零。给定一个`Box`，可以获取其下界和上界，并使用它们编写与维度无关的循环。"

#: ../../source/Basics.rst:882 af26e90d96f8417997227fbf26778b3c
msgid "One can also call function ``Dim3 length(Box const&)`` to return the length of a Box."
msgstr "可以调用函数 `Dim3 length(Box const&)` 来返回一个 Box 的长度。"

#: ../../source/Basics.rst:887 94c9de3ea293468cbfee7feef4d455f1
msgid "RealBox and Geometry"
msgstr "真实盒子和几何"

#: ../../source/Basics.rst:889 51af74456aa04eb0a99b46744176cc51
msgid ""
"A :cpp:`RealBox` stores the physical location in floating-point numbers of the lower and upper corners of a rectangular "
"domain."
msgstr "一个 `RealBox` 类用浮点数存储矩形域的左下角和右上角的物理位置。"

#: ../../source/Basics.rst:892 bf6bcc40bd4b48439b49e1e1ec7eb4be
msgid ""
"The :cpp:`Geometry` class in AMReX_Geometry.H describes problem domain and coordinate system for rectangular problem "
"domains. A :cpp:`Geometry` object can be constructed with"
msgstr "在 AMReX_Geometry.H 中，`Geometry` 类描述了矩形问题域的问题域和坐标系。可以使用 `Geometry` 对象来构建。"

#: ../../source/Basics.rst:908 932f740e19614fa781c98e50c5ac3749
msgid ""
"Here the constructors take a cell-centered :cpp:`Box` specifying the indexing space domain, a :cpp:`RealBox` specifying "
"the physical domain, an :cpp:`int` specifying coordinate system type, and an :cpp:`int` pointer or array specifying "
"periodicity. If a :cpp:`RealBox` is not given in the first constructor, AMReX  will construct one based on "
":cpp:`ParmParse` parameters, ``geometry.prob_lo`` / ``geometry.prob_hi`` / ``geometry.prob_extent``, where each of the "
"parameter is an array of ``AMREX_SPACEDIM`` real numbers. See the section on :ref:`sec:inputs:pd` for more details "
"about how to specify these."
msgstr ""
"在这里，构造函数接受一个以单元为中心的 `Box`，用于指定索引空间域，一个 `RealBox`，用于指定物理域，一个整数，用于指定坐标系类型，以及一个整数指针或数组，用于指定周期性。如果在第一个构造函数中没有提供 "
"`RealBox`，AMReX 将根据 `ParmParse` 参数构造一个 `RealBox`，这些参数是 `geometry.prob_lo` / `geometry.prob_hi` / "
"`geometry.prob_extent`，其中每个参数都是一个包含 `AMREX_SPACEDIM` 个实数的数组。有关如何指定这些参数的详细信息，请参阅 :ref:`sec:inputs:pd` 章节。"

#: ../../source/Basics.rst:917 ef8908c9062a405094286e3b2e338ec2
msgid ""
"The argument for coordinate system is an integer type with valid values being 0 (Cartesian), or 1 (cylindrical), or 2 "
"(spherical). If it is invalid as in the case of the default argument value of the first constructor, AMReX will query "
"the :cpp:`ParmParse` database for ``geometry.coord_sys`` and use it if one is found. If it cannot find the parameter, "
"the coordinate system is set to 0 (i.e., Cartesian coordinates)."
msgstr ""
"坐标系的参数是一个整数类型，有效值为0（笛卡尔坐标系）、1（柱坐标系）或2（球坐标系）。如果参数无效，例如在第一个构造函数的默认参数值中，AMReX将查询 :cpp:`ParmParse` 数据库中的 "
"``geometry.coord_sys``，如果找到该参数，则使用它。如果找不到该参数，则坐标系将被设置为0（即笛卡尔坐标系）。"

#: ../../source/Basics.rst:924 8360da55edfd4100bd31ff49964f4a17
msgid ""
"The :cpp:`Geometry` class has the concept of periodicity.  An argument can be passed specifying periodicity in each "
"dimension. If it is not given in the first constructor, the domain is assumed to be non-periodic unless there is the "
":cpp:`ParmParse` integer array parameter ``geometry.is_periodic`` with 0 denoting non-periodic and 1 denoting periodic. "
"Below is an example of defining a :cpp:`Geometry` for a periodic rectangular domain of :math:`[-1.0,1.0]` in each "
"direction discretized with :math:`64` numerical cells in each direction."
msgstr ""
"`Geometry`类具有周期性的概念。可以传递一个参数来指定每个维度的周期性。如果在第一个构造函数中没有给出该参数，则假定域是非周期性的，除非存在名为`geometry.is_periodic`的`ParmParse`整数数组参数，其中0"
"表示非周期性，1表示周期性。下面是一个示例，用于定义一个周期性矩形域的`Geometry`，在每个方向上的范围为`[-1.0,1.0]`，每个方向上离散化为`64`个数值单元。"

#: ../../source/Basics.rst:956 3613e6a6bbfe4d369356c552271a2382
msgid ""
"A :cpp:`Geometry` object can return various information of the physical domain and the indexing space domain. For "
"example,"
msgstr "一个 `Geometry` 对象可以返回物理域和索引空间域的各种信息。例如，"

#: ../../source/Basics.rst:975 b97b8156be0f4b89b504b98e0c5b97f5
msgid "BoxArray"
msgstr "盒子数组"

#: ../../source/Basics.rst:977 c34b8d6e7a194a22841552582175ab53
msgid ""
":cpp:`BoxArray` is a class in ``AMReX_BoxArray.H`` for storing a collection of Boxes on a single AMR level. One can "
"make a :cpp:`BoxArray` out of a single :cpp:`Box` and then chop it into multiple Boxes."
msgstr "`BoxArray` 是 `AMReX_BoxArray.H` 中的一个类，用于在单个 AMR 层级上存储一组 Boxes。可以使用一个单独的 `Box` 来创建一个 `BoxArray`，然后将其分割成多个 Boxes。"

#: ../../source/Basics.rst:991 3796961a5d5e462ca79609224f2e262c
msgid "The output is like below,"
msgstr "输出如下："

#: ../../source/Basics.rst:1004 16f1256c512a4c19b72350468252ada8
msgid "It shows that ``ba`` now has 8 Boxes, and it also prints out each Box."
msgstr "显示“ba”现在有8个盒子，并且打印出每个盒子。"

#: ../../source/Basics.rst:1006 4559732d8b1644389709a6ca40f3fbc3
msgid ""
"In AMReX, :cpp:`BoxArray` is a global data structure. It holds all the Boxes in a collection, even though a single "
"process in a parallel run only owns some of the Boxes via domain decomposition. In the example above, a 4-process run "
"may divide the work and each process owns say 2 Boxes (see section on :ref:`sec:basics:dm`). Each process can then "
"allocate memory for the floating point data on the Boxes it owns (see sections on :ref:`sec:basics:multifab` & "
":ref:`sec:basics:fab`)."
msgstr ""
"在AMReX中，:cpp:`BoxArray`是一个全局数据结构。它保存了所有的Boxes，即使在并行运行中，单个进程只通过域分解拥有其中的一部分Boxes。在上面的示例中，一个由4个进程组成的运行可能会将工作分割，每个进程拥有2"
"个Boxes（参见:ref:`sec:basics:dm`部分）。然后，每个进程可以为其所拥有的Boxes分配浮点数据的内存（参见:ref:`sec:basics:multifab`和:ref:`sec:basics:fab`部分）。"

#: ../../source/Basics.rst:1014 7712d49d171c4be2950ae42e41f6f0de
msgid ""
":cpp:`BoxArray` has an indexing type, just like :cpp:`Box`. Each Box in a BoxArray has the same type as the BoxArray "
"itself. In the following example, we show how one can convert BoxArray to a different type."
msgstr "`BoxArray`具有索引类型，就像`Box`一样。`BoxArray`中的每个`Box`与`BoxArray`本身具有相同的类型。在下面的示例中，我们展示了如何将`BoxArray`转换为不同的类型。"

#: ../../source/Basics.rst:1032 c64f61434c06446c8f2953ba6180f41f
msgid ""
"As shown in the example above, :cpp:`BoxArray` has an :cpp:`operator[]` that returns a :cpp:`Box` given an index. It "
"should be emphasized that there is a difference between its behavior and the usual behavior of an subscript operator "
"one might expect. The subscript operator in :cpp:`BoxArray` returns by **value instead of reference**. This means code "
"like below is meaningless because it modifies a temporary return value."
msgstr ""
"如上例所示，:cpp:`BoxArray`具有一个`operator[]`，根据索引返回一个`Box`。需要强调的是，它的行为与通常所期望的下标运算符的行为有所不同。在:cpp:`BoxArray`中，下标运算符返回的是**值而不是引用**"
"。这意味着下面的代码是无意义的，因为它修改的是一个临时返回值。"

#: ../../source/Basics.rst:1045 4f8df6818a114df49f7f144b049d6243
msgid ":cpp:`BoxArray` has a number of member functions that allow the Boxes to be modified. For example,"
msgstr "`BoxArray`有许多成员函数可以修改Boxes。例如，"

#: ../../source/Basics.rst:1057 edf62228b7174ac49e4d3ba83d7940be
msgid ""
"We have mentioned at the beginning of this section that :cpp:`BoxArray` is a global data structure storing Boxes shared "
"by all processes.  The operation of a deep copy is thus undesirable because it is expensive and the extra copy wastes "
"memory. The implementation of the :cpp:`BoxArray` class uses :cpp:`std::shared_ptr` to an internal container holding "
"the actual Box data. Thus making a copy of :cpp:`BoxArray` is a quite cheap operation. The conversion of types and "
"coarsening are also cheap because they can share the internal data with the original :cpp:`BoxArray`. In our "
"implementation, function :cpp:`refine` does create a new deep copy of the original data. Also note that a "
":cpp:`BoxArray` and its variant with a different type share the same internal data is an implementation detail.  We "
"discuss this so that the users are aware of the performance and resource cost. Conceptually we can think of them as "
"completely independent of each other."
msgstr ""
"我们在本节开头提到：`BoxArray`是一个全局数据结构，用于存储所有进程共享的`Boxes`。因此，进行深拷贝操作是不可取的，因为它既耗费资源又浪费内存。`BoxArray`类的实现使用`std::shared_ptr`"
"指向一个内部容器，该容器保存实际的`Box`数据。因此，复制`BoxArray`是一种非常廉价的操作。类型转换和粗化也很廉价，因为它们可以与原始的`BoxArray`共享内部数据。在我们的实现中，函数`refine`"
"确实会创建原始数据的深拷贝。还要注意的是，具有不同类型的`BoxArray`及其变体共享相同的内部数据是一种实现细节。我们讨论这一点是为了让用户了解性能和资源成本。从概念上讲，我们可以将它们视为完全独立的。"

#: ../../source/Basics.rst:1080 513e462285874302917d07c30dcb66d2
msgid ""
"For advanced users, AMReX provides functions performing the intersection of a :cpp:`BoxArray` and a :cpp:`Box`. These "
"functions are much faster than a naive implementation of performing intersection of the Box with each Box in the "
"BoxArray. If one needs to perform those intersections, functions :cpp:`amrex::intersect`, :cpp:`BoxArray::intersects` "
"and :cpp:`BoxArray::intersections` should be used."
msgstr ""
"对于高级用户，AMReX提供了执行`BoxArray`和`Box`的交集的函数。这些函数比使用朴素方法在`BoxArray`中的每个`Box`上执行交集要快得多。如果需要执行这些交集操作，应使用函数`amrex::intersect`、`"
"BoxArray::intersects`和`BoxArray::intersections`。"

#: ../../source/Basics.rst:1091 61c760180e804f06a8b0e45f0fbbec78
msgid "DistributionMapping"
msgstr "分布映射"

#: ../../source/Basics.rst:1093 48d04a41ed38407c8a6acf835ecc6e0f
msgid ""
":cpp:`DistributionMapping` is a class in ``AMReX_DistributionMapping.H`` that describes which process owns the data "
"living on the domains specified by the Boxes in a :cpp:`BoxArray`. Like :cpp:`BoxArray`, there is an element for each "
":cpp:`Box` in :cpp:`DistributionMapping`, including the ones owned by other parallel processes. One can construct a "
":cpp:`DistributionMapping` object given a :cpp:`BoxArray`,"
msgstr ""
"`DistributionMapping` 是位于 `AMReX_DistributionMapping.H` 中的一个类，用于描述在 `BoxArray` 中指定的域上的数据由哪个进程拥有。与 `BoxArray` "
"类似，`DistributionMapping` 中的每个元素对应于 `DistributionMapping` 中的每个 `Box`，包括由其他并行进程拥有的 `Box`。可以通过给定一个 `BoxArray` 来构造一个 "
"`DistributionMapping` 对象。"

#: ../../source/Basics.rst:1106 dd155d2f36944018a6f0b36b4dc9af65
msgid "or by simply making a copy,"
msgstr "或者只需简单地复制一份，"

#: ../../source/Basics.rst:1114 7f6f70888b1e451db1506ced7522fb79
msgid ""
"Note that this class is built using :cpp:`std::shared_ptr`. Thus making a copy is relatively cheap in terms of "
"performance and memory resources. This class has a subscript operator that returns the process ID at a given index."
msgstr "请注意，这个类是使用 `std::shared_ptr` 构建的。因此，在性能和内存资源方面，进行复制是相对廉价的。这个类具有一个下标运算符，它返回给定索引处的进程 ID。"

#: ../../source/Basics.rst:1118 0cc8ccc8795840b4907c8b3fb640ca3c
msgid ""
"By default, :cpp:`DistributionMapping` uses an algorithm based on space filling curve to determine the distribution. "
"One can change the default via the :cpp:`ParmParse` parameter ``DistributionMapping.strategy``.  ``KNAPSACK`` is a "
"common choice that is optimized for load balance.  One can also explicitly construct a distribution.  The "
":cpp:`DistributionMapping` class allows the user to have complete control by passing an array of integers that "
"represent the mapping of grids to processes."
msgstr ""
"默认情况下，:cpp:`DistributionMapping` 使用基于空间填充曲线的算法来确定分布方式。可以通过 :cpp:`ParmParse` 参数 ``DistributionMapping.strategy`` "
"来更改默认设置。``KNAPSACK`` 是一种常见选择，它针对负载平衡进行了优化。用户还可以显式构建分布方式。:cpp:`DistributionMapping` 类允许用户通过传递一个表示网格与进程映射关系的整数数组来完全控制分布方式。"

#: ../../source/Basics.rst:1139 fa42aaf52c0a4f8cb6b323e5fa7eaa14
msgid "BaseFab, FArrayBox, IArrayBox, and Array4"
msgstr ""
"BaseFab, FArrayBox, IArrayBox, and Array4\n"
"\n"
"BaseFab, FArrayBox, IArrayBox, and Array4"

#: ../../source/Basics.rst:1141 3f807aa61e064d599e68d7c834259a6c
msgid ""
"AMReX is a block-structured AMR framework. Although AMR introduces irregularity to the data and algorithms, there is "
"regularity at the block/Box level because each is still logically rectangular, and the data structure at the Box level "
"is conceptually simple. :cpp:`BaseFab` is a class template for multi-dimensional array-like data structure on a "
":cpp:`Box`. The template parameter is typically basic types such as :cpp:`Real`, :cpp:`int` or :cpp:`char`. The "
"dimensionality of the array is ``AMREX_SPACEDIM`` *plus one*. The additional dimension is for the number of components. "
"The data are internally stored in a contiguous block of memory in Fortran array order (i.e., column-major order) for "
":math:`(x,y,z,\\mathrm{component})`, and each component also occupies a contiguous block of memory because of the "
"ordering. For example, a :cpp:`BaseFab<Real>` with 4 components defined on a three-dimensional "
":cpp:`Box(IntVect{-4,8,32},IntVect{32,64,48})` is like a Fortran array of :fortran:`real(amrex_real), "
"dimension(-4:32,8:64,32:48,0:3)`.  Note that the convention in C++ part of AMReX is the component index is zero based. "
"The code for constructing such an object is as follows,"
msgstr ""
"AMReX是一个基于块结构的自适应网格细化（AMR）框架。虽然AMR在数据和算法上引入了不规则性，但在块/Box级别上仍然存在规则性，因为每个块仍然是逻辑上的矩形，并且在Box级别上的数据结构是概念上简单的。:cpp:`BaseFab`"
"是一个用于在:cpp:`Box`上的多维类似数组的数据结构的类模板。模板参数通常是基本类型，如:cpp:`Real`、:cpp:`int`或:cpp:`char`。数组的维度是``AMREX_SPACEDIM``*加一*"
"。额外的维度用于表示组件的数量。数据在内部以Fortran数组顺序（即列主序）存储在连续的内存块中，按照:math:`(x,y,z,\\mathrm{component})`"
"的顺序。由于顺序的原因，每个组件也占据了连续的内存块。例如，一个在三维:cpp:`Box(IntVect{-4,8,32},IntVect{32,64,48})`上定义了4个组件的:cpp:`BaseFab<Real>`"
"类似于一个Fortran数组:fortran:`real(amrex_real), dimension(-4:32,8:64,32:48,0:3)`。请注意，AMReX的C++部分中的组件索引是从零开始的。构造这样一个对象的代码如下："

#: ../../source/Basics.rst:1166 5a6ddc9819b04da0bfdd2df6290cf863
msgid ""
"Most applications do not use :cpp:`BaseFab` directly, but utilize specialized classes derived from :cpp:`BaseFab`. The "
"most common types are :cpp:`FArrayBox` in AMReX_FArrayBox.H derived from :cpp:`BaseFab<Real>` and :cpp:`IArrayBox` in "
"AMReX_IArrayBox.H derived from :cpp:`BaseFab<int>`."
msgstr ""
"大多数应用程序不直接使用 :cpp:`BaseFab`，而是使用从 :cpp:`BaseFab` 派生的专门类。最常见的类型是从 :cpp:`BaseFab<Real>` 派生的 :cpp:`FArrayBox`（在 "
"AMReX_FArrayBox.H 中）和从 :cpp:`BaseFab<int>` 派生的 :cpp:`IArrayBox`（在 AMReX_IArrayBox.H 中）。"

#: ../../source/Basics.rst:1171 186641bbc203469a9f6a4180c12d5a9c
msgid ""
"These derived classes also obtain many :cpp:`BaseFab` member functions via inheritance. We now show some common usages "
"of these functions.  To get the :cpp:`Box` where a :cpp:`BaseFab` or its derived object is defined, one can call"
msgstr "这些派生类也通过继承获得了许多 `BaseFab` 成员函数。现在我们展示一些这些函数的常见用法。要获取一个 `BaseFab` 或其派生对象所定义的 `Box`，可以调用"

#: ../../source/Basics.rst:1182 1a2c4ad340604c9c8b5c1f251cd69ea4
msgid "To the number of component, one can call"
msgstr "在组件的数量方面，可以称之为"

#: ../../source/Basics.rst:1190 a3b366b4eedb4c64b0385124c92295d3
msgid "To get a pointer to the array data, one can call"
msgstr "要获取指向数组数据的指针，可以调用"

#: ../../source/Basics.rst:1200 2c96a0bd3d454833b153ef90abd00882
msgid ""
"The typical usage of the returned pointer is then to pass it to a Fortran or C function that works on the array data "
"(see the section on :ref:`sec:basics:fortran`).  :cpp:`BaseFab` has several functions that set the array data to a "
"constant value. Two examples are as follows."
msgstr "返回指针的典型用法是将其传递给一个处理数组数据的Fortran或C函数（请参阅:ref:`sec:basics:fortran`部分）。:cpp:`BaseFab`有几个函数可以将数组数据设置为常量值。以下是两个示例。"

#: ../../source/Basics.rst:1214 01250d40f67f4982878fecbd5f8f15a7
msgid "One can copy data from one :cpp:`BaseFab` to another."
msgstr "可以将数据从一个 `BaseFab` 复制到另一个。"

#: ../../source/Basics.rst:1223 eb8dc97301bf4cb79fdaac6176e148cb
msgid ""
"Here the function copies the data from the region specified by :cpp:`srcbox` in the source :cpp:`BaseFab src` into the "
"region specified by :cpp:`destbox` in the destination BaseFab that invokes the function call. Note that although "
":cpp:`srcbox` and :cpp:`destbox` may be different, they must be the same size, shape and index type, otherwise a "
"runtime error occurs. The user also specifies how many components (:cpp:`int numcomp`) are copied starting at component "
"srccomp in src and stored starting at component destcomp. BaseFab has functions returning the minimum or maximum value."
msgstr ""
"在这个函数中，它将从源BaseFab的由:cpp:`srcbox`指定的区域复制数据到调用函数的目标BaseFab的由:cpp:`destbox`指定的区域。请注意，尽管:cpp:`srcbox`和:cpp:`destbox`"
"可能不同，但它们必须具有相同的大小、形状和索引类型，否则会发生运行时错误。用户还需要指定要复制的组件数量（:cpp:`int "
"numcomp`），从源BaseFab的组件srccomp开始复制，并从目标BaseFab的组件destcomp开始存储。BaseFab具有返回最小值或最大值的函数。"

#: ../../source/Basics.rst:1243 494d1c0fe8084d1085724e05c6aa5ba2
msgid ":cpp:`BaseFab` also has many arithmetic functions. Here are some examples using FArrayBox."
msgstr "`BaseFab`还具有许多算术函数。以下是使用`FArrayBox`的一些示例。"

#: ../../source/Basics.rst:1260 89eee4a1bebe402c81021aadc172e796
msgid ""
"These floating point operation functions are templated with parameter :cpp:`RunOn` specifying where they run, "
":cpp:`RunOn::Host` or :cpp:`RunOn::Device`.  When AMReX is built just for CPU, the template parameter has a default "
"value of :cpp:`RunOn::Host` so that the user does not need to specify it for backward compatibility, and if "
":cpp:`RunOn::Device` is provided it will be ignored. However, when AMReX is built with GPU support, one must specify "
"where to run for these :cpp:`BaseFab` functions.  For example,"
msgstr ""
"这些浮点运算函数使用模板参数 :cpp:`RunOn` 来指定运行位置，可以是 :cpp:`RunOn::Host` 或 :cpp:`RunOn::Device`。当 AMReX 仅构建用于 CPU 时，模板参数有一个默认值 "
":cpp:`RunOn::Host`，以保持向后兼容性，用户无需指定它，如果提供了 :cpp:`RunOn::Device`，将会被忽略。然而，当 AMReX 构建支持 GPU 时，必须指定这些 :cpp:`BaseFab` "
"函数在哪里运行。例如，"

#: ../../source/Basics.rst:1278 72da70ae482d4f3ab61d0104245ad4a7
msgid ""
"For more complicated expressions that are not supported, one can write Fortran or C/C++ functions for those (see the "
"section on :ref:`sec:basics:fortran`).  In C++, one can use :cpp:`Array4`, which is a class template for accessing "
":cpp:`BaseFab` data in a more array like manner using :cpp:`operator()`.  Below is an example of using :cpp:`Array4`."
msgstr ""
"对于不支持的更复杂表达式，可以编写Fortran或C/C++函数来处理（请参阅:ref:`sec:basics:fortran`部分）。在C++中，可以使用:cpp:`Array4`，它是一个类模板，可以使用:cpp:`operator()"
"`以更类似数组的方式访问:cpp:`BaseFab`数据。以下是使用:cpp:`Array4`的示例。"

#: ../../source/Basics.rst:1311 5b10f67a35464db6bdd49f93183f1d23
msgid ""
"Note that :cpp:`operator()` of :cpp:`Array4` takes either three or four arguments.  The optional fourth argument has a "
"default value of zero.  The two :cpp:`const`\\ s in :cpp:`Array4<Real const> const&` have different meaning.  The first "
":cpp:`const` inside :cpp:`<>` means the data accessed via :cpp:`Array4` is read-only, whereas the second :cpp:`const` "
"means the :cpp:`Array4` object itself cannot be modified to point to other data.  In the example above, neither "
"``m(i,j,k) = 0`` nor ``b(i,j,k) = 0.0`` is allowed.  However one is allowed to do ``m = ifab2.array()`` to assign "
":cpp:`m` again, but not to :cpp:`b`. The behavior is in some sense similar to ``double const * const p``."
msgstr ""
"请注意：`Array4`的`:cpp:`operator()`接受三个或四个参数。可选的第四个参数默认值为零。`:cpp:`Array4<Real const> "
"const&`中的两个`:cpp:`const`具有不同的含义。`:cpp:`<>`内部的第一个`:cpp:`const`表示通过`:cpp:`Array4`访问的数据是只读的，而第二个`:cpp:`const`表示`:cpp:`"
"Array4`对象本身不能被修改为指向其他数据。在上面的示例中，既不允许`m(i,j,k) = 0`，也不允许`b(i,j,k) = 0.0`。然而，可以使用`m = "
"ifab2.array()`将`:cpp:`m`重新赋值，但不能将其赋值给`:cpp:`b`。在某种意义上，这种行为类似于`double const * const p`。"

#: ../../source/Basics.rst:1322 c0abf90f3824418c806a49d13cdbba8e
msgid ""
":cpp:`BaseFab` and its derived classes are containers for data on :cpp:`Box`. Recall that :cpp:`Box` has various types "
"(see the section on :ref:`sec:basics:box`). The examples in this section so far use the default cell based type.  "
"However, some functions will result in a runtime error if the types mismatch.  For example."
msgstr ""
"`BaseFab`及其派生类是存储在`Box`上的数据容器。请回忆一下，`Box`有各种类型（请参阅:ref:`sec:basics:box`"
"部分）。到目前为止，本节中的示例都使用了默认的基于单元格的类型。然而，如果类型不匹配，某些函数将导致运行时错误。例如。"

#: ../../source/Basics.rst:1339 f763f3f4c80844a3bce1b858173e87e9
msgid ""
"Because it typically contains a lot of data, BaseFab's copy constructor and copy assignment operator are disabled to "
"prevent performance degradation. However, BaseFab does provide a move constructor. In addition, it also provides a "
"constructor for making an alias of an existing object. Here is an example using :cpp:`FArrayBox`."
msgstr "由于通常包含大量数据，BaseFab的复制构造函数和复制赋值运算符被禁用以防止性能下降。然而，BaseFab提供了移动构造函数。此外，它还提供了一个用于创建现有对象别名的构造函数。以下是使用`FArrayBox`的示例。"

#: ../../source/Basics.rst:1354 93c5f2460b5b45169ff9c1579df1be7e
msgid ""
"In this example, the alias :cpp:`FArrayBox` has only two components even though the original one has four components. "
"The alias has a sliced component view of the original :cpp:`FArrayBox`. This is possible because of the array ordering. "
"However, it is not possible to slice in the real space (i.e., the first ``AMREX_SPACEDIM`` dimensions).  Note that no "
"new memory is allocated in constructing the alias and the alias contains a non-owning pointer. It should be emphasized "
"that the alias will contain a dangling pointer after the original :cpp:`FArrayBox` reaches its end of life.  One can "
"also construct an alias :cpp:`BaseFab` given an :cpp:`Array4`,"
msgstr ""
"在这个示例中，别名 `FArrayBox` 只有两个分量，尽管原始对象有四个分量。该别名具有原始 `FArrayBox` 的分量切片视图。这是由于数组的排序方式所导致的。然而，在实空间（即前 `AMREX_SPACEDIM` "
"个维度）中无法进行切片。请注意，在构建别名时不会分配新的内存，并且别名包含一个非拥有指针。需要强调的是，当原始 `FArrayBox` 达到其生命周期的结束时，别名将包含一个悬空指针。还可以根据 `Array4` 构建别名 "
"`BaseFab`。"

#: ../../source/Basics.rst:1374 d3fb089d48c8400f872cedbc79a59798
msgid "FabArray, MultiFab and iMultiFab"
msgstr "FabArray, MultiFab和iMultiFab"

#: ../../source/Basics.rst:1376 bacb77cdba6a43bd99755651db5729a7
msgid ""
":cpp:`FabArray<FAB>` is a class template in AMReX_FabArray.H for a collection of FABs on the same AMR level associated "
"with a :cpp:`BoxArray` (see the section on :ref:`sec:basics:ba`). The template parameter :cpp:`FAB` is usually "
":cpp:`BaseFab<T>` or its derived classes (e.g., :cpp:`FArrayBox`). However, FabArray can also be used to hold other "
"data structures. To construct a FabArray, a :cpp:`BoxArray` must be provided because the FabArray is intended to hold "
"*grid* data defined on a union of rectangular regions embedded in a uniform index space. For example, a FabArray object "
"can be used to hold data for one level as in :numref:`fig:basics:amrgrids`."
msgstr ""
"`FabArray<FAB>`是在AMReX_FabArray.H中的一个类模板，用于存储与一个`BoxArray`相关联的同一AMR级别上的一组FABs（请参阅:ref:`sec:basics:ba`部分）。模板参数`FAB`通常是`"
"BaseFab<T>`或其派生类（例如`FArrayBox`）。然而，FabArray也可以用于存储其他数据结构。要构造一个FabArray，必须提供一个`BoxArray`"
"，因为FabArray旨在存储定义在统一索引空间中的一组矩形区域的*网格*数据。例如，一个FabArray对象可以用于存储一个级别的数据，如:numref:`fig:basics:amrgrids`所示。"

#: ../../source/Basics.rst:1386 7add223c360b42459e8829da128d79fc
msgid ""
":cpp:`FabArray` is a parallel data structure in which the data (i.e., FAB) are distributed among parallel processes. "
"For each process, a FabArray contains only the FAB objects owned by that process, and the process operates only on its "
"local data. For operations that require data owned by other processes, remote communications are involved. Thus, the "
"construction of a :cpp:`FabArray` requires a :cpp:`DistributionMapping` (see the section on :ref:`sec:basics:dm`) that "
"specifies which process owns which Box. For level 2 (*red*) in :numref:`fig:basics:amrgrids`, there are two Boxes. "
"Suppose there are two parallel processes, and we use a DistributionMapping that assigns one Box to each process. Then "
"the :cpp:`FabArray` on each process is built on the :cpp:`BoxArray` with both Boxes, but contains only the FAB "
"associated with its process."
msgstr ""
"`FabArray`"
"是一种并行数据结构，其中数据（即FAB）在并行进程之间分布。对于每个进程，FabArray仅包含该进程拥有的FAB对象，并且该进程仅对其本地数据进行操作。对于需要使用其他进程拥有的数据的操作，涉及到远程通信。因此，构建一个`"
"FabArray`需要一个`DistributionMapping`（参见:ref:`sec:basics:dm`部分），该映射指定了哪个进程拥有哪个Box。对于图:numref:`fig:basics:amrgrids`"
"中的二级（红色）层次，有两个Box。假设有两个并行进程，并且我们使用一个将一个Box分配给每个进程的DistributionMapping。然后，每个进程上的`FabArray`都是基于包含两个Box的`BoxArray`"
"构建的，但仅包含与其进程相关联的FAB。"

#: ../../source/Basics.rst:1398 4bb36d44699c4c01a6b30962a67d8d54
msgid ""
"In AMReX, there are some specialized classes derived from :cpp:`FabArray`. The :cpp:`iMultiFab` class in "
"AMReX_iMultiFab.H is derived from :cpp:`FabArray<IArrayBox>`. The most commonly used :cpp:`FabArray` kind class is "
":cpp:`MultiFab` in AMReX_MultiFab.H derived from :cpp:`FabArray<FArrayBox>`. In the rest of this section, we use "
":cpp:`MultiFab` as example. However, these concepts are equally applicable to other types of FabArrays. There are many "
"ways to define a MultiFab. For example,"
msgstr ""
"在AMReX中，有一些从`FabArray`派生出来的专门类。在AMReX_iMultiFab.H中，`iMultiFab`类是从`FabArray<IArrayBox>`派生出来的。而在AMReX_MultiFab.H中，最常用的`"
"FabArray`类是从`FabArray<FArrayBox>`派生出来的`MultiFab`类。在本节的其余部分，我们以`MultiFab`"
"作为示例。然而，这些概念同样适用于其他类型的FabArrays。有许多方法可以定义一个MultiFab。例如，"

#: ../../source/Basics.rst:1416 8db7f5b0b3a643bc99eeb75a2301557e
msgid ""
"Here we define a :cpp:`MultiFab` with 4 components and 1 ghost cell. A MultiFab contains a number of :cpp:`FArrayBox`\\ "
"es (see the section on :ref:`sec:basics:fab`) defined on Boxes grown by the number of ghost cells (1 in this example). "
"That is the :cpp:`Box` in the :cpp:`FArrayBox` is not exactly the same as in the :cpp:`BoxArray`.  If the "
":cpp:`BoxArray` has a :cpp:`Box{(7,7,7) (15,15,15)}`, the one used for constructing :cpp:`FArrayBox` will be "
":cpp:`Box{(6,6,6) (16,16,16)}` in this example. For cells in :cpp:`FArrayBox`, we call those in the original :cpp:`Box` "
"**valid cells** and the grown part **ghost cells**. Note that :cpp:`FArrayBox` itself does not have the concept of "
"ghost cells.  Ghost cells are a key concept of :cpp:`MultiFab`, however, that allows for local operations on ghost cell "
"data originated from remote processes. We will discuss how to fill ghost cells with data from valid cells later in this "
"section.  :cpp:`MultiFab` also has a default constructor. One can define an empty :cpp:`MultiFab` first and then call "
"the :cpp:`define` function as follows."
msgstr ""
"在这里，我们定义了一个具有4个分量和1个幽灵单元的`MultiFab`。`MultiFab`包含一些在通过幽灵单元（在此示例中为1）扩展的`Box`上定义的`FArrayBox`（请参阅`sec:basics:fab`部分）。也就是说，`"
"FArrayBox`中的`Box`与`BoxArray`中的`Box`不完全相同。如果`BoxArray`具有`Box{(7,7,7) "
"(15,15,15)}`，则用于构建`FArrayBox`的`Box`在此示例中将为`Box{(6,6,6) "
"(16,16,16)}`。对于`FArrayBox`中的单元格，我们将原始`Box`中的单元格称为**有效单元格**，而扩展部分称为**幽灵单元格**。请注意，`FArrayBox`本身没有幽灵单元格的概念。然而，幽灵单元格是`"
"MultiFab`的一个关键概念，它允许对来自远程进程的幽灵单元格数据进行本地操作。我们将在本节后面讨论如何使用有效单元格中的数据填充幽灵单元格。`MultiFab`还具有默认构造函数。可以首先定义一个空的`MultiFab`，然后调用`"
"define`函数，如下所示。"

#: ../../source/Basics.rst:1443 7ce80d776d0e4de3b3a16efebdd695f3
msgid "Given an existing :cpp:`MultiFab`, one can also make an alias :cpp:`MultiFab` as follows."
msgstr "在现有的 `MultiFab` 上，我们也可以创建一个别名 `MultiFab`，具体操作如下。"

#: ../../source/Basics.rst:1455 23d9a89ddcde43fda6d82553a1a14af5
msgid ""
"Here the first integer parameter is the starting component in the original :cpp:`MultiFab` that will become component 0 "
"in the alias :cpp:`MultiFab` and the second integer parameter is the number of components in the alias. It's a runtime "
"error if the sum of the two integer parameters is greater than the number of the components in the original MultiFab. "
"Note that the alias MultiFab has exactly the same number of ghost cells as the original MultiFab."
msgstr ""
"这里的第一个整数参数是原始 `MultiFab` 中将成为别名 `MultiFab` 中组件0的起始组件，第二个整数参数是别名中的组件数量。如果这两个整数参数的和大于原始 `MultiFab` "
"中的组件数量，则会引发运行时错误。请注意，别名 `MultiFab` 的幽灵单元格数量与原始 `MultiFab` 完全相同。"

#: ../../source/Basics.rst:1462 6e836b1058de4d95b08005a91c4c823a
msgid ""
"We often need to build new MultiFabs that have the same :cpp:`BoxArray` and :cpp:`DistributionMapping` as a given "
"MultiFab.  Below is an example of how to achieve this."
msgstr "我们经常需要构建具有与给定 MultiFab 相同的 `BoxArray` 和 `DistributionMapping` 的新 MultiFab。以下是实现此目的的示例。"

#: ../../source/Basics.rst:1480 951f4e8b0366404a93a5bdf8d35c53ac
msgid ""
"As we have repeatedly mentioned in this chapter that :cpp:`Box` and :cpp:`BoxArray` have various index types. Thus, "
":cpp:`MultiFab` also has an index type that is obtained from the :cpp:`BoxArray` used for defining the :cpp:`MultiFab`. "
"It should be noted again that index type is a very important concept in AMReX. Let's consider an example of a "
"finite-volume code, in which the state is defined as cell averaged variables and the fluxes are defined as face "
"averaged variables."
msgstr ""
"正如我们在本章中多次提到的那样，:cpp:`Box` 和 :cpp:`BoxArray` 具有不同的索引类型。因此，:cpp:`MultiFab` 也具有一个索引类型，该类型是从用于定义 :cpp:`MultiFab` 的 "
":cpp:`BoxArray` 中获得的。需要再次强调的是，索引类型是 AMReX 中非常重要的概念。让我们考虑一个有限体积代码的示例，其中状态被定义为单元平均变量，而通量被定义为面平均变量。"

#: ../../source/Basics.rst:1501 a266c80229f34c5b8630562529b01be4
msgid ""
"Here all :cpp:`MultiFab`\\ s  use the same :cpp:`DistributionMapping`, but their :cpp:`BoxArray`\\ s have different "
"index types. The state is cell-based, whereas the fluxes are on the faces. Suppose the cell based :cpp:`BoxArray` "
"contains a :cpp:`Box{(8,8,16), (15,15,31)}`. The state on that :cpp:`Box` is conceptually a Fortran Array with the "
"dimension of :fortran:`(8:15,8:15,16:31,0:2)`. The fluxes are arrays with slightly different indices. For example, the "
":math:`x`-direction flux for that :cpp:`Box` has the dimension of :fortran:`(8:16,8:15,16:31,0:2)`. Note there is an "
"extra element in :math:`x`-direction."
msgstr ""
"这里所有的 `MultiFab` 使用相同的 `DistributionMapping`，但它们的 `BoxArray` 具有不同的索引类型。状态是基于单元的，而通量是在面上的。假设基于单元的 `BoxArray` 包含一个 "
"`Box{(8,8,16), (15,15,31)}`。在该 `Box` 上的状态在概念上是一个具有维度为 `(8:15,8:15,16:31,0:2)` 的 Fortran 数组。通量是具有稍微不同索引的数组。例如，该 `Box` 的 "
"`x`-方向通量具有维度为 `(8:16,8:15,16:31,0:2)`。请注意，`x`-方向上有一个额外的元素。"

#: ../../source/Basics.rst:1511 3531c15646af49429e9c704d4ac9c823
msgid ""
"The :cpp:`MultiFab` class provides many functions performing common arithmetic operations on a :cpp:`MultiFab` or "
"between :cpp:`MultiFab`\\ s  built with the *same* :cpp:`BoxArray` and :cpp:`DistributionMap`.  For example,"
msgstr "`MultiFab`类提供了许多函数，用于在具有相同`BoxArray`和`DistributionMap`的`MultiFab`之间或对`MultiFab`执行常见的算术操作。例如，"

#: ../../source/Basics.rst:1535 0e95da279ca144d4ba51cf42f430aebf
msgid ""
"We refer the reader to ``amrex/Src/Base/AMReX_MultiFab.H`` and ``amrex/Src/Base/AMReX_FabArray.H`` for more details. It "
"should be noted again it is a runtime error if the two :cpp:`MultiFab`\\ s  passed to functions like "
":cpp:`MultiFab::Copy` are not built with the *same* :cpp:`BoxArray` (including index type) and "
":cpp:`DistributionMapping`."
msgstr ""
"请参考``amrex/Src/Base/AMReX_MultiFab.H``和``amrex/Src/Base/AMReX_FabArray.H``以获取更多详细信息。需要再次注意的是，如果传递给像:cpp:`MultiFab::Copy`"
"这样的函数的两个:cpp:`MultiFab`对象没有使用相同的:cpp:`BoxArray`（包括索引类型）和:cpp:`DistributionMapping`进行构建，则会出现运行时错误。"

#: ../../source/Basics.rst:1541 b387085394aa4b06ae75db1abfffbabc
msgid ""
"It is usually the case that the Boxes in the :cpp:`BoxArray` used for building a :cpp:`MultiFab` are non-intersecting "
"except that they can be overlapping due to nodal index type. However, :cpp:`MultiFab` can have ghost cells, and in that "
"case FArrayBoxes are defined on Boxes larger than the Boxes in the :cpp:`BoxArray`.  Parallel communication is then "
"needed to fill the ghost cells with valid cell data from other FArrayBoxes possibly on other parallel processes. The "
"function for performing this type of communication is :cpp:`FillBoundary`."
msgstr ""
"通常情况下，用于构建 MultiFab 的 BoxArray 中的 Boxes 是不相交的，除非由于节点索引类型的原因它们可以重叠。然而，MultiFab 可以具有 ghost cells，在这种情况下，FArrayBoxes 在比 "
"BoxArray 中的 Boxes 更大的 Boxes 上定义。然后需要进行并行通信，以便从可能位于其他并行进程上的其他 FArrayBoxes 中填充 ghost cells，使其包含有效的单元格数据。执行此类型通信的函数是 "
"FillBoundary。"

#: ../../source/Basics.rst:1563 41afa9f3cf2f4787abfbccbaf6dd612e
msgid ""
"Note that :cpp:`FillBoundary` does not modify any valid cells. Also note that :cpp:`MultiFab` itself does not have the "
"concept of periodic boundary, but :cpp:`Geometry` has, and we can provide that information so that periodic boundaries "
"can be filled as well. You might have noticed that a ghost cell could overlap with multiple valid cells from different "
"FArrayBoxes in the case of nodal index type. In that case, it is unspecified that which valid cell's value is used to "
"fill the ghost cell. It ought to be the case the values in those overlapping valid cells are the same up to roundoff "
"errors.  If a ghost cell does not overlap with any valid cells, its value will not be modified by :cpp:`FillBoundary`."
msgstr ""
"请注意：cpp: `FillBoundary` 不会修改任何有效的单元格。同时，请注意：cpp: `MultiFab` 本身没有周期边界的概念，但是cpp: `Geometry` "
"有，我们可以提供该信息，以便填充周期边界。您可能已经注意到，在节点索引类型的情况下，一个幽灵单元格可能与不同的FArrayBoxes中的多个有效单元格重叠。在这种情况下，未指定使用哪个有效单元格的值来填充幽灵单元格。应该假设这些重叠的有效单"
"元格的值在舍入误差范围内是相同的。如果幽灵单元格与任何有效单元格不重叠，则cpp: `FillBoundary` 不会修改其值。"

#: ../../source/Basics.rst:1574 cc2a3be6b9dd487e8afb7aefda767767
msgid ""
"Another type of parallel communication is copying data from one :cpp:`MultiFab` to another :cpp:`MultiFab` with a "
"different :cpp:`BoxArray` or the same :cpp:`BoxArray` with a different :cpp:`DistributionMapping`. The data copy is "
"performed on the regions of intersection. The most generic interface for this is"
msgstr "另一种并行通信的方式是将数据从一个具有不同的`BoxArray`或具有不同的`DistributionMapping`的`MultiFab`复制到另一个`MultiFab`中。数据复制是在交集区域上执行的。最通用的接口是："

#: ../../source/Basics.rst:1586 b9dd1dede70d4dbfa3fe6b1bf93f4aa7
msgid ""
"Here :cpp:`mfdst` and :cpp:`mfsrc` are destination and source MultiFabs, respectively. Parameters :cpp:`compsrc`, "
":cpp:`compdst`, and :cpp:`ncomp` are integers specifying the range of components. The copy is performed on :cpp:`ncomp` "
"components starting from component :cpp:`compsrc` of :cpp:`mfsrc` and component :cpp:`compdst` of :cpp:`mfdst`. "
"Parameters :cpp:`ngsrc` and :cpp:`ngdst` specify the number of ghost cells involved for the source and destination, "
"respectively. Parameter :cpp:`period` is optional, and by default no periodic copy is performed. Like "
":cpp:`FillBoundary`, one can use :cpp:`Geometry::periodicity()` to provide the periodicity information. The last "
"parameter is also optional and is set to :cpp:`FabArrayBase::COPY` by default. One could also use "
":cpp:`FabArrayBase::ADD`. This determines whether the function copies or adds data from the source to the destination. "
"Similar to :cpp:`FillBoundary`, if a destination cell has multiple cells as source, it is unspecified that which source "
"cell is used in :cpp:`FabArrayBase::COPY`, and, for :cpp:`FabArrayBase::ADD`, the multiple values are all added to the "
"destination cell.  This function has two variants, in which the periodicity and operation type are also optional."
msgstr ""
"这里，`mfdst`和`mfsrc`分别是目标和源的MultiFabs。参数`compsrc`、`compdst`和`ncomp`是指定组件范围的整数。复制操作从`mfsrc`的第`compsrc`个组件开始，复制`ncomp`个组件到`"
"mfdst`的第`compdst`个组件。参数`ngsrc`和`ngdst`分别指定源和目标涉及的幽灵单元数。参数`period`是可选的，默认情况下不执行周期性复制。与`FillBoundary`类似，可以使用`"
"Geometry::periodicity()`提供周期性信息。最后一个参数也是可选的，默认设置为`FabArrayBase::COPY`。也可以使用`FabArrayBase::ADD`。这决定了函数是从源复制数据还是添加到目标。与`"
"FillBoundary`类似，如果一个目标单元有多个源单元，则在`FabArrayBase::COPY`中使用哪个源单元是未指定的，对于`FabArrayBase::ADD`"
"，多个值都会被添加到目标单元。此函数有两个变体，其中周期性和操作类型也是可选的。"

#: ../../source/Basics.rst:1612 d96d47f3361f4fd59c23d4364bb3a9e4
msgid ""
"Here the number of ghost cells involved is zero, and the copy is performed on all components if unspecified (assuming "
"the two MultiFabs have the same number of components)."
msgstr "在这里，涉及到的幽灵单元格数量为零，并且如果未指定，将对所有组件执行复制操作（假设两个 MultiFabs 具有相同数量的组件）。"

#: ../../source/Basics.rst:1616 0504569767054e4992e40e15347b3b5b
msgid ""
"Both :cpp:`ParallelCopy(...)` and :cpp:`FillBoundary(...)` are blocking calls. They will only return when the "
"communication is completed and the destination MultiFab is guaranteed to be properly updated.  AMReX also provides "
"non-blocking versions of these calls to allow users to overlap communication with calculation and potentially improve "
"overall application performance."
msgstr ""
"无论是 `cpp:ParallelCopy(...)` 还是 `cpp:FillBoundary(...)` 都是阻塞调用。只有在通信完成并且目标 MultiFab 被正确更新后，它们才会返回。AMReX "
"还提供了这些调用的非阻塞版本，以允许用户将通信与计算重叠，从而可能提高整体应用程序性能。"

#: ../../source/Basics.rst:1622 0c38f7c21c2a48319579fd3470fd54bc
msgid ""
"The non-blocking calls are used by calling the :cpp:`***_nowait(...)` function to begin the comm operation, followed by "
"the :cpp:`***_finish()` function at a later time to complete it. For example:"
msgstr "非阻塞调用通过调用 :cpp:`***_nowait(...)` 函数开始通信操作，然后在稍后的时间调用 :cpp:`***_finish()` 函数来完成它。例如："

#: ../../source/Basics.rst:1642 bdccb3e9bddc418fb2cfc4d2725cf891
msgid ""
"All function signatures of the blocking calls are also available in the non-blocking calls and should be used in the "
"`nowait` function.  The `finish` functions take no parameters, as the required data is stored during `nowait` and "
"retrieved.  Users that choose to use non-blocking calls must ensure the calls are properly used to avoid race "
"conditions, which typically means not interacting with the MultiFab between the :cpp:`_nowait` and :cpp:`_finish` calls."
msgstr ""
"所有阻塞调用的函数签名在非阻塞调用中也是可用的，并且应该在`nowait`函数中使用。`finish`函数不接受任何参数，因为所需的数据在`nowait`"
"期间被存储并检索。选择使用非阻塞调用的用户必须确保正确使用这些调用以避免竞态条件，通常意味着在`:cpp:`_nowait`和`:cpp:`_finish`调用之间不与MultiFab进行交互。"

#: ../../source/Basics.rst:1653 a34ea58d46824b66b8e0d5223e5430c4
msgid "MFIter and Tiling"
msgstr "MFIter 和 Tiling"

#: ../../source/Basics.rst:1655 630c8de05b584cb69115e6f8d60d6477
msgid ""
"In this section, we will first show how :cpp:`MFIter` works without tiling. Then we will introduce the concept of "
"logical tiling.  Finally we will show how logical tiling can be launched via :cpp:`MFIter`."
msgstr "在这个部分，我们首先会展示没有使用切片的情况下 :cpp:`MFIter` 的工作原理。然后我们会介绍逻辑切片的概念。最后我们会展示如何通过 :cpp:`MFIter` 来启动逻辑切片。"

#: ../../source/Basics.rst:1662 3a9b92e4556e4ff4a7e963da37c1afc9
msgid "MFIter without Tiling"
msgstr "不使用平铺的MFIter"

#: ../../source/Basics.rst:1664 d9dbbb457eee4082bcd8571a6f8a07d4
msgid ""
"In the section on :ref:`sec:basics:multifab`, we have shown some of the arithmetic functionalities of :cpp:`MultiFab`, "
"such as adding two MultiFabs together. In this section, we will show how you can operate on the :cpp:`MultiFab` data "
"with your own functions. AMReX provides an iterator, :cpp:`MFIter` for looping over the FArrayBoxes in MultiFabs. For "
"example,"
msgstr ""
"在:ref:`sec:basics:multifab`部分，我们展示了一些:cpp:`MultiFab`的算术功能，比如将两个MultiFab相加。在本节中，我们将展示如何使用自己的函数对:cpp:`MultiFab`"
"数据进行操作。AMReX提供了一个迭代器:cpp:`MFIter`，用于循环遍历MultiFabs中的FArrayBoxes。例如，"

#: ../../source/Basics.rst:1694 fc73ae35d01842bf83166c971f27d145
msgid "Here function :cpp:`f1` might be something like below,"
msgstr "这里的 `f1` 函数可能是类似下面这样的："

#: ../../source/Basics.rst:1713 a72a4aed753e4f608f15fdcdabc030b6
msgid ""
":cpp:`MFIter` only loops over grids owned by this process. For example, suppose there are 5 Boxes in total and "
"processes 0 and 1 own 2 and 3 Boxes, respectively. That is the MultiFab on process 0 has 2 FArrayBoxes, whereas there "
"are 3 FArrayBoxes on process 1. Thus the numbers of iterations of MFIter are 2 and 3 on processes 0 and 1, respectively."
msgstr ""
"`MFIter`仅循环遍历本进程拥有的网格。例如，假设总共有5个盒子，进程0和1分别拥有2个和3个盒子。这意味着在进程0上的MultiFab有2个FArrayBoxes，在进程1上有3个FArrayBoxes。因此，在进程0上，`"
"MFIter`的迭代次数为2，在进程1上为3。"

#: ../../source/Basics.rst:1719 8739b77de81c4e2c98097d6353be9358
msgid ""
"In the example above, :cpp:`MultiFab` is assumed to have a single component. If it has multiple components, we can call "
"``int nc = mf.nComp()`` or ``int nc = a.nComp()`` to get the number of components."
msgstr "在上面的示例中，假设 `MultiFab` 只有一个分量。如果它有多个分量，我们可以调用 `int nc = mf.nComp()` 或 `int nc = a.nComp()` 来获取分量的数量。"

#: ../../source/Basics.rst:1723 138e342cbb8840149982c4c18279c490
msgid ""
"There is only one :cpp:`MultiFab` in the example above. Below is an example of working with multiple MultiFabs. Note "
"that these two MultiFabs are not necessarily built on the same :cpp:`BoxArray`.  But they must have the same "
":cpp:`DistributionMapping`, and their BoxArrays are typically related (e.g., they are different due to index types)."
msgstr ""
"在上面的示例中只有一个 `MultiFab`。下面是一个使用多个 `MultiFab` 的示例。请注意，这两个 `MultiFab` 不一定建立在相同的 `BoxArray` 上。但它们必须具有相同的 "
"`DistributionMapping`，它们的 `BoxArray` 通常是相关的（例如，由于索引类型不同而不同）。"

#: ../../source/Basics.rst:1744 91985a7af3a745f0a6c08b089127e27b
msgid "Here function :cpp:`f2` might be something like below,"
msgstr "这里的 `f2` 函数可能是以下这样的："

#: ../../source/Basics.rst:1770 a8f23d7a73004a42858e8e839c09df55
msgid "MFIter with Tiling"
msgstr "使用 MFIter 进行切片操作"

#: ../../source/Basics.rst:1772 82216a5b45354f56bf863fbabae230f6
msgid ""
"Tiling, also known as cache blocking, is a well known loop transformation technique for improving data locality.  This "
"is often done by transforming the loops into tiling loops that iterate over tiles and element loops that iterate over "
"the data elements within a tile. For example, the original loops might look like this in Fortran"
msgstr "平铺，也被称为缓存阻塞，是一种改善数据局部性的众所周知的循环转换技术。通常通过将循环转换为迭代瓦片的平铺循环和迭代瓦片内数据元素的元素循环来实现。例如，在Fortran中，原始循环可能如下所示："

#: ../../source/Basics.rst:1791 840299a30eeb4e2798226b8bbd705bcd
msgid "And the manually tiled loops might look like"
msgstr "而手动平铺的循环可能会看起来像这样"

#: ../../source/Basics.rst:1812 ae3444d324c14cd7b18e1846f4eae351
msgid ""
"As we can see, to manually tile individual loops is very labor-intensive and error-prone for large applications. AMReX "
"has incorporated the tiling construct into :cpp:`MFIter` so that the application codes can get the benefit of tiling "
"easily. An :cpp:`MFIter` loop with tiling is almost the same as the non-tiling version. The first example in (see the "
"previous section on :ref:`sec:basics:mfiter:notiling`) requires only two minor changes:"
msgstr ""
"正如我们所看到的，对于大型应用程序来说，手动对每个循环进行切片非常费时且容易出错。AMReX已将切片结构整合到了`MFIter`中，以便应用程序可以轻松地获得切片的好处。带有切片的`MFIter`"
"循环与非切片版本几乎相同。在（参见前一节的:ref:`sec:basics:mfiter:notiling`）中的第一个示例只需要进行两个小的更改："

#: ../../source/Basics.rst:1819 6f5b368c11064b558f856107972f4514
msgid "passing :cpp:`true` when defining :cpp:`MFIter` to indicate tiling;"
msgstr "在定义 `MFIter` 时，通过传递 `true` 来指示切片操作；"

#: ../../source/Basics.rst:1820 fefb8cf130fb46b7ae53329850428664
msgid "calling :cpp:`tilebox` instead of :cpp:`validbox` to obtain the work region for the loop iteration."
msgstr "在循环迭代中，调用 `tilebox` 而不是 `validbox` 来获取工作区域。"

#: ../../source/Basics.rst:1838 c700ee66cb7e43168703c19ffe9c8ec7
msgid "The second example in the previous section on :ref:`sec:basics:mfiter:notiling` also requires only two minor changes."
msgstr "在前一节的示例中，第二个示例 :ref:`sec:basics:mfiter:notiling` 也只需要进行两个小的更改。"

#: ../../source/Basics.rst:1856 a4fe56d5de0d4d4ebfd99debd142c9a3
msgid "The kernels functions like :cpp:`f1` and :cpp:`f2` in the two examples here usually require very little changes."
msgstr "这两个示例中的内核函数，如 `f1` 和 `f2`，通常需要进行非常少的更改。"

#: ../../source/Basics.rst:1868 c3f9e66fd82140d79cd47c6854183a1e
msgid "Comparison of :cpp:`MFIter` with (right) and without (left) tiling."
msgstr "比较：使用（右侧）和不使用（左侧）tiling的cpp::MFIter。"

#: ../../source/Basics.rst:1872 bf0a0e1f29e6459e9254ea4bc659e91a
msgid "|a|"
msgstr "|a|"

#: ../../source/Basics.rst:1859 6eda20f1cc5144908754cba6cc08dc82
msgid "a"
msgstr "一个"

#: ../../source/Basics.rst:1872 0503567bb7a148839d0cdede92bc77e4
msgid "|b|"
msgstr "|b|"

#: ../../source/Basics.rst:1863 2b120ae29596458ba865af15839943a3
msgid "b"
msgstr "b"

#: ../../source/Basics.rst dbacd2bef0134002842e9497d6e76588
msgid "Example of cell-centered valid boxes."
msgstr "细胞居中的有效框示例。"

#: ../../source/Basics.rst bc82be3e22f24523bf9007c0646f2c38
msgid "There are two valid boxes in this example."
msgstr "在这个示例中有两个有效的框。"

#: ../../source/Basics.rst af5a687cd8bc402f868c2f518838f033
msgid "Each has :math:`8^2` cells."
msgstr "每个有 :math:`8^2` 个单元格。"

#: ../../source/Basics.rst 5e37f7dd4b804b65885b336c9f69aa80
msgid "Example of cell-centered tile boxes. Each grid"
msgstr "细胞居中的瓷砖盒子示例。每个网格"

#: ../../source/Basics.rst 887a958036ad45bd86e95836c0cb18b8
msgid "is *logically* broken into 4 tiles, and each tile"
msgstr "被*逻辑上*分为4个瓷砖，并且每个瓷砖"

#: ../../source/Basics.rst 076f976b98864d23bc2a609a925c2602
msgid "as :math:`4^2` cells. There are 8 tiles in total."
msgstr "有 :math:`4^2` 个单元格。总共有 8 个瓷砖。"

#: ../../source/Basics.rst:1879 a7fd589016bf435b88fa6de64c7963ca
msgid ""
":numref:`fig:basics:cc_comparison` shows an example of the difference between :cpp:`validbox` and :cpp:`tilebox`. In "
"this example, there are two grids of cell-centered index type. The function :cpp:`validbox` always returns a :cpp:`Box` "
"for the valid region of an :cpp:`FArrayBox` no matter whether or not tiling is enabled, whereas the function "
":cpp:`tilebox` returns a :cpp:`Box` for a tile. (Note that when tiling is disabled, :cpp:`tilebox` returns the same "
":cpp:`Box` as :cpp:`validbox`.) The number of loop iteration is 2 in the non-tiling version, whereas in the tiling "
"version the kernel function is called 8 times."
msgstr ""
"图:numref:`fig:basics:cc_comparison`展示了:cpp:`validbox`和:cpp:`tilebox`之间的区别示例。在这个示例中，有两个以单元格为中心的索引类型的网格。函数:cpp:`validbox`"
"始终返回一个:cpp:`Box`，表示:cpp:`FArrayBox`的有效区域，无论是否启用了平铺。而函数:cpp:`tilebox`返回一个表示平铺的:cpp:`Box`。（请注意，当禁用平铺时，:cpp:`tilebox`"
"返回与:cpp:`validbox`相同的:cpp:`Box`。）在非平铺版本中，循环迭代的次数为2次，而在平铺版本中，内核函数被调用了8次。"

#: ../../source/Basics.rst:1889 1cb228f9fd914b379428ccc2591ce71b
msgid ""
"It is important to use the correct :cpp:`Box` when implementing tiling, especially if the box is used to define a work "
"region inside of the loop. For example:"
msgstr "在实现平铺时，使用正确的 `Box` 是非常重要的，特别是如果该 `Box` 用于在循环内定义工作区域。例如："

#: ../../source/Basics.rst:1904 b99520b2ad374194b0742c928b4e80c8
msgid "The tile size can be explicitly set when defining :cpp:`MFIter`."
msgstr "在定义 :cpp:`MFIter` 时，可以明确设置瓦片大小。"

#: ../../source/Basics.rst:1913 73c0dfc5c8d04abb9d7513baab6c3fff
msgid ""
"An :cpp:`IntVect` is used to specify the tile size for every dimension.  A tile size larger than the grid size simply "
"means tiling is disabled in that direction. AMReX has a default tile size :cpp:`IntVect{1024000,8,8}` in 3D and no "
"tiling in 2D. This is used when tile size is not explicitly set but the tiling flag is on. One can change the default "
"size using :cpp:`ParmParse` (section :ref:`sec:basics:parmparse`) parameter ``fabarray.mfiter_tile_size.``"
msgstr ""
"一个 `IntVect` 用于指定每个维度的瓦片大小。如果瓦片大小大于网格大小，则表示在该方向上禁用了瓦片。在3D中，AMReX 默认的瓦片大小是 "
"`IntVect{1024000,8,8}`，在2D中不进行瓦片处理。当瓦片大小没有明确设置但瓦片标志打开时，会使用这个默认大小。可以使用 `ParmParse`（参见 :ref:`sec:basics:parmparse`）参数 "
"`fabarray.mfiter_tile_size` 来更改默认大小。"

#: ../../source/Basics.rst:1929 1a912e2865c24a7182ce80a2119b1f4f
msgid "Comparison of :cpp:`MFIter` with (right) and without (left) tiling, for face-centered nodal indexing."
msgstr "比较使用划分（右侧）和不使用划分（左侧）的cpp::MFIter，用于面心节点索引。"

#: ../../source/Basics.rst:1933 028df9bb1b0b42238dbac1e46e50f7d7
msgid "|c|"
msgstr "|c|"

#: ../../source/Basics.rst:1920 f57705373fe1441f8646592383ab736a
msgid "c"
msgstr "c"

#: ../../source/Basics.rst:1933 103c6346e89544aba4a9dc45a52261ee
msgid "|d|"
msgstr "|d|"

#: ../../source/Basics.rst:1924 791b1aa06d634a26bd9463ff1d99fc38
msgid "d"
msgstr "d"

#: ../../source/Basics.rst e5776b24b87b42f19c011bfbb5ffb017
msgid "Example of face valid boxes. There are two"
msgstr "面向有效的盒子示例。有两个。"

#: ../../source/Basics.rst 981f01bdd7ce4d9e9f9dbb3de2036d64
msgid "valid boxes in this example. Each has"
msgstr "在这个示例中，有效的盒子。每个盒子都有。"

#: ../../source/Basics.rst b20a3ebf0c794d54ac5ddbd07e5e8013
msgid ":math:`9\\times 8` points. Note that points in one"
msgstr ":math:`9\\times 8` 点。请注意，一个组中的点数"

#: ../../source/Basics.rst c5a6384cc2224ae9a69df20235ebf5ef
msgid ":cpp:`Box` may overlap with points in the other"
msgstr ":cpp:`Box` 可能与其他点重叠"

#: ../../source/Basics.rst 3028bd4e3d7a431c92d6083c2dcb64f0
msgid ":cpp:`Box`. However, the memory locations for"
msgstr ":cpp:`Box`. 然而，内存位置对于"

#: ../../source/Basics.rst 56ed928eab35458e9f539020b26d2122
msgid "storing floating point data of those points do"
msgstr "存储这些点的浮点数据。"

#: ../../source/Basics.rst 4116424d4bc24984baef1edc6701dfeb
msgid "not overlap, because they belong to separate"
msgstr "不重叠，因为它们属于不同的部分。"

#: ../../source/Basics.rst a268a4c275994adbb6e8e148f5181df9
msgid "FArrayBoxes."
msgstr "FArrayBoxes."

#: ../../source/Basics.rst fe8be62028144562a40a1d3c90804a2c
msgid "Example of face tile boxes. Each grid is"
msgstr "面砖盒的示例。每个格子是"

#: ../../source/Basics.rst 90c9fb124fd94d58bd509a33fe85fab8
msgid "*logically* broken into 4 tiles as indicated by"
msgstr "根据指示，可以将其*逻辑上*分为4个瓷砖。"

#: ../../source/Basics.rst cc0a06b40a714b33981fbd86688f73fc
msgid "the symbols. There are 8 tiles in total. Some"
msgstr "这些符号。总共有8个瓷砖。有些"

#: ../../source/Basics.rst 2e4c060186344db888fe285752437a68
msgid "tiles have :math:`5\\times 4` points, whereas"
msgstr "瓦片有5×4个点。"

#: ../../source/Basics.rst ab81a012cc934474b4232fb95e32d768
msgid "others have :math:`4 \\times 4` points. Points from"
msgstr "其他人有：math:`4 \\times 4`个点。来自的点"

#: ../../source/Basics.rst a483209835854558a59bc892c27e2228
msgid "different Boxes may overlap, but points from"
msgstr "不同的方框可能会重叠，但点来自于"

#: ../../source/Basics.rst 9051e3e5bf024e17a398f47c86fdc282
msgid "different tiles of the same Box do not."
msgstr "相同盒子的不同瓦片不会这样。"

#: ../../source/Basics.rst:1945 7cb96ee1ca494ea6b91605c125e52719
msgid ""
"Dynamic tiling, which runs one box per OpenMP thread, is also available. This is useful when the underlying work cannot "
"benefit from thread parallelization.  Dynamic tiling is implemented using the :cpp:`MFItInfo` object and requires the "
":cpp:`MFIter` loop to be defined in an OpenMP parallel region:"
msgstr ""
"还有一种可用的动态切片方法，它会在每个OpenMP线程上运行一个盒子。当底层工作无法从线程并行化中受益时，这种方法非常有用。动态切片是通过使用:cpp:`MFItInfo`对象来实现的，并且需要在OpenMP并行区域中定义:cpp:`"
"MFIter`循环。"

#: ../../source/Basics.rst:1967 0516a47164ec40c8b3a3e864f31915cf
msgid "Dynamic tiling also allows explicit definition of a tile size:"
msgstr "动态平铺还允许显式定义瓷砖的大小："

#: ../../source/Basics.rst:1984 08fd2ee570f24977b9b2dd7430cbc333
msgid ""
"Usually :cpp:`MFIter` is used for accessing multiple MultiFabs like the second example, in which two MultiFabs, "
":cpp:`U` and :cpp:`F`, use :cpp:`MFIter` via :cpp:`operator[]`. These different MultiFabs may have different BoxArrays. "
"For example, :cpp:`U` might be cell-centered, whereas :cpp:`F` might be nodal in :math:`x`-direction and cell in other "
"directions. The :cpp:`MFIter::validbox` and :cpp:`tilebox` functions return Boxes of the same type as the "
":cpp:`MultiFab` used in defining the :cpp:`MFIter` (:cpp:`F` in this example). :numref:`fig:basics:ec_comparison` "
"illustrates an example of non-cell-centered valid and tile boxes. Besides :cpp:`validbox` and :cpp:`tilebox`, "
":cpp:`MFIter` has a number of functions returning various Boxes.  Examples include,"
msgstr ""
"通常情况下，使用`MFIter`来访问多个MultiFab，就像第二个示例中那样。在这个示例中，两个MultiFab，即`U`和`F`，通过`MFIter`和`operator[]`"
"进行访问。这些不同的MultiFab可能具有不同的BoxArrays。例如，`U`可能是以单元为中心，而`F`可能在x方向上是节点的，在其他方向上是单元的。`MFIter::validbox`和`tilebox`函数返回与定义`"
"MFIter`时使用的MultiFab（在本示例中为`F`）相同类型的Boxes。在:numref:`fig:basics:ec_comparison`中，展示了一个非单元为中心的有效和tile "
"boxes的示例。除了`validbox`和`tilebox`之外，`MFIter`还有许多返回不同Boxes的函数。例如，"

#: ../../source/Basics.rst:2009 78dc6f3d495c44fbab7a36022f7e0ed4
msgid ""
"It should be noted that the function :cpp:`growntilebox` does not grow the tile Box like a normal :cpp:`Box`. Growing a "
":cpp:`Box` normally means the Box is extended in every face of every dimension.  However, the function "
":cpp:`growntilebox` only extends the tile Box in such a way that tiles from the same grid do not overlap. This is the "
"basic design principle of these various tiling functions. Tiling is a way of domain decomposition for work sharing. "
"Overlapping tiles is undesirable because work would be wasted and for multi-threaded codes race conditions could occur."
msgstr ""
"需要注意的是，函数 `growntilebox` 并不像普通的 `Box` 那样扩展 Tile Box。通常情况下，扩展一个 `Box` 意味着在每个维度的每个面上都会进行扩展。然而，`growntilebox` "
"函数只会以一种不重叠的方式扩展 Tile Box，以确保来自同一网格的瓦片不会重叠。这是这些不同平铺函数的基本设计原则。平铺是一种用于工作共享的域分解方法。重叠的瓦片是不可取的，因为会浪费工作量，并且在多线程代码中可能会出现竞争条件。"

#: ../../source/Basics.rst:2027 f6eb07eae4bd4f238367c54b78475655
msgid "Comparing growing cell-type and face-type tile boxes."
msgstr "比较生长型细胞和面型瓷砖盒。"

#: ../../source/Basics.rst:2031 631942a5247b409fac48bc0f23cb44dd
msgid "|e|"
msgstr "|e|"

#: ../../source/Basics.rst:2018 3a02278b6483403bb96f839c58c65645
msgid "e"
msgstr "e"

#: ../../source/Basics.rst:2031 c192a6fcb5e54bc4ad065ffd11faa62e
msgid "|f|"
msgstr "|f|"

#: ../../source/Basics.rst:2022 93a193f22b594d18a6e7a3f4d2392e98
msgid "f"
msgstr "f"

#: ../../source/Basics.rst 4ea56372cf15408ab1fa3b8a7b570d4b
msgid "Example of cell-centered grown tile boxes. As"
msgstr "细胞中心生长的瓷砖盒子的示例。"

#: ../../source/Basics.rst 5370fa5996e44f34ac537168388c0b34
msgid "indicated by symbols and colors, there are 4"
msgstr "根据符号和颜色的指示，有4个。"

#: ../../source/Basics.rst b404d6ccf35141b4997c7c80918ca489
msgid "tiles per grid in this example. Tiles from the"
msgstr "在这个示例中，每个网格的瓷砖数量。从瓷砖中"

#: ../../source/Basics.rst bac4d25403bf45e7be950b11c14491cf
msgid "same grid do not overlap. But tiles from"
msgstr "相同的网格不重叠。但是来自瓷砖的"

#: ../../source/Basics.rst de02ab43b23947aebd58d6a14648724a
msgid "different grids may overlap."
msgstr "不同的网格可能会重叠。"

#: ../../source/Basics.rst 63aab0cc83a84107b6bd4781878d7eb8
msgid "Example of face type grown tile boxes. As"
msgstr "面型种植瓦盒的示例。"

#: ../../source/Basics.rst e8bc17ba10bb4144a7337c93c50dd913
msgid "indicated by symbols and colors, there are 4 tiles"
msgstr "根据符号和颜色指示，有4个瓷砖。"

#: ../../source/Basics.rst ca6cd6eeb6b34de8a23cc828b82aedfa
msgid "per grid in this example. Tiles from the"
msgstr "在这个示例中，每个网格。瓷砖从..."

#: ../../source/Basics.rst 8fe6a15cf5c4450fa5023a6505861e95
msgid "same grid do not overlap even though they"
msgstr "相同的网格不会重叠，即使它们"

#: ../../source/Basics.rst fa1fc74ba7564ec38f90a0680d0bbe55
msgid "have face index type."
msgstr "有面部指数类型。"

#: ../../source/Basics.rst:2041 1a15e9c51c8449988daf1fe4ec44145b
msgid ""
":numref:`fig:basics:growbox_comparison` illustrates an example of :cpp:`growntilebox`. These functions in :cpp:`MFIter` "
"return :cpp:`Box` by value. There are three ways of using these functions."
msgstr ":numref:`fig:basics:growbox_comparison`展示了一个:cpp:`growntilebox`的示例。在:cpp:`MFIter`中，这些函数通过值返回:cpp:`Box`。有三种使用这些函数的方式。"

#: ../../source/Basics.rst:2060 d5fa842171234601bdffa635b54d68ae
msgid "But :cpp:`Box& bx = mfi.validbox()` is not legal and will not compile."
msgstr "但是 `:cpp:`Box& bx = mfi.validbox()` 是不合法的，并且无法编译通过。"

#: ../../source/Basics.rst:2062 9a6b2b0cafdb4ad498b741c1fdc401e5
msgid "Finally it should be emphasized that tiling should not be used when running on GPUs because of kernel launch overhead."
msgstr "最后需要强调的是，在使用GPU运行时，不应该使用平铺（tiling）技术，因为这会增加内核启动的开销。"

#: ../../source/Basics.rst:2066 eb21932ddc3d42ce82dde94f686d4b11
msgid "Multiple MFIters"
msgstr "多个MFIters"

#: ../../source/Basics.rst:2068 aac97dbc74db40c699980a71ff3c0b3d
msgid "To avoid some common bugs, it is not allowed to have multiple active :cpp:`MFIter` objects like below by default."
msgstr "为了避免一些常见的错误，不允许默认情况下同时存在多个活动的 `MFIter` 对象，如下所示。"

#: ../../source/Basics.rst:2087 9ea903e2597a4dfaac9c544b0c058c83
msgid "The will results in an assertion failure at runtime.  To disable the assertion, one could call"
msgstr "运行时将导致断言失败。要禁用断言，可以调用"

#: ../../source/Basics.rst:2106 8c2ba9e9a3664434bfd67c53dd343d76
msgid "Fortran and C++ Kernels"
msgstr "Fortran和C++内核"

#: ../../source/Basics.rst:2108 34ccdcaca4c1480d9e173af3240861d5
msgid ""
"In the section on :ref:`sec:basics:mfiter`, we have shown that a typical pattern for working with MultiFabs is to use "
":cpp:`MFIter` to iterate over the data. In each iteration, a kernel function is called to work on the data and the work "
"region is specified by a :cpp:`Box`.  When tiling is used, the work region is a tile. The tiling is logical in the "
"sense that there is no data layout transformation. The kernel function still gets the whole arrays in :cpp:`FArrayBox`\\ "
"es, even though it is supposed to work on a tile region of the arrays.  We have shown examples of writing kernels in "
"C++ in the previous section.  Fortran is also often used for writing these kernels because of its native "
"multi-dimensional array support.  To C++, these kernel functions are C functions, whose function signatures are "
"typically declared in a header file named ``*_f.H`` or ``*_F.H``. We recommend the users to follow this convention. "
"Examples of these function declarations are as follows."
msgstr ""
"在:ref:`sec:basics:mfiter`部分中，我们展示了使用:cpp:`MFIter`迭代数据的典型模式。在每次迭代中，调用一个核函数来处理数据，工作区域由一个:cpp:`Box`"
"指定。当使用切片时，工作区域是一个切片。切片在逻辑上是存在的，没有数据布局转换。核函数仍然会获得:cpp:`FArrayBox`中的整个数组，即使它应该在数组的切片区域上工作。我们在前一节中展示了使用C++"
"编写核函数的示例。由于Fortran具有本地多维数组支持，因此通常也用于编写这些核函数。对于C++来说，这些核函数是C函数，其函数签名通常在名为``*_f.H``或``*_F.H``"
"的头文件中声明。我们建议用户遵循这个约定。以下是这些函数声明的示例。"

#: ../../source/Basics.rst:2139 b25d9268a51244f88824c5a9e10c4b56
msgid ""
"These Fortran functions take C pointers and view them as multi-dimensional arrays of the shape specified by the "
"additional integer arguments.  Note that Fortran takes arguments by reference unless the :fortran:`value` keyword is "
"used. So an integer argument on the Fortran side matches an integer pointer on the C++ side. Thanks to Fortran 2003, "
"function name mangling is easily achieved by declaring the Fortran function as :fortran:`bind(c)`."
msgstr ""
"这些Fortran函数接受C指针，并将其视为由附加整数参数指定形状的多维数组。请注意，除非使用:fortran:`value`关键字，否则Fortran按引用传递参数。因此，Fortran端的整数参数与C++"
"端的整数指针相匹配。由于Fortran 2003的存在，函数名修饰很容易通过将Fortran函数声明为:fortran:`bind(c)`来实现。"

#: ../../source/Basics.rst:2147 17d04773c5b04f09b8a703c306981ef6
msgid "AMReX provides many macros for passing an FArrayBox's data into Fortran/C. For example"
msgstr "AMReX提供了许多宏，用于将FArrayBox的数据传递给Fortran/C。例如，"

#: ../../source/Basics.rst:2161 ed3d90ab77aa46cbbf45b4f31aa4a336
msgid ""
"Here :cpp:`BL_TO_FORTRAN_BOX` takes a :cpp:`Box` and provides two :cpp:`int *` s specifying the lower and upper bounds "
"of the Box.  :cpp:`BL_TO_FORTRAN_ANYD` takes an :cpp:`FArrayBox` returned by :cpp:`mf[mfi]` and the preprocessor turns "
"it into :cpp:`Real *, int *, int *`, where :cpp:`Real *` is the data pointer that matches real array argument in "
"Fortran, the first :cpp:`int *` (which matches an integer argument in Fortran) specifies the lower bounds, and the "
"second :cpp:`int *` the upper bounds of the spatial dimensions of the array. An example of the Fortran function is "
"shown below,"
msgstr ""
"在这里，`BL_TO_FORTRAN_BOX`接受一个`Box`对象，并提供两个`int*`，指定了Box的下界和上界。`BL_TO_FORTRAN_ANYD`接受由`mf[mfi]`返回的`FArrayBox`"
"对象，并通过预处理器将其转换为`Real*，int*，int*`，其中`Real*`是与Fortran中的实数数组参数匹配的数据指针，第一个`int*`（与Fortran中的整数参数匹配）指定了数组的下界，第二个`int*`"
"指定了数组的空间维度的上界。下面是Fortran函数的一个示例："

#: ../../source/Basics.rst:2180 18c3a418f1344212a31d0c6b4071f6df
msgid ""
"Here, the size of the integer arrays is 3, the maximal number of spatial dimensions. If the actual spatial dimension is "
"less than 3, the values in the degenerate dimensions are set to zero. So the Fortran function interface does not have "
"to change according to the spatial dimensionality, and the bound of the third dimension of the data array simply "
"becomes :fortran:`0:0`. With the data passed by :cpp:`BL_TO_FORTRAN_BOX` and :cpp:`BL_FORTRAN_ANYD`, this version of "
"Fortran function interface works for any spatial dimensions. If one wants to write a special version just for 2D and "
"would like to use 2D arrays, one can use"
msgstr ""
"在这里，整数数组的大小为3，即空间维度的最大数量。如果实际的空间维度小于3，则退化维度中的值被设为零。因此，Fortran函数接口不需要根据空间维度的变化而改变，数据数组的第三个维度的边界简单地变为:fortran:`0:0`"
"。通过:cpp:`BL_TO_FORTRAN_BOX`和:cpp:`BL_FORTRAN_ANYD`传递的数据，这个版本的Fortran函数接口适用于任何空间维度。如果想要编写一个专门针对2D的特殊版本，并且想要使用2D数组，可以使用"

#: ../../source/Basics.rst:2200 b462ffbe3e554631af4e48dbbd0eb76e
msgid ""
"Note that this does not require any changes in the C++ part, because when C++ passes an integer pointer pointing to an "
"array of three integers Fortran can treat it as a 2-element integer array."
msgstr "请注意，在C++部分不需要进行任何更改，因为当C++传递一个指向包含三个整数的数组的整数指针时，Fortran可以将其视为一个包含两个元素的整数数组。"

#: ../../source/Basics.rst:2204 ce5957411c3f4a12a4b13d10cb2fc133
msgid ""
"Another commonly used macro is :cpp:`BL_TO_FORTRAN`. This macro takes an :cpp:`FArrayBox` and provides a real pointer "
"for the floating point data array and a number of integer scalars for the bounds.  However, the number of the integers "
"depends on the dimensionality.  More specifically, there are 6 and 4 integers for 2D and 3D, respectively. The first "
"half of the integers are the lower bounds for each spatial dimension and the second half the upper bounds. For example,"
msgstr ""
"另一个常用的宏是：cpp:`BL_TO_FORTRAN`。该宏接受一个：cpp:`FArrayBox`，并为浮点数据数组提供一个实际指针，以及一些整数标量用于表示边界。然而，整数的数量取决于维度。具体而言，对于二维情况，有6"
"个整数；对于三维情况，有4个整数。这些整数的前一半表示每个空间维度的下界，后一半表示上界。例如，"

#: ../../source/Basics.rst:2228 5ddb75bab3854ccaabd34f168814b375
msgid "Here for simplicity we have omitted passing the tile Box."
msgstr "为了简化，我们省略了传递瓷砖盒子的步骤。"

#: ../../source/Basics.rst:2230 f6eabe59f5a54c299c06c04f1f410519
msgid ""
"Usually :cpp:`MultiFab`\\ s  have multiple components. Thus we often also need to pass the number of component into "
"Fortran functions. We can obtain the number by calling the :cpp:`MultiFab::nComp()` function, and pass it to Fortran.  "
"We can also use the :cpp:`BL_TO_FORTRAN_FAB` macro that is similar to :cpp:`BL_TO_FORTRAN_ANYD` except that it provides "
"an additional :cpp:`int *` for the number of components. The Fortran function matching :cpp:`BL_TO_FORTRAN_FAB(fab)` is "
"then like below,"
msgstr ""
"通常，`MultiFab` 类有多个组件。因此，我们经常需要将组件的数量传递给 Fortran 函数。我们可以通过调用 `MultiFab::nComp()` 函数来获取组件的数量，并将其传递给 Fortran。我们还可以使用 "
"`BL_TO_FORTRAN_FAB` 宏，它类似于 `BL_TO_FORTRAN_ANYD`，但提供了一个额外的 `int *` 参数用于组件的数量。匹配 `BL_TO_FORTRAN_FAB(fab)` 的 Fortran "
"函数如下所示："

#: ../../source/Basics.rst:2249 358dc2561693494087dbc8df3ae7a6e5
msgid ""
"There is a potential type safety issue when calling Fortran functions from C++.  If there is a mismatch between the "
"function declaration on the C++ side and the function definition in Fortran, the compiler cannot catch it.  For example"
msgstr "在从C++调用Fortran函数时存在潜在的类型安全问题。如果C++端的函数声明与Fortran中的函数定义不匹配，编译器无法捕捉到这个问题。例如，"

#: ../../source/Basics.rst:2274 3d7e643f9cc54f9abeb1049b7f1e2064
msgid "The code above will compile without errors even though the number of arguments and types don't match."
msgstr "尽管参数的数量和类型不匹配，上述代码将会编译通过而不会出现错误。"

#: ../../source/Basics.rst:2277 09190c6030124b8bb5128d0f6b7265e1
msgid ""
"To help detect this kind of issues, AMReX provides a type check tool. Note that it only works when GCC is used.  In the "
"directory an AMReX based code is compiled, type"
msgstr "为了帮助检测这类问题，AMReX提供了一种类型检查工具。请注意，该工具仅在使用GCC编译时有效。在编译基于AMReX的代码的目录中，输入以下命令："

#: ../../source/Basics.rst:2287 2652ef42def240d686dec21530be391c
msgid ""
"Extra arguments used in a usual AMReX build (e.g., USE_MPI=TRUE DIM=2) can be added.  When it finishes, the output may "
"look like,"
msgstr "通常在 AMReX 构建过程中可以添加额外的参数（例如，USE_MPI=TRUE DIM=2）。当构建完成后，输出可能如下所示："

#: ../../source/Basics.rst:2299 c8dbb244dee4412aab8ea5993af3ae8d
msgid ""
"It should be noted that Fortran by default passes argument by reference.  In the example output above, ``pointer`` in "
"``Fortran type ('INTEGER 4', 'pointer', 'x')`` means it's a reference to argument (i.e., C pointer), not a Fortran "
"pointer."
msgstr ""
"需要注意的是，Fortran默认按引用传递参数。在上面的示例输出中，\"Fortran type ('INTEGER 4', 'pointer', 'x')\" 中的 \"pointer\" "
"表示它是一个对参数的引用（即C指针），而不是Fortran指针。"

#: ../../source/Basics.rst:2304 9aeeeebebaba4ccf93475fa0d2e6fdff
msgid ""
"The type check tool has known limitations.  For a function to be checked by the tool in the GNU make build system, the "
"declaration must be in a header file named ``*_f.H`` or ``*_F.H``, and the header file must be in the ``CEXE_headers`` "
"make variable.  The headers are preprocessed first by cpp as C language, and is then parsed by pycparser "
"(https://pypi.python.org/pypi/pycparser) that needs to be installed on your system.  Because pycparser is a C parser, "
"C++ parts of the headers (e.g., :cpp:`extern \"C\" {`) need to be hidden with macro :cpp:`#ifdef __cplusplus`.  Headers "
"like ``AMReX_BLFort.H`` can be used as a C header, but most other AMReX headers cannot and should be hidden by "
":cpp:`#ifdef __cplusplus` if they are included.  More details can be found at ``amrex/Docs/Readme.typecheck``.  Despite "
"these limitations, it is recommended to use the type check tool and report issues to us."
msgstr ""
"这个类型检查工具有一些已知的限制。在GNU "
"make构建系统中，要使函数能够被该工具检查，声明必须位于名为``*_f.H``或``*_F.H``的头文件中，并且该头文件必须在``CEXE_headers``"
"的make变量中。这些头文件首先会被cpp预处理为C语言，然后由pycparser解析（https://pypi.python.org/pypi/"
"pycparser），你需要在你的系统上安装pycparser。由于pycparser是一个C解析器，头文件中的C++部分（例如：:cpp:`extern \"C\" {`）需要用宏 :cpp:`#ifdef __cplusplus` "
"进行隐藏。像``AMReX_BLFort.H``这样的头文件可以作为C头文件使用，但大多数其他的AMReX头文件不能，如果它们被包含在内，应该用 :cpp:`#ifdef __cplusplus` "
"进行隐藏。更多详细信息可以在``amrex/Docs/Readme.typecheck``中找到。尽管存在这些限制，建议使用类型检查工具并向我们报告问题。"

#: ../../source/Basics.rst:2321 daf76d55d7b345b58e09b4687db1ae34
msgid ""
"Although Fortran has native multi-dimensional array, we recommend writing kernels in C++ because of performance "
"portability for CPU and GPU.  AMReX provides a multi-dimensional array type of syntax, similar to Fortran, that is "
"readable and easy to implement.  We have demonstrated how to use :cpp:`Array4` in previous sections.  Because of its "
"importance, we will summarize its basic usage again with the example below."
msgstr ""
"尽管Fortran具有本地的多维数组，但我们建议使用C++编写内核，因为它在CPU和GPU上具有性能可移植性。AMReX提供了一种类似于Fortran的多维数组语法，易于阅读和实现。我们在之前的章节中已经演示了如何使用:cpp:`"
"Array4`。由于它的重要性，我们将再次总结其基本用法，如下所示的示例。"

#: ../../source/Basics.rst:2357 a336b9acfd974e4d81b496313a1aab18
msgid ""
"A :cpp:`Box` and two :cpp:`FArrayBox`\\es are passed to a C++ kernel function.  In the function, :cpp:`amrex::lbound` "
"and :cpp:`amrex::ubound` are called to get the start and end of the loops from :cpp:`Box::smallEnd()` and "
":cpp:`Box::bigEnd` of ``bx``.  Both functions return a :cpp:`amrex::Dim3`, a trivial type containing three integers. "
"The individual components are accessed by using :cpp:`.x`, :cpp:`.y` and :cpp:`.z`, as shown in the :cpp:`for` loops."
msgstr ""
"一个 `Box` 和两个 `FArrayBox` 被传递给一个 C++ 内核函数。在函数中，使用 `amrex::lbound` 和 `amrex::ubound` 从 `bx` 的 `Box::smallEnd()` 和 "
"`Box::bigEnd()` 获取循环的起始和结束。这两个函数返回一个 `amrex::Dim3`，一个包含三个整数的简单类型。可以使用 `.x`、`.y` 和 `.z` 来访问各个分量，就像 `for` 循环中所示。"

#: ../../source/Basics.rst:2365 3878c8d0396445138d8377d4add60b51
msgid ""
":cpp:`BaseFab::array()` is called to obtain an :cpp:`Array4` object that is designed as an independent, "
":cpp:`operator()` based accessor to the :cpp:`BaseFab` data. :cpp:`Array4` is an AMReX class that contains a pointer to "
"the :cpp:`FArrayBox` data and two :cpp:`Dim3` structs that contain the bounds of the :cpp:`FArrayBox`.  The bounds are "
"stored to properly translate the three dimensional coordinates to the appropriate location in the one-dimensional "
"array.  :cpp:`Array4`\\'s :cpp:`operator()` can also take a fourth integer to access across states of the "
":cpp:`FArrayBox`.  When AMReX is built for 1D or 2D, it can be used by passing `0` to the missing dimensions."
msgstr ""
"调用`BaseFab::array()`函数可以获取一个`Array4`对象，该对象被设计为独立的、基于`operator()`的访问器，用于访问`BaseFab`数据。`Array4`是一个AMReX类，它包含一个指向`"
"FArrayBox`数据的指针，以及两个包含`FArrayBox`边界的`Dim3`结构体。这些边界被存储起来，以便将三维坐标正确转换为一维数组中的相应位置。`Array4`的`operator()`还可以接受第四个整数，用于跨越`"
"FArrayBox`的状态进行访问。当AMReX构建为1D或2D时，可以通过将缺失的维度传递为`0`来使用它。"

#: ../../source/Basics.rst:2376 eb0eb504e37a406380c3f492be8c287a
msgid ""
"The ``AMREX_PRAGMA_SIMD`` macro is placed in the innermost loop to notify the compiler that loop iterations are "
"independent and it is safe to vectorize the loop.  This should be done whenever possible to achieve the best "
"performance. Be aware: the macro generates a compiler dependent pragma, so their exact effect on the resulting code is "
"also compiler dependent.  It should be emphasized that using the ``AMREX_PRAGMA_SIMD`` macro on loops that are not safe "
"for vectorization may lead to errors, so if unsure about the independence of the iterations of a loop, test and verify "
"before adding the macro."
msgstr ""
"在最内层循环中放置``AMREX_PRAGMA_SIMD``"
"宏，以通知编译器循环迭代是独立的，可以安全地对循环进行向量化。为了获得最佳性能，应尽可能地使用该宏。需要注意的是，该宏会生成与编译器相关的编译指示，因此对生成的代码产生的确切影响也取决于编译器。强调一点，如果在不适合向量化的循环上使用``"
"AMREX_PRAGMA_SIMD``宏可能会导致错误，因此如果对循环的迭代独立性不确定，请在添加该宏之前进行测试和验证。"

#: ../../source/Basics.rst:2386 9b2de1d8ae724b909c35e9c7a48ba06b
msgid ""
"These loops should usually use :cpp:`i <= hi.x`, not :cpp:`i < hi.x`, when defining the loop bounds. If not, the "
"highest index cells will be left out of the calculation."
msgstr "通常情况下，这些循环应该使用 `i <= hi.x` 而不是 `i < hi.x` 来定义循环的边界。如果不这样做，最高索引的单元将被排除在计算之外。"

#: ../../source/Basics.rst:2393 90361a4c08ab48f4bd958fb57adeb659
msgid "ParallelFor"
msgstr "并行循环"

#: ../../source/Basics.rst:2395 9d0e55303c284c938bdcb97294959b3d
msgid ""
"In the examples so far, we have explicitly written out the for loops when we iterate over a :cpp:`Box`.  AMReX also "
"provides function templates for writing these in a concise and performance portable way like below,"
msgstr "到目前为止的示例中，我们在迭代 :cpp:`Box` 时明确地编写了 for 循环。AMReX 还提供了函数模板，以简洁且具有可移植性的方式编写这些循环，如下所示："

#: ../../source/Basics.rst:2419 443b61315efc4d50ae73abff3214297c
msgid ""
"Here, :cpp:`ParallelFor` takes two arguments.  The first argument is a :cpp:`Box` specifying the iteration index space, "
"and the second argument is a C++ lambda function that works on cell :cpp:`(i,j,k)`. Variables a, b and c in the lambda "
"function are captured by value from the enclosing scope.  The code above is performance portable.  It works with and "
"without GPU support.  When AMReX is built with GPU support, AMREX_GPU_DEVICE indicates that the lambda function is a "
"device function and :cpp:`ParallelFor` launches a GPU kernel to do the work. When it is built without GPU support, "
"AMREX_GPU_DEVICE has no effects whatsoever.  More details on :cpp:`ParallelFor` will be presented in section "
":ref:`sec:gpu:for`.  It should be emphasized that :cpp:`ParallelFor` does not start an OpenMP parallel region.  The "
"OpenMP parallel region will be started by the pragma above the :cpp:`MFIter` loop if it is built with OpenMP and "
"without enabling GPU.  Tiling is turned off if GPU is enabled so that more parallelism is exposed to GPU kernels. Also "
"note that when tiling is off, :cpp:`tilebox` returns :cpp:`validbox`."
msgstr ""
"这里，:cpp:`ParallelFor`接受两个参数。第一个参数是一个指定迭代索引空间的:cpp:`Box`，第二个参数是一个在单元格:cpp:`(i,j,k)`上工作的C++ "
"lambda函数。lambda函数中的变量a、b和c是从外部作用域按值捕获的。以上代码是性能可移植的，它可以在有或没有GPU支持的情况下工作。当使用GPU支持构建AMReX时，AMREX_GPU_"
"DEVICE表示lambda函数是一个设备函数，:cpp:`ParallelFor`会启动一个GPU内核来执行工作。当没有GPU支持构建AMReX时，AMREX_GPU_DEVICE没有任何效果。关于:cpp:`ParallelFor`"
"的更多细节将在第:ref:`sec:gpu:for`节中介绍。需要强调的是，:cpp:`ParallelFor`不会启动一个OpenMP并行区域。如果使用OpenMP构建，并且没有启用GPU，则在:cpp:`MFIter`循环之前的#"
"pragma会启动OpenMP并行区域。如果启用了GPU，则关闭平铺，以便将更多的并行性暴露给GPU内核。还要注意，当关闭平铺时，:cpp:`tilebox`返回:cpp:`validbox`。"

#: ../../source/Basics.rst:2437 a79032c8732949a5a064aa4bb4fb88c9
msgid "There are other versions of :cpp:`ParallelFor`,"
msgstr "有其他版本的 `ParallelFor`："

#: ../../source/Basics.rst:2451 d84cf70da5a94d0ab1c61fec84cf4eec
msgid "Ghost Cells"
msgstr "幽灵细胞"

#: ../../source/Basics.rst:2453 e5ab725a6efb4b30b2a63070a0069010
msgid ""
"AMReX uses a :cpp:`MultiFab` as a container for floating point data on multiple Boxes at a single level of refinement. "
"Each rectangular Box has its own boundaries on the low and high side in each coordinate direction. Each Box within a "
":cpp:`MultiFab` can have ghost cells for storing data outside the Box's valid region. This allows us to, e.g., perform "
"stencil-type operations on regular arrays. There are three basic types of boundaries:"
msgstr ""
"AMReX使用:cpp:`MultiFab`作为在单个细化级别上存储多个盒子中的浮点数据的容器。每个矩形盒子在每个坐标方向上都有自己的低边界和高边界。:cpp:`MultiFab`"
"中的每个盒子都可以有用于存储盒子有效区域之外数据的幽灵单元。这使我们能够在常规数组上执行类似于模板操作的操作。有三种基本类型的边界："

#: ../../source/Basics.rst:2460 41682438bb1c4889b2a580182831a704
msgid "interior boundary"
msgstr "内部边界"

#: ../../source/Basics.rst:2461 22c1867f22dd4521a04d9dcd1283b156
msgid "coarse/fine boundary"
msgstr "粗细界限"

#: ../../source/Basics.rst:2462 a994c0b126814a9a820cba6d275f80e2
msgid "physical boundary"
msgstr "物理边界"

#: ../../source/Basics.rst:2464 f05dcf349226412283517b702f58e1da
msgid ""
"Interior boundary is the border among the grid Boxes themselves.  For example, in :numref:`fig:basics:amrgrids`, the "
"two blue grid Boxes on level 1 share an interior boundary that is 10 cells long. For a :cpp:`MultiFab` with ghost cells "
"on level 1, we can use the :cpp:`MultiFab::FillBoundary` function introduced in the section on "
":ref:`sec:basics:multifab` to fill ghost cells at the interior boundary with valid cell data from other Boxes.  "
":cpp:`MultiFab::FillBoundary` can optionally fill periodic boundary ghost cells as well."
msgstr ""
"内部边界是网格盒子之间的边界。例如，在图:numref:`fig:basics:amrgrids`中，一级的两个蓝色网格盒子共享一个长度为10个单元的内部边界。对于一级带有幽灵单元的:cpp:`MultiFab`，我们可以使用在:ref:`"
"sec:basics:multifab`部分介绍的:cpp:`MultiFab::FillBoundary`函数，将内部边界处的幽灵单元填充为来自其他盒子的有效单元数据。:cpp:`MultiFab::FillBoundary`"
"还可以选择性地填充周期性边界的幽灵单元。"

#: ../../source/Basics.rst:2472 5e968dd70810499c8829c5a33f784139
msgid ""
"A coarse/fine boundary is the border between two AMR levels. :cpp:`FillBoundary` does not fill these ghost cells. These "
"ghost cells on the fine level need to be interpolated from the coarse level data.  This is a subject that will be "
"discussed in the section on :ref:`sec:amrcore:fillpatch`."
msgstr "粗/细边界是两个AMR层之间的边界。:cpp:`FillBoundary`不会填充这些虚拟单元。细层上的这些虚拟单元需要从粗层数据进行插值。这是一个将在:ref:`sec:amrcore:fillpatch`章节中讨论的主题。"

#: ../../source/Basics.rst:2477 7966c5de83dc4519be2708f30d01e3a0
msgid ""
"Note that periodic boundary is not considered a basic type in the discussion here because after periodic transformation "
"it becomes either interior boundary or coarse/fine boundary."
msgstr "请注意，在这里讨论中，周期边界不被视为基本类型，因为经过周期性转换后，它会变成内部边界或粗/细边界之一。"

#: ../../source/Basics.rst:2481 f2c8758a68e34b5fb05161d1008585bf
msgid ""
"The third type of boundary is the physical boundary at the physical domain. Note that both coarse and fine AMR levels "
"could have grids touching the physical boundary. It is up to the application codes to properly fill the ghost cells at "
"the physical boundary. However, AMReX does provide support for some common operations.  See the section on "
":ref:`sec:basics:boundary` for a discussion on domain boundary conditions in general, including how to implement "
"physical (non-periodic) boundary conditions."
msgstr ""
"第三种边界是物理域的物理边界。请注意，粗粒度和细粒度的 AMR 层级都可能与物理边界接触。如何正确填充物理边界上的幽灵单元是应用程序代码的责任。然而，AMReX 提供了一些常见操作的支持。请参阅 "
":ref:`sec:basics:boundary` 部分，了解关于域边界条件的讨论，包括如何实现物理（非周期性）边界条件。"

#: ../../source/Basics.rst:2492 88e09ba7045643d69d080621c647effd
msgid "Boundary Conditions"
msgstr "边界条件"

#: ../../source/Basics.rst:2494 61fd4cf0c74b4d57ab1e099fe0c8f5d4
msgid ""
"This section describes how to implement domain boundary conditions in AMReX.  A ghost cell that is outside of the valid "
"region can be thought of as either \"interior\" (which includes periodic and coarse-fine ghost cells), or \"physical\". "
"Physical boundary conditions can occur on domain boundaries and can be characterized as inflow, outflow, slip/no-slip "
"walls, etc., and are ultimately linked to mathematical Dirichlet or Neumann conditions."
msgstr ""
"本节描述了如何在AMReX中实现域边界条件。位于有效区域之外的幽灵单元可以被视为“内部”（包括周期性和粗细幽灵单元）或“物理”单元。物理边界条件可以出现在域边界上，并且可以被描述为流入、流出、滑移/"
"非滑移壁等，最终与数学上的迪里切特或诺依曼条件相关联。"

#: ../../source/Basics.rst:2501 8313a507797f45f9809b055449fd1fff
msgid "The basic idea behind physical boundary conditions is as follows:"
msgstr "物理边界条件的基本思想如下："

#: ../../source/Basics.rst:2503 915511f392ec4c319a0f368ecc209f28
msgid ""
"Create a :cpp:`BCRec` object, which is essentially a multidimensional integer array of :cpp:`2*DIM` components. Each "
"component defines a boundary condition type for the lo/hi side of the domain, for each direction.  See "
"``amrex/Src/Base/AMReX_BC_TYPES.H`` for common physical and mathematical types.  Below is an example of setting up a "
":cpp:`Vector<BCRec>` for multiple components before the call to ghost cell routines."
msgstr ""
"创建一个 `BCRec` 对象，它实质上是一个具有 `2*DIM` 个分量的多维整数数组。每个分量为每个方向上的域的低/高边界条件类型。请参考 `amrex/Src/Base/AMReX_BC_TYPES.H` "
"中的常见物理和数学类型。下面是在调用幽灵单元例程之前设置多个分量的 `Vector<BCRec>` 的示例。"

#: ../../source/Basics.rst:2533 45bcb815523f4cf9bb101a1b475a7ee2
msgid ":cpp:`amrex::BCType` has the following types,"
msgstr ":cpp:`amrex::BCType`有以下类型："

#: ../../source/Basics.rst:2536 e0f84b4c1d3c4f7d9dd5c91782b0b17e
msgid "int_dir"
msgstr "int_dir (内部目录)"

#: ../../source/Basics.rst:2536 ce6f96082100458daef5f8762f787136
msgid "Interior, including periodic boundary"
msgstr "内部，包括周期边界"

#: ../../source/Basics.rst:2542 834285d44c334842b5d8a9c6d9e33219
msgid "ext_dir"
msgstr "扩展目录"

#: ../../source/Basics.rst:2539 b85bc934034a45d6ac5bb09170852a08
msgid ""
"\"External Dirichlet\". It is the user's responsibility to write a routine to fill ghost cells (more details below). "
"The boundary location is on the domain face even when the data inside the domain are cell-centered."
msgstr "\"外部迪利克雷\"。用户有责任编写一个例程来填充幽灵单元（更多细节见下文）。即使域内的数据是以单元为中心，边界位置也位于域面上。"

#: ../../source/Basics.rst:2547 8796ef1e77d24c1799cb5adbff76f645
msgid "ext_dir_cc"
msgstr "扩展目录 CC"

#: ../../source/Basics.rst:2545 dc2b7d26f47f4701a3091f39b013dfa4
msgid ""
"\"External Dirichlet\". It is the user's responsibility to write a routine to fill ghost cells (more details below). "
"The boundary location is at the cell center of ghost cells outside the domain."
msgstr "\"外部迪利克雷\"。用户有责任编写一个例程来填充幽灵单元（更多细节见下文）。边界位置位于域外幽灵单元的单元中心。"

#: ../../source/Basics.rst:2551 e379a2125ce14cc98914d5fd8c44e1dd
msgid "foextrap"
msgstr "抱歉，我无法理解您的消息 \"foextrap\" 的含义。请提供更多上下文或者重新表达您的意思，以便我能够帮助您进行翻译。"

#: ../../source/Basics.rst:2550 be009e7ef8484984b071f0ac68fd35be
msgid "\"First Order Extrapolation\" First order extrapolation from last cell in interior."
msgstr "\"一阶外推\" 从内部最后一个单元格进行一阶外推。"

#: ../../source/Basics.rst:2555 d5a35ecf21b4438db563aa98c1fbfa82
msgid "hoextrap"
msgstr "抱歉，我无法理解您的消息 \"hoextrap\" 的含义。请提供更多上下文或者重新表达您的意思，以便我能够帮助您进行翻译。"

#: ../../source/Basics.rst:2554 841f00238349405b94071aac03629b06
msgid ""
"\"High Order Extrapolation\". The boundary location is on the domain face even when the data inside the domain are "
"cell-centered."
msgstr "\"高阶外推法\"。即使在域内的数据是以单元为中心，边界位置仍位于域面上。"

#: ../../source/Basics.rst:2559 cabc1f030167466580b69c7e406dc15a
msgid "hoextrapcc"
msgstr "抱歉，我无法理解您的消息 \"hoextrapcc\" 的含义。请提供更多上下文或明确您想要翻译的内容。"

#: ../../source/Basics.rst:2558 4ebaf2a5d77848be89fb57546296ec70
msgid "\"High Order Extrapolation\" The boundary location is at the cell center of ghost cells outside the domain."
msgstr "\"高阶外推\" 边界位置位于域外幽灵单元的单元中心。"

#: ../../source/Basics.rst:2563 55475af6911a449d82a2f62c6ca8429d
msgid "reflect_even"
msgstr "反映偶数"

#: ../../source/Basics.rst:2562 840125bda2674fa098fb298cf4f8d6be
msgid "Reflection from interior cells with sign unchanged, :math:`q(-i) = q(i)`."
msgstr "内部单元的反射，符号保持不变，:math:`q(-i) = q(i)`。"

#: ../../source/Basics.rst:2567 0aa4c9d2778d45a58ccbcf1786a2fc04
msgid "reflect_odd"
msgstr "反映奇数"

#: ../../source/Basics.rst:2566 a085f61517154806993c6187893d301c
msgid "Reflection from interior cells with sign changed, :math:`q(-i) = -q(i)`."
msgstr "内部细胞的反射，符号改变：:math:`q(-i) = -q(i)`。"

#: ../../source/Basics.rst:2571 200d18210d574ab09af1ea1cb8d80460
msgid "user_1, user_2 and user_3"
msgstr "用户_1，用户_2和用户_3"

#: ../../source/Basics.rst:2570 6712ed3d91404cb199cf299ebe582513
msgid "\"User\".  It is the user's responsibility to write a routine to fill ghost cells (more details below)."
msgstr "\"User\". It is the user's responsibility to write a routine to fill ghost cells (more details below)."

#: ../../source/Basics.rst:2573 37580d30ce9c4c288f296544bc6242d6
msgid "For external Dirichlet and user boundaries, the user needs to provide a callable object like below."
msgstr "对于外部迪利克雷和用户边界，用户需要提供一个可调用对象，如下所示。"

#: ../../source/Basics.rst:2592 0b56d36f304441c888839a2322a32adf
msgid ""
"Here, for the CPU build, the AMREX_GPU_DEVICE macro has no effect whatsoever, whereas for the GPU build, this marks the "
"operator as a GPU device function."
msgstr "在这里，对于 CPU 构建，AMREX_GPU_DEVICE 宏没有任何作用，而对于 GPU 构建，它将操作符标记为 GPU 设备函数。"

#: ../../source/Basics.rst:2596 57aeaa7cc139490e8866539520fce7bd
msgid ""
"It is the user's responsibility to have a consistent definition of what the ghost cells represent. A common option used "
"in AMReX codes is to fill the domain ghost cells with the value that lies on the boundary (as opposed to another common "
"option where the value in the ghost cell represents an extrapolated value based on the boundary condition type). Then "
"in our stencil based \"work\" codes, we also pass in the :cpp:`BCRec` object and use modified stencils near the domain "
"boundary that know the value in the first ghost cell represents the value on the boundary."
msgstr ""
"用户有责任对幽灵单元的含义进行一致的定义。在AMReX代码中常用的一种选项是将域的幽灵单元填充为边界上的值（而不是另一种常见选项，其中幽灵单元的值表示基于边界条件类型的外推值）。然后在我们基于模板的“工作”代码中，我们还传递了:cpp:`"
"BCRec`对象，并在靠近域边界的修改模板中使用，这些模板知道第一个幽灵单元中的值表示边界上的值。"

#: ../../source/Basics.rst:2605 764330da43c840048cb7a0d0ac429063
msgid "Depending on the level of complexity of your code, there are various options for filling domain boundary ghost cells."
msgstr "根据您的代码复杂程度，填充域边界的幽灵单元有多种选择。"

#: ../../source/Basics.rst:2608 50092724bddc44fe8cbdeda9b127e257
msgid ""
"For single-level codes built from ``amrex/Src/Base`` (excluding the ``amrex/Src/AmrCore`` and ``amrex/Src/Amr`` source "
"code directories), you will have single-level MultiFabs filled with data in the valid region where you need to fill the "
"ghost cells on each grid."
msgstr "对于从“amrex/Src/Base”构建的单层代码（不包括“amrex/Src/AmrCore”和“amrex/Src/Amr”源代码目录），您将拥有填充了有效区域数据的单层MultiFab，在每个网格上需要填充幽灵单元。"

#: ../../source/Basics.rst:2636 9ac4afbdcfda4f3ba4c45915edb0eefd
msgid "Masks"
msgstr "口罩"

#: ../../source/Basics.rst:2638 0d9d42945d52498d820a92d28e90b49f
msgid ""
"Given an index :cpp:`(i,j,k)`, we often need to know its relationship with other points and levels (e.g., whether this "
"point on a coarse level is covered by a fine level, whether this ghost point is outside coarse/fine boundary, etc.).  "
"AMReX provides various functions for creating masks for this type of purposes."
msgstr "给定一个索引 `(i,j,k)`，我们经常需要了解它与其他点和层级的关系（例如，这个粗粒度层级上的点是否被细粒度层级覆盖，这个幽灵点是否在粗粒度/细粒度边界之外等）。AMReX 提供了各种用于创建此类目的掩码的函数。"

#: ../../source/Basics.rst:2645 e1ce808a4b3e4012953d7cb8f473b9a0
msgid "Owner Mask"
msgstr "所有者面具"

#: ../../source/Basics.rst:2647 85ee4ac3de1c4543aa87fd5c0e0225de
msgid ""
"AMReX supports various index types such as face, edge and node, besides cell centered type.  For non-cell types, two "
"boxes could overlap.  For example, a nodal index :cpp:`(i,j,k)` could exist in more than one :cpp:`FArrayBox` of a "
"nodal :cpp:`MultiFab`.  AMReX provides a function to create an owner mask, where the owner is the grid with the lowest "
"grid number containing the data. This has a number of use cases.  The nodal data for the same nodal point on different "
":cpp:`FArrayBox`\\ es may be out of sync.  We can use :cpp:`MultiFab::OverrideSync` and an owner mask to sync up the "
"data with owners overriding non-owners."
msgstr ""
"AMReX支持各种索引类型，如面、边和节点，除了以单元为中心的类型。对于非单元类型，两个框可能会重叠。例如，一个节点索引 `（i，j，k）` 可能存在于一个节点 `MultiFab` 的多个 `FArrayBox` "
"中。AMReX提供了一个函数来创建所有者掩码，其中所有者是包含数据的最低网格编号的网格。这有许多用途。不同 `FArrayBox` 上的相同节点点的节点数据可能不同步。我们可以使用 `MultiFab::OverrideSync` "
"和所有者掩码来同步数据，使所有者覆盖非所有者。"

#: ../../source/Basics.rst:2665 e65432baec7b43e6a1b0b516e85c6d54
msgid "To compute the dot product of two nodal :cpp:`MultiFab`\\ s, we can use a mask to avoid double counting."
msgstr "计算两个节点 :cpp:`MultiFab` 的点积时，我们可以使用掩码来避免重复计数。"

#: ../../source/Basics.rst:2678 e361fda7499346e8b78453f6fdd44653
msgid "Overlap Mask"
msgstr "重叠掩码"

#: ../../source/Basics.rst:2680 f5b548a3ec0345e899d5d03e96d1629a
msgid ""
"For the synchronization example mentioned previously, maybe instead of overriding, we want to do averaging.  This can "
"be achieved with an overlap mask indicating how many duplicates are in each point.  The code below shows how the "
":cpp:`MultiFab::AverageSync` function is implemented in AMReX."
msgstr "对于先前提到的同步示例，也许我们不想使用覆盖，而是想要进行平均。这可以通过使用一个重叠掩码来实现，该掩码指示每个点中有多少个重复项。下面的代码展示了在AMReX中如何实现:cpp:`MultiFab::AverageSync`函数。"

#: ../../source/Basics.rst:2695 6522de88a9994ac2a703b14aa729a53d
msgid "Point Mask"
msgstr "点掩码"

#: ../../source/Basics.rst:2697 0d65580ed14b4083a751b2eabddbab7e
msgid ""
"The :cpp:`FabArray` class has a member function :cpp:`BuildMask` that can be used to set masks indicating the type of "
"points (e.g., valid, outside the domain, etc.).  For example,"
msgstr "`FabArray`类有一个成员函数`BuildMask`，可以用来设置指示点类型的掩码（例如，有效点、域外点等）。例如，"

#: ../../source/Basics.rst:2713 6517357046af4bbfb17ed8e29a79df27
msgid "Fine Mask"
msgstr "好的，口罩。"

#: ../../source/Basics.rst:2715 2d6708cfdbb848dfb2de0afd6666559d
msgid ""
"AMReX provides a number of :cpp:`makeFineMask` functions that can be useful for multi-level AMR calculations.  For "
"example, we may want to compute the infinity norm on a coarse AMR level without including data from cells covered by "
"fine level grids."
msgstr "AMReX提供了许多`makeFineMask`函数，对于多层自适应网格计算非常有用。例如，我们可能希望在粗糙的自适应网格层上计算无穷范数，而不包括被细网格覆盖的单元格中的数据。"

#: ../../source/Basics.rst:2731 9f601bf4f7fc4d1785ca784cf5510c42
msgid "Memory Allocation"
msgstr "内存分配"

#: ../../source/Basics.rst:2733 8db72747c3f041d4b20296989f3dbaed
msgid ""
"Some constructors of :cpp:`MultiFab`, :cpp:`FArrayBox`, etc. can take an :cpp:`Arena` argument for memory allocation.  "
"This is usually not important for CPU codes, but very important for GPU codes.  We will present more details in "
":ref:`sec:gpu:memory` in Chapter GPU."
msgstr ""
"一些构造函数，如：cpp:`MultiFab`、cpp:`FArrayBox`等，可以接受一个cpp:`Arena`参数用于内存分配。对于CPU代码来说，这通常不是很重要，但对于GPU代码来说非常重要。我们将在第GPU章节的:ref:`"
"sec:gpu:memory`中详细介绍。"

#: ../../source/Basics.rst:2738 3cd2ab149fbe404eb8ebdd01dc8e7920
msgid ""
"AMReX has a Fortran module, :fortran:`amrex_mempool_module` that can be used to allocate memory for Fortran pointers. "
"The reason that such a module exists in AMReX is that memory allocation is often very slow in multi-threaded OpenMP "
"parallel regions. AMReX :cpp:`amrex_mempool_module` provides a much faster alternative approach, in which each thread "
"has its own memory pool. Here are examples of using the module."
msgstr ""
"AMReX拥有一个Fortran模块，即`amrex_mempool_module`，可用于为Fortran指针分配内存。AMReX存在这样一个模块的原因是，在多线程OpenMP并行区域中，内存分配通常非常缓慢。AMReX的`amrex_"
"mempool_module`提供了一种更快的替代方法，其中每个线程都有自己的内存池。以下是使用该模块的示例。"

#: ../../source/Basics.rst:2761 622611833bea4e82948d8eacb827085b
msgid ""
"The downside of this is we have to use :fortran:`pointer` instead of :fortran:`allocatable`. This means we must "
"explicitly free the memory via :fortran:`amrex_deallocate` and we need to declare the pointers as :fortran:`contiguous` "
"for performance reason.  Also, we often pass the Fortran pointer to a procedure with explicit array argument to get rid "
"of the pointerness completely."
msgstr ""
"这种方法的缺点是我们必须使用 `:fortran:`pointer` ` 来替代 `:fortran:`allocatable` `。这意味着我们必须通过 `:fortran:`amrex_deallocate` "
"`显式释放内存，并且出于性能原因，我们需要将指针声明为 `:fortran:`contiguous` `。此外，我们经常将Fortran指针传递给具有显式数组参数的过程，以完全消除指针的存在。"

#: ../../source/Basics.rst:2769 bc9aa06a8e504c458a44fca034ce7941
msgid "Abort, Assertion and Backtrace"
msgstr "中止，断言和回溯"

#: ../../source/Basics.rst:2771 0ec870b119264fd3860a9c98ba35a2c6
msgid ""
":cpp:`amrex::Abort(const char * message)` is used to terminate a run usually when something goes wrong. This function "
"takes a message and writes it to stderr. Files named like ``Backtrace.1`` (where 1 means process 1) are produced "
"containing backtrace information of the call stack. In Fortran, we can call :fortran:`amrex_abort` from the "
":fortran:`amrex_error_module`, which takes a Fortran character variable with assumed size (i.e., :fortran:`len=*`) as a "
"message.  A ``ParmParse`` runtime boolean parameter ``amrex.throw_handling`` (which is defaulted to 0, i.e., "
":cpp:`false`) can be set to 1 (i.e., :cpp:`true`) so that AMReX will throw an exception instead of aborting."
msgstr ""
":cpp:`amrex::Abort(const char * message)` 用于在运行出现问题时终止程序。该函数接受一个消息并将其写入 stderr。生成的文件名类似于 ``Backtrace.1``（其中 1 表示进程 "
"1），其中包含调用堆栈的回溯信息。在 Fortran 中，我们可以从 :fortran:`amrex_error_module` 调用 :fortran:`amrex_abort`，它接受一个 Fortran "
"字符变量作为消息，其大小被假定为可变（即 :fortran:`len=*`）。``ParmParse`` 运行时布尔参数 ``amrex.throw_handling``（默认为 0，即 :cpp:`false`）可以设置为 1（即 "
":cpp:`true`），这样 AMReX 将抛出异常而不是终止程序。"

#: ../../source/Basics.rst:2782 70da781b7dd24519aac829dddd76362d
msgid ""
":cpp:`AMREX_ASSERT` is a macro that takes a Boolean expression. For debug build (e.g., ``DEBUG=TRUE`` using the GNU "
"Make build system), if the expression at runtime is evaluated to false, :cpp:`amrex::Abort` will be called and the run "
"is thus terminated. For optimized build (e.g., ``DEBUG=FALSE`` using the GNU Make build system), the "
":cpp:`AMREX_ASSERT` statement is removed at compile time and thus has no effect at runtime. We often use this as a "
"means of putting debug statement in the code without adding any extra cost for production runs. For example,"
msgstr ""
"`AMREX_ASSERT`是一个宏，接受一个布尔表达式作为参数。在调试构建中（例如，使用GNU "
"Make构建系统时设置``DEBUG=TRUE``），如果运行时表达式的结果为false，将调用:cpp:`amrex::Abort`函数终止运行。在优化构建中（例如，使用GNU "
"Make构建系统时设置``DEBUG=FALSE``），编译时会移除:cpp:`AMREX_ASSERT`语句，因此在运行时不会产生任何影响。我们经常使用这种方式在代码中添加调试语句，而不会增加生产运行的额外成本。例如，"

#: ../../source/Basics.rst:2797 933b9cfc892340f5a53983cdb830c75d
msgid ""
"Here for debug build we like to assert that :cpp:`MultiFab mf` has ghost cells and it also has the same number of "
"components as :cpp:`MultiFab mf2`. If we always want the assertion, we can use :cpp:`AMREX_ALWAYS_ASSERT`.  The "
"assertion macros have a ``_WITH_MESSAGE`` variant that will print a message when assertion fails.  For example,"
msgstr ""
"在调试构建中，我们希望断言：cpp:`MultiFab mf`具有幽灵单元，并且它的组件数量与cpp:`MultiFab "
"mf2`相同。如果我们始终希望进行断言，可以使用cpp:`AMREX_ALWAYS_ASSERT`。断言宏有一个“_WITH_MESSAGE”变体，当断言失败时会打印一条消息。例如，"

#: ../../source/Basics.rst:2811 8ebbf4f913044395bf5aed9a81abd55d
msgid ""
"Backtrace files are produced by AMReX signal handler by default when segfault occurs or ``Abort`` is called.  If the "
"application does not want AMReX to handle this, ``ParmParse`` parameter `amrex.signal_handling=0` can be used to "
"disable it."
msgstr "默认情况下，当发生段错误或调用“Abort”时，AMReX信号处理程序会生成回溯文件。如果应用程序不希望AMReX处理此类情况，可以使用“ParmParse”参数`amrex.signal_handling=0`来禁用它。"

#: ../../source/Basics.rst:2816 1536ddce40944e13ad568df679e3a294
msgid "See :ref:`sec:gpu:assertion` for considerations on using these functions in GPU-enabled code."
msgstr "请参阅:ref:`sec:gpu:assertion`，了解在启用GPU的代码中使用这些函数的注意事项。"
