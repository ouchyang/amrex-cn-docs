# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/Faq.rst:5 7d03489fe3a44ba085d82d8119fb626c
msgid "Frequently Asked Questions"
msgstr ""

#: ../../source/Faq.rst:8 e73fd021bb374b12b3833d5eebd59fd4
msgid "**Q.** Why am I getting a segmentation fault after my code runs?"
msgstr ""

#: ../../source/Faq.rst:10 cccca2c059a24f608da4c81458088af4
msgid ""
"**A.** Do you have :cpp:`amrex::Initialize(); {` and :cpp:`} "
"amrex::Finalize();` at the beginning and end of your code? For all AMReX "
"commands to function properly, including to release resources, they need "
"to be contained between these two curly braces or in a separate function."
" In the `Initialize and Finalize`_ section, these commands are discussed "
"further detail."
msgstr ""

#: ../../source/Faq.rst:20 8ce1fddd574f4d76a2165bef548259b4
msgid ""
"**Q.** I want to use a different compiler with GNU Make to compile AMReX."
" How do I do this?"
msgstr ""

#: ../../source/Faq.rst:22 7abc8b758fa443b4a0569e679088e739
msgid ""
"**A.** In the file ``amrex/Tools/GNUMake/Make.local`` you can specify "
"your own compile commands by setting the variables ``CXX``, ``CC``, "
"``FC``, and ``F90``. An example can be found at `Specifying your own "
"compiler`_ . Additional customizations are described in the file, "
"``amrex/Tools/GNUMake/Make.local.template``. In the same directory, "
"``amrex/Tools/GNUMake/README.md`` contains detailed information on "
"compiler commands."
msgstr ""

#: ../../source/Faq.rst:33 a1043aca6a3d47678cd7ca29d27ef548
msgid "**Q.** I'm having trouble compiling my code."
msgstr ""

#: ../../source/Faq.rst:35 db3755d462394ee0b568ee83398c716b
msgid ""
"**A.** AMReX developers have found that running the command ``make "
"clean`` can resolve many compilation issues."
msgstr ""

#: ../../source/Faq.rst:38 0e60212ae94e4ec1b0bd0599c0ff94e9
msgid ""
"If you are working in an environment that uses a module system, please "
"ensure you have the correct modules loaded. Typically, to do this, type "
"``module list`` at the command prompt."
msgstr ""

#: ../../source/Faq.rst:44 4e87040a5c524281bc6dd65b4493430c
msgid ""
"**Q.** When I profile my code that uses GPUs with ``TINY_PROFILE=TRUE`` "
"or ``PROFILE=TRUE`` my timings are inconsistent."
msgstr ""

#: ../../source/Faq.rst:47 2475d8a6ace54f32bced2c9f2971886c
msgid ""
"**A.** Due to the asynchronous nature of GPU execution, profilers might "
"only measure the run time on CPU, if there is no explicit "
"synchronization.  For ``TINY_PROFILE``, one could use :cpp:`ParmParse` "
"parameter ``tiny_profiler.device_synchronize_around_region=1`` to add "
"synchronization. Note that this may degrade performance."
msgstr ""

#: ../../source/Faq.rst:55 faad8d3bcaa145feab2536b5bf0ad136
msgid "**Q.** How do I know I am getting the right answer?"
msgstr ""

#: ../../source/Faq.rst:57 1aa691536d88480fb84d19266485a2f9
msgid ""
"**A.** AMReX provides support for verifying output with several tools. To"
" briefly mention a few:"
msgstr ""

#: ../../source/Faq.rst:59 c4c39609e4684f47acec5edfae711a92
msgid ""
"The :cpp:`print_state` function can be used to output the data of a "
"single cell."
msgstr ""

#: ../../source/Faq.rst:60 1eed16b05adb4c15af80c98ef9ec2e70
msgid ""
":cpp:`VisMF::Write` can be used to write MultiFab data to disk that can "
"be viewed with `Amrvis`_."
msgstr ""

#: ../../source/Faq.rst:61 df24f4530a3644d2820146a61375966e
msgid ""
":cpp:`amrex::Print()` and :cpp:`amrex::AllPrint()` are useful for "
"printing output when using multiple processes or threads as it prevents "
"messages from getting mixed up."
msgstr ""

#: ../../source/Faq.rst:64 603fa682159d46ebb0aae50403c04226
msgid ""
"`fcompare`_ compares two plotfiles and reports absolute and relative "
"error."
msgstr ""

#: ../../source/Faq.rst:66 759927bc6b224e0eb14a3c1adc9316b6
msgid ""
"Additional tools and discussion on this topic is contained in the section"
" `Debugging`_."
msgstr ""

#: ../../source/Faq.rst:77 a6855e0fa0f442e2977414643e421c18
msgid ""
"**Q.** What's the difference between :cpp:`Copy` and :cpp:`ParallelCopy` "
"for :cpp:`MultiFab` data?"
msgstr ""

#: ../../source/Faq.rst:80 2dd5ab701e58468383783d22e3678a4f
msgid ""
"**A.** :cpp:`MultiFab::Copy` is for two :cpp:`MultiFab`\\ s built with "
"the same :cpp:`BoxArray` and :cpp:`DistributionMapping`, whereas "
":cpp:`ParallelCopy` is for parallel communication of two "
":cpp:`MultiFab`\\ s with different :cpp:`BoxArray` and/or "
":cpp:`DistributionMapping`."
msgstr ""

#: ../../source/Faq.rst:87 099a411b691e4d288c4ced170ccf4822
msgid "**Q.** How do I fill ghost cells?"
msgstr ""

#: ../../source/Faq.rst:89 12e7022d37ad44fcaebd2f235b02f1f2
msgid "**A.** See `Ghost Cells`_ in the AMReX Source Documentation."
msgstr ""

#: ../../source/Faq.rst:95 f62bf81d60c44a49a62c12fc3de494b1
msgid ""
"**Q.** What's the difference between ``AmrCore`` and ``AmrLevel``? How do"
" I decide which to use?"
msgstr ""

#: ../../source/Faq.rst:98 adb583abe9c3425a9bf537dc52e68b89
msgid ""
"**A.** The :cpp:`AmrLevel` class is an abstract base class that holds "
"data for a single AMR level.  A vector of :cpp:`AmrLevel` is stored in "
"the :cpp:`Amr` class, which is derived from :cpp:`AmrCore`.  An "
"application code can derive from :cpp:`AmrLevel` and override functions."
"  :cpp:`AmrCore` contains the meta-data for the AMR hierarchy, but it "
"does not contain any floating point mesh data.  Instead of using "
":cpp:`Amr`/:cpp:`AmrLevel`, an application can also derive from "
":cpp:`AmrCore`.  If you want flexibility, you might choose the "
":cpp:`AmrCore` approach, otherwise the :cpp:`AmrLevel` approach might be "
"easier because it already has a lot of built-in capabilities that are "
"common for AMR applications."
msgstr ""

#: ../../source/Faq.rst:111 2a945b1888b94f2c8baed95e551afa4c
msgid ""
"**Q.** For GPU usage, how can I perform explicit host to device and "
"device to host copies without relying on managed memory?"
msgstr ""

#: ../../source/Faq.rst:114 4afe56f7ee264749a93bbc447695b5b7
msgid ""
"**A.** Use ``The_Pinned_Arena()`` (See `Memory Allocation`_ in the AMReX "
"Source Documentation.) and"
msgstr ""

#: ../../source/Faq.rst:128 224f253033894f2b9a3ee354e837c591
msgid ""
"**Q.** How do I generate random numbers with AMReX? Can I set the seed? "
"Are they thread safe with MPI and OpenMP?"
msgstr ""

#: ../../source/Faq.rst:131 f351f299766c41bab9ba46667456f8b4
msgid ""
"**A.** (Thread safe) Yes, :cpp:`amrex::Random()` is thread safe. When "
"OpenMP is on, each thread will have its own dedicated Random Number "
"Generator that is totally independent of the others."
msgstr ""

#: ../../source/Faq.rst:137 512e8e0ccad245d690e228f0bc508298
msgid ""
"**Q.** Is Dirichlet boundary condition data loaded into cell-centered, or"
" face-centered containers? How is it used in AMReX-based codes like MLMG "
"and the advection routines in AMReX-Hydro?"
msgstr ""

#: ../../source/Faq.rst:141 ef54cd70e3684fd9a1490b061cd02431
msgid ""
"**A.** In the cell-centered MLMG solver, the Dirichlet boundary data are "
"stored in containers that have the information of the location of the "
"data."
msgstr ""

#: ../../source/Faq.rst:146 94fecbbd1279411b9168106e92dac41f
msgid ""
"**Q.** How does coarse-grained OpenMP parallelism work in AMReX? How is "
"it different from the fine-grained approach?"
msgstr ""

#: ../../source/Faq.rst:149 01f488695cfe4335864f94e5ead2a66a
msgid ""
"**A.** Our OpenMP strategy is explained in this paper, "
"https://arxiv.org/abs/1604.03570."
msgstr ""

#: ../../source/Faq.rst:153 f121d643e4324645ba37596e6ce028a0
msgid ""
"**Q.** How to avoid running into :cpp:`Formal parameter space overflowed`"
" CUDA error while building complex EB geometries using AMReX implicit "
"functions and CSG functionalities ?"
msgstr ""

#: ../../source/Faq.rst:156 fac5170feb424c37a8d3931a25ca4ab3
msgid ""
"**A.** AMReX enables logical operations and transformations to assemble "
"basic shapes `Implicit Functions`_ into complex geometries. Each "
"operation results in a more complex type which can eventually overflow "
"the parameter space (4096 bytes on CUDA 11.4 for instance). To circumvent"
" the problem, explicitly copy the object to the device and pass a device "
"pointer function object `DevicePtrIF` into the `EB2` function using:"
msgstr ""

#: ../../source/Faq.rst:176 87def4ff26254dbf86537c16938e343b
msgid "More Questions"
msgstr ""

#: ../../source/Faq.rst:178 659f8917f89b40db8723e60d2b25397a
msgid ""
"If your question was not addressed here, you are encouraged to search and"
" ask for help on the `AMReX GitHub Discussions`_ page."
msgstr ""

