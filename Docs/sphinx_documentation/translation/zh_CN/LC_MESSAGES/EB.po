# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/EB.rst:10 51f685a3b3944ed884e443c110b4f36c
msgid "Initializing the Geometric Database"
msgstr ""

#: ../../source/EB.rst:12 21e1074c949448878fb4a22729c28a9c
msgid ""
"In AMReX geometric information is stored in a distributed database class "
"that must be initialized at the start of the calculation. The procedure "
"for this goes as follows:"
msgstr ""

#: ../../source/EB.rst:16 dbc230475d494daa8f79ac165c3b83b9
msgid ""
"Define an implicit function of position which describes the surface of "
"the embedded object. Specifically, the function class must have a public "
"member function that takes a position and returns a negative value if "
"that position is inside the fluid, a positive value in the body, and "
"identically zero at the embedded boundary."
msgstr ""

#: ../../source/EB.rst:28 de7b833a0eb2463fb0dc15b7b7e2cbb3
msgid "Make a :cpp:`EB2::GeometryShop` object using the implicit function."
msgstr ""

#: ../../source/EB.rst:30 989657236dff412094fe8c955e8de3e5
msgid ""
"Build an :cpp:`EB2::IndexSpace` with the :cpp:`EB2::GeometryShop` object "
"and a :cpp:`Geometry` object that contains the information about the "
"domain and the mesh."
msgstr ""

#: ../../source/EB.rst:34 1124ade034a24274b37dcc9328ed0aa4
msgid ""
"Here is a simple example of initialize the database for an embedded "
"sphere."
msgstr ""

#: ../../source/EB.rst:50 138e5d06ccc6438ea60e6cd0958a50c5
msgid ""
"Alternatively, the EB information can be initialized from an STL file "
"specified by a :cpp:`ParmParse` parameter ``eb2.stl_file``.  The "
"initialization is done by calling"
msgstr ""

#: ../../source/EB.rst:64 c432051a65cd40ad953be5c6fac47126
msgid ""
"Additionally one can use ``eb2.stl_scale``, ``eb2.stl_center`` and "
"``eb2.stl_reverse_normal`` to scale, translate and reverse the object, "
"respectively."
msgstr ""

#: ../../source/EB.rst:71 28417fe3b56347158c6803d43a39ad0e
msgid "Implicit Function"
msgstr ""

#: ../../source/EB.rst:73 6f66c0c58efe42d5a0e1ee14d606c58d
msgid ""
"In ``amrex/Src/EB/``, there are a number of predefined implicit function "
"classes for basic shapes. One can use these directly or as template for "
"their own classes."
msgstr ""

#: ../../source/EB.rst:77 3d595e1090304d56b542160a1e6cdb18
msgid ":cpp:`AllRegularIF`:  No embedded boundaries at all."
msgstr ""

#: ../../source/EB.rst:79 2b10e196eb054a82bb52bfd4346c0542
msgid ":cpp:`BoxIF`: Box."
msgstr ""

#: ../../source/EB.rst:81 54369537864643988addd943520a1c82
msgid ":cpp:`CylinderIF`: Cylinder."
msgstr ""

#: ../../source/EB.rst:83 7a346eddf7f44db38f6fe91e1582ecb6
msgid ":cpp:`EllipsoidIF`: Ellipsoid."
msgstr ""

#: ../../source/EB.rst:85 510b3238804648b2b7f300dee8857c9a
msgid ":cpp:`PlaneIF`: Half-space plane."
msgstr ""

#: ../../source/EB.rst:87 9822db206b4643d484078b4f2ba5cf68
msgid ":cpp:`SphereIF`: Sphere."
msgstr ""

#: ../../source/EB.rst:89 7156091bd5d54667943362c109133d8f
msgid ""
"AMReX also provides a number of transformation operations to apply to an "
"object."
msgstr ""

#: ../../source/EB.rst:91 d6c1f3b8803d4383a64b783bc553f0c8
msgid ""
":cpp:`makeComplement`: Complement of an object. E.g. a sphere with fluid "
"on outside becomes a sphere with fluid inside."
msgstr ""

#: ../../source/EB.rst:94 32e46a6042c14c589041145f9ab0f527
msgid ":cpp:`makeIntersection`: Intersection of two or more objects."
msgstr ""

#: ../../source/EB.rst:96 e0d1cc184fd349608bec5765226653c2
msgid ":cpp:`makeUnion`: Union of two or more objects."
msgstr ""

#: ../../source/EB.rst:98 30482759b73b4609b32a17b2681523c4
msgid ":cpp:`Translate`: Translates an object."
msgstr ""

#: ../../source/EB.rst:100 b2c4daf366514610887a50047a183736
msgid ":cpp:`scale`: Scales an object."
msgstr ""

#: ../../source/EB.rst:102 982bfb29ef284b848b8c28165939cd9f
msgid ":cpp:`rotate`: Rotates an object."
msgstr ""

#: ../../source/EB.rst:104 095718e69ec04a7a883d44c5a7d67b13
msgid ""
":cpp:`lathe`: Creates a surface of revolution by rotating a 2D object "
"around an axis."
msgstr ""

#: ../../source/EB.rst:106 7b89f29718b940de8a774ca5c2d1a5f8
msgid "Here are some examples of using these functions."
msgstr ""

#: ../../source/EB.rst:130 ac697a0fa1524fdd8f79710eb8248697
msgid ":cpp:`EB2::GeometryShop`"
msgstr ""

#: ../../source/EB.rst:132 c09bbbfec52a4df6964c8237d304528b
msgid ""
"Given an implicit function object, say :cpp:`f`, we can make a "
":cpp:`GeometryShop` object with"
msgstr ""

#: ../../source/EB.rst:142 0acc45673dff40248d017150dfd09084
msgid ":cpp:`EB2::IndexSpace`"
msgstr ""

#: ../../source/EB.rst:144 7e705a5a40634e1b8b14925c7625f4e0
msgid "We build :cpp:`EB2::IndexSpace` with a template function"
msgstr ""

#: ../../source/EB.rst:156 90a8da5fdfb7467cb0c943177c14e67b
msgid ""
"Here the template parameter is a :cpp:`EB2::GeometryShop`. "
":cpp:`Geometry` (see section :ref:`sec:basics:geom`) describes the "
"rectangular problem domain and the mesh on the finest AMR level. Coarse "
"level EB data is generated from coarsening the original fine data. The "
":cpp:`int required_coarsening_level` parameter specifies the number of "
"coarsening levels required. This is usually set to :math:`N-1`, where "
":math:`N` is the total number of AMR levels. The :cpp:`int "
"max_coarsening_levels` parameter specifies the number of coarsening "
"levels AMReX should try to have. This is usually set to a big number, say"
" 20 if multigrid solvers are used. This essentially tells the build to "
"coarsen as much as it can. If there are no multigrid solvers, the "
"parameter should be set to the same as :cpp:`required_coarsening_level`. "
"It should be noted that coarsening could create multi-valued cells even "
"if the fine level does not have any multi-valued cells. This occurs when "
"the embedded boundary cuts a cell in such a way that there is fluid on "
"multiple sides of the boundary within that cell. Because multi-valued "
"cells are not supported, it will cause a runtime error if the required "
"coarsening level generates multi-valued cells. The optional :cpp:`int "
"ngrow` parameter specifies the number of ghost cells outside the domain "
"on required levels. For levels coarser than the required level, no EB "
"data are generated for ghost cells outside the domain."
msgstr ""

#: ../../source/EB.rst:176 9fe34cc462e346208f0eb998cabe6cb9
msgid ""
"The newly built :cpp:`EB2::IndexSpace` is pushed on to a stack. Static "
"function :cpp:`EB2::IndexSpace::top()` returns a :cpp:`const &` to the "
"new :cpp:`EB2::IndexSpace` object. We usually only need to build one "
":cpp:`EB2::IndexSpace` object. However, if your application needs "
"multiple :cpp:`EB2::IndexSpace` objects, you can save the pointers for "
"later use. For simplicity, we assume there is only one `EB2::IndexSpace` "
"object for the rest of this chapter."
msgstr ""

#: ../../source/EB.rst:185 f6de501a98624883bd53c106e34ef48e
msgid "EBFArrayBoxFactory"
msgstr ""

#: ../../source/EB.rst:187 4a361907467e43ed9ea99675f2dba02e
msgid ""
"After the EB database is initialized, the next thing we build is "
":cpp:`EBFArrayBoxFactory`. This object provides access to the EB database"
" in the format of basic AMReX objects such as :cpp:`BaseFab`, "
":cpp:`FArrayBox`, :cpp:`FabArray`, and :cpp:`MultiFab`. We can construct "
"it with"
msgstr ""

#: ../../source/EB.rst:202 f0c7fd2706b247329eb355efb59880f6
msgid "or"
msgstr ""

#: ../../source/EB.rst:215 a96aab00bc404c9faa4ea5fd71dab022
msgid ""
"Argument :cpp:`Vector<int> const& a_ngrow` specifies the number of ghost "
"cells we need for EB data at various :cpp:`EBSupport` levels, and "
"argument :cpp:`EBSupport a_support` specifies the level of support "
"needed."
msgstr ""

#: ../../source/EB.rst:220 049b81e803494aba89960e0b99220070
msgid ":cpp:`EBSupport:basic`:  basic flags for cell types"
msgstr ""

#: ../../source/EB.rst:221 7a04165591824757bba843323f23d936
msgid ":cpp:`EBSupport:volume`: basic plus volume fraction and centroid"
msgstr ""

#: ../../source/EB.rst:222 0712b0aa099941099483798458d06643
msgid ""
":cpp:`EBSupport:full`: volume plus area fraction, boundary centroid and "
"face centroid"
msgstr ""

#: ../../source/EB.rst:225 804b5e999924410cac86e9d490a517cd
msgid ""
":cpp:`EBFArrayBoxFactory` is derived from :cpp:`FabFactory<FArrayBox>`. "
":cpp:`MultiFab` constructors have an optional argument :cpp:`const "
"FabFactory<FArrayBox>&`.  We can use :cpp:`EBFArrayBoxFactory` to build "
":cpp:`MultiFab`\\ s that carry EB data.  Member function of "
":cpp:`FabArray`"
msgstr ""

#: ../../source/EB.rst:237 ba3f2a0fcc6f40e5a1688d30517bbbf5
msgid ""
"can then be used to return a reference to the :cpp:`EBFArrayBoxFactory` "
"used for building the :cpp:`MultiFab`. Using :cpp:`dynamic_cast`, we can "
"test whether a :cpp:`MultiFab` is built with an "
":cpp:`EBFArrayBoxFactory`."
msgstr ""

#: ../../source/EB.rst:253 1dd218e3c68e4dcc8ff48019eac5f600
msgid "Embedded Boundary Data"
msgstr ""

#: ../../source/EB.rst:255 38782495c3f741b2bf94e3152fc172b5
msgid ""
"Through member functions of :cpp:`EBFArrayBoxFactory`, we have access to "
"the following data:"
msgstr ""

#: ../../source/EB.rst:280 d2baf70574764f77aee3bdf8f59a56c0
msgid ""
"**Volume fraction** is in a single-component :cpp:`MultiFab`. Data are in"
" the range of :math:`[0,1]` with zero representing covered cells and one "
"for regular cells."
msgstr ""

#: ../../source/EB.rst:284 662a66c95a96411c85089bc60aae975d
msgid ""
"**Volume centroid** (also called cell centroid) is in a "
":cpp:`MultiCutFab` with ``AMREX_SPACEDIM`` components. Each component of "
"the data is in the range of :math:`[-0.5,0.5]`, based on each cell's "
"local coordinates with respect to the regular cell's center."
msgstr ""

#: ../../source/EB.rst:289 9deb9bfd909b46c98dda375519e35266
msgid ""
"**Boundary centroid** is also in a :cpp:`MultiCutFab` with "
"``AMREX_SPACEDIM`` components.  Each component of the data is in the "
"range of :math:`[-0.5,0.5]`, based on each cell's local coordinates with "
"respect to the regular cell's center."
msgstr ""

#: ../../source/EB.rst:294 97c64e39f32d427d85793a0ac43cfd0e
msgid ""
"**Face centroid** is in a :cpp:`MultiCutFab` with ``AMREX_SPACEDIM`` "
"components. Each component of the data is in the range of "
":math:`[-0.5,0.5]`, based on each cell's local coordinates with respect "
"to the embedded boundary."
msgstr ""

#: ../../source/EB.rst:298 e2c799e8952c4efe89907a6a981b899f
msgid ""
"**Area fractions** are returned in an :cpp:`Array` of :cpp:`MultiCutFab` "
"pointers. For each direction, area fraction is for the face of that "
"direction. Data are in the range of :math:`[0,1]` with zero representing "
"a covered face and one an un-cut face."
msgstr ""

#: ../../source/EB.rst:303 da0f50f0e906460db4e22a6028efdf9d
msgid ""
"**Face centroids** are returned in an :cpp:`Array` of :cpp:`MultiCutFab` "
"pointers. There are two components for each direction and the ordering is"
" always the same as the original ordering of the coordinates. For "
"example, for :math:`y` face, the component 0 is for :math:`x` coordinate "
"and 1 for :math:`z`. The coordinates are in each face's local frame "
"normalized to the range of :math:`[-0.5,0.5]`."
msgstr ""

#: ../../source/EB.rst:312 dbc2861b4ff84cf2ab3706a214e13ce8
msgid "Embedded Boundary Data Structures"
msgstr ""

#: ../../source/EB.rst:314 e166360a7ef14550af09519dc5e8e960
msgid ""
"A :cpp:`MultiCutFab` is very similar to a :cpp:`MultiFab`. Its data can "
"be accessed with subscript operator"
msgstr ""

#: ../../source/EB.rst:323 e1f245b8fc8f44d89d258701b1c0900e
msgid ""
"Here :cpp:`CutFab` is derived from :cpp:`FArrayBox` and can be passed to "
"Fortran just like :cpp:`FArrayBox`. The difference between "
":cpp:`MultiCutFab` and :cpp:`MultiFab` is that to save memory "
":cpp:`MultiCutFab` only has data on boxes that contain cut cells. It is "
"an error to call :cpp:`operator[]` if that box does not have cut cells. "
"Thus the call must be in a :cpp:`if` test block (see section "
":ref:`sec:EB:flag`)."
msgstr ""

#: ../../source/EB.rst:333 d19ccdfd99a44da0b55b267b4c285f27
msgid ":cpp:`EBCellFlagFab`"
msgstr ""

#: ../../source/EB.rst:335 00212537ab4c4461a2bddc040d6e5fe9
msgid ""
":cpp:`EBCellFlagFab` contains information on cell types.  We can use it "
"to determine if a box contains cut cells."
msgstr ""

#: ../../source/EB.rst:359 d8748aeddaa941358b9013d98750bd8a
msgid ""
":cpp:`EBCellFlagFab` is derived from :cpp:`BaseFab`. Its data are stored "
"in an array of 32-bit integers, and can be used in C++ or passed to "
"Fortran just like an :cpp:`IArrayBox` (section :ref:`sec:basics:fab`). "
"AMReX provides a Fortran module called ``amrex_ebcellflag_module``. This "
"module contains procedures for testing cell types and getting neighbor "
"information. For example"
msgstr ""

#: ../../source/EB.rst:390 1c78dc37e5b94817b4a9fe807f2974f8
msgid "Small Cell Problem and Redistribution"
msgstr ""

#: ../../source/EB.rst:392 245754aa5f22489fb14261c397cebe6e
msgid ""
"First, we review finite volume discretizations with embedded boundaries "
"as used by AMReX-based applications. Then we illustrate the small cell "
"problem."
msgstr ""

#: ../../source/EB.rst:396 3f5636f6b81f452986351f228dd53657
msgid "Finite Volume Discretizations"
msgstr ""

#: ../../source/EB.rst:398 7bb54c4845cb4872a350b478efe0fdb9
msgid ""
"Consider a system of PDEs to advance a conserved quantity :math:`U` with "
"fluxes :math:`F`:"
msgstr ""

#: ../../source/EB.rst:401 bc28d0d6509e41e8ad635698b7d084c0
msgid ""
"\\frac{\\partial U}{\\partial t} + \\nabla \\cdot F = 0.\n"
"\n"
msgstr ""

#: ../../source/EB.rst:404 9128389e230d40eebd0f2a3bebf371bb
msgid ""
"A conservative, finite volume discretization starts with the divergence "
"theorm"
msgstr ""

#: ../../source/EB.rst:406 c6909ea910454bf1887ab109de9676c1
msgid ""
"\\int_V \\nabla \\cdot F dV = \\int_{\\partial V} F \\cdot n dA.\n"
"\n"
msgstr ""

#: ../../source/EB.rst:408 b4564b48014d494cbaef734e9bea40e1
msgid ""
"In an embedded boundary cell, the \"conservative divergence\" is "
"discretized (as :math:`D^c(F)`) as follows"
msgstr ""

#: ../../source/EB.rst:411 214eacbfe29e4e8388601aedecce7900
msgid ""
" D^c(F) = \\frac{1}{\\kappa h} \\left( \\sum^D_{d = 1}\n"
"   (F_{d, \\mathrm{hi}} \\, \\alpha_{d, \\mathrm{hi}} - F_{d, "
"\\mathrm{lo}}\\, \\alpha_{d, \\mathrm{lo}})\n"
"   + F^{EB} \\alpha^{EB} \\right)."
msgstr ""

#: ../../source/EB.rst:418 3f6411cad0284a6fab2059353aeefce1
msgid ""
"Geometry is discretely represented by volumes (:math:`V = \\kappa h^d`) "
"and apertures (:math:`A= \\alpha h^{d-1}`), where :math:`h` is the "
"(uniform) mesh spacing at that AMR level, :math:`\\kappa` is the volume "
"fraction and :math:`\\alpha` are the area fractions. Without multivalued "
"cells the volume fractions, area fractions and cell and face centroids "
"(see :numref:`fig::volume`) are the only geometric information needed to "
"compute second-order fluxes centered at the face centroids, and to infer "
"the connectivity of the cells. Cells are connected if adjacent on the "
"Cartesian mesh, and only via coordinate-aligned faces on the mesh. If an "
"aperture, :math:`\\alpha = 0`, between two cells, they are not directly "
"connected to each other."
msgstr ""

#: ../../source/EB.rst:442 49b2fe45909a466c8cfa723d1520d500
msgid "Illustration of embedded boundary cutting a two-dimensional cell."
msgstr ""

#: ../../source/EB.rst:446 d26231c0298e48a396c7daad649e4d9f
msgid "|a|"
msgstr ""

#: ../../source/EB.rst:434 3ccf333e62e748719ad70d030ff62dd5
msgid "a"
msgstr ""

#: ../../source/EB.rst:446 a171dcf69d3e4650a665eb79b04bcbb6
msgid "|b|"
msgstr ""

#: ../../source/EB.rst:437 5caf6475e79c49bd81f0d6f9034b34f3
msgid "b"
msgstr ""

#: ../../source/EB.rst 710f09e45b4845b98c6be2bd7c748dc6
msgid "A typical two-dimensional uniform cell that is"
msgstr ""

#: ../../source/EB.rst 6e6a654004e641a8ba79116713bc8ed4
msgid "cut by the embedded boundary. The grey area"
msgstr ""

#: ../../source/EB.rst 557b5a97e0cf49afaca74b1730cb6cc7
msgid "represents the region excluded from the"
msgstr ""

#: ../../source/EB.rst d9c261fd67ef4fa097fa0a4b9a31105c
msgid "calculation. The portion of the cell faces"
msgstr ""

#: ../../source/EB.rst 36af5b5032024422890526484dd5442e
msgid "faces (labelled with A) through which fluxes"
msgstr ""

#: ../../source/EB.rst f5639dbade78406eadcad112f75a88ac
msgid "flow are the \"uncovered\" regions of the full"
msgstr ""

#: ../../source/EB.rst 64fbe6c94f7c45afb86ffda2f48d0d4b
msgid "cell faces. The volume (labelled V) is the"
msgstr ""

#: ../../source/EB.rst bc8ad109e3f84d8481406e4d90586b7b
msgid "uncovered region of the interior."
msgstr ""

#: ../../source/EB.rst 5f75c92f088c4ec383c94700a7ce8009
msgid "Fluxes in a cut cell."
msgstr ""

#: ../../source/EB.rst:464 f4e6a4bae7164298bf4afdd2622bc59f
msgid "Small Cells And Stability"
msgstr ""

#: ../../source/EB.rst:466 3fb893e993554d39941c2e2ea00ae9f5
msgid ""
"In the context of time-explicit advance methods for, say hyperbolic "
"conservation laws, a naive discretization in time of :eq:`eqn::hypsys` "
"using :eq:`eqn::ebdiv`,"
msgstr ""

#: ../../source/EB.rst:470 40cfb1b13ee84cb6b4d644f7cadd1ea5
msgid ""
"U^{n+1} = U^{n} - \\delta t D^c(F)\n"
"\n"
msgstr ""

#: ../../source/EB.rst:472 97f8c08e044a4b5a90da2895a9db2404
msgid ""
"would have a time step constraint :math:`\\delta t \\sim h "
"\\kappa^{1/D}/V_m`, which goes to zero as the size of the smallest volume"
" fraction :math:`\\kappa` in the calculation. Since EB volume fractions "
"can be arbitrarily small, this presents an unacceptable constraint. This "
"is the so-called \"small cell problem,\" and AMReX-based applications "
"address it with redistribution methods."
msgstr ""

#: ../../source/EB.rst:479 f324da2787b84d4a9b04be4394ed026d
msgid "Flux Redistribution"
msgstr ""

#: ../../source/EB.rst:481 50641072ca164b188651765f0205a9cd
msgid "Consider a conservative update in the form:"
msgstr ""

#: ../../source/EB.rst:483 4e6e777855324c50a92ec48684429bdc
msgid ""
"(\\rho \\phi)_t + \\nabla \\cdot ( \\rho \\phi u) = RHS\n"
"\n"
msgstr ""

#: ../../source/EB.rst:485 c921c5d0ab714566831987bcb210c66a
msgid ""
"For each valid cell in the domain, compute the conservative divergence, "
":math:`(\\nabla \\cdot F)^c` , of the convective fluxes, :math:`F`"
msgstr ""

#: ../../source/EB.rst:488 90a6bc80b1c04e9f8f30976b680f0d69
msgid ""
"(\\nabla \\cdot {F})^c_i = \\dfrac{1}{\\mathcal{V}_i} \\sum_{f=1}^{N_f} "
"({F}_f\\cdot{n}_f) A_f\n"
"\n"
msgstr ""

#: ../../source/EB.rst:490 1f68b23371c14dc5af40322a8480cd70
msgid ""
"Here :math:`N_f` is the number of faces of cell :math:`i`, "
":math:`\\vec{n}_f` and :math:`A_f` are the unit normal and area of the "
":math:`f` -th face respectively, and :math:`\\mathcal{V}_i` is the volume"
" of cell :math:`i` given by"
msgstr ""

#: ../../source/EB.rst:494 5f07dcc38fbb48f2b44a47742659e109
msgid ""
"\\mathcal{V}_i = (\\Delta x \\Delta y \\Delta z)\\cdot \\mathcal{K}_i\n"
"\n"
msgstr ""

#: ../../source/EB.rst:496 0718acc0cff64c018461c2a19887739a
msgid "where :math:`\\mathcal{K}_i` is the volume fraction of cell :math:`i` ."
msgstr ""

#: ../../source/EB.rst:498 6f6d4710a74749519754b18870ef4ca7
msgid "Now, a conservative update can be written as"
msgstr ""

#: ../../source/EB.rst:500 57979b6760484181a94396f9dd1ad47d
msgid ""
"\\frac{ \\rho^{n+1} \\phi^{n+1} - \\rho^{n} \\phi^{n} }{\\Delta t} = - "
"\\nabla \\cdot{F}^c\n"
"\n"
msgstr ""

#: ../../source/EB.rst:502 1d8f78cfee3f4c16bd2884e4eda86aa8
msgid ""
"For each cell cut by the EB geometry, compute the non-conservative "
"update, :math:`\\nabla \\cdot {F}^{nc}` ,"
msgstr ""

#: ../../source/EB.rst:504 6f7ed9ee7a064076afa38595cae94698
msgid ""
"\\nabla\\cdot{F}^{nc}_i = \\dfrac{\\sum\\limits_{j\\in N(i) } "
"\\mathcal{K}_j\\nabla \\cdot {F}^c_j} {\\sum\\limits_{j\\in N(i) } "
"{\\mathcal{K}}_j}\n"
"\n"
msgstr ""

#: ../../source/EB.rst:506 d5e4e49b33474a5b8203f9fcb7e78795
msgid "where :math:`N(i)` is the index set of cell :math:`i` and its neighbors."
msgstr ""

#: ../../source/EB.rst:508 7d224281b2c042fea163f4f46775e04d
msgid ""
"For each cell cut by the EB geometry, compute the convective update "
":math:`\\nabla \\cdot{F}^{EB}` follows:"
msgstr ""

#: ../../source/EB.rst:510 d8671f74c2654be691fc4aba6ec27f25
msgid ""
"\\nabla \\cdot{F}^{EB}_i = \\mathcal{K}_i\\nabla \\cdot{F}^{c}_i "
"+(1-\\mathcal{K}_i) \\nabla \\cdot \\mathcal{F}^{nc}_i\n"
"\n"
msgstr ""

#: ../../source/EB.rst:512 d238529f02764a91b6c69d945bdf4b68
msgid ""
"For each cell cut by the EB geometry, redistribute its mass loss, "
":math:`\\delta M_i` , to its neighbors:"
msgstr ""

#: ../../source/EB.rst:514 bcaf3b6cb611498b8172b9541a5385ff
msgid ""
"\\nabla \\cdot {F}^{EB}_j :=   \\nabla \\cdot {F}^{EB}_j + w_{ij}\\delta "
"M_i\\, \\qquad \\forall j\\in N(i)\\setminus i\n"
"\n"
msgstr ""

#: ../../source/EB.rst:516 1212152316df4e9485d4a6544d8fe081
msgid "where the mass loss in cell :math:`i` , :math:`\\delta M_i` , is given by"
msgstr ""

#: ../../source/EB.rst:518 82960a1fd3bc434b8dce8cef07004e30
msgid ""
"\\delta M_i =  \\mathcal{K}_i(1- \\mathcal{K}_i)[ \\nabla \\cdot {F}^c_i-"
"  \\nabla \\cdot {F}^{nc}_i]\n"
"\n"
msgstr ""

#: ../../source/EB.rst:520 bd899748b9b143faafe01e7c5f77524a
msgid "and the weights, :math:`w_{ij}` , are"
msgstr ""

#: ../../source/EB.rst:522 03d3840a34df4ed0bc856088f2149279
msgid ""
"w_{ij} = \\dfrac{1}{\\sum\\limits_{j\\in N(i)\\setminus i}  "
"\\mathcal{K}_j}\n"
"\n"
msgstr ""

#: ../../source/EB.rst:524 f8e3a759851942328cfe07543d795d4c
msgid ""
"Note that :math:`\\nabla \\cdot{F}_i^{EB}` gives an update for "
":math:`\\rho \\phi` ; i.e.,"
msgstr ""

#: ../../source/EB.rst:526 416ab09c1c9c4c7ebee3c9da10d64c4e
msgid ""
"\\frac{(\\rho \\phi_i)^{n+1} - (\\rho \\phi_i)^{n} }{\\Delta t} = - "
"\\nabla \\cdot{F}^{EB}_i\n"
"\n"
msgstr ""

#: ../../source/EB.rst:528 3e917e938f544c829c60d4b9aa558f56
msgid ""
"Typically, the redistribution neighborhood for each cell is one that can "
"be reached via a monotonic path in each coordinate direction of unit "
"length (see, e.g., :numref:`fig::redistribution`)"
msgstr ""

#: ../../source/EB.rst:541 a34358fab8ac404ca7c36b1f76ceb90a
msgid ""
": Redistribution illustration. Excess update distributed to neighbor "
"cells."
msgstr ""

#: ../../source/EB.rst:549 63f87334723d4184bcbd471b23341949
msgid "State Redistribution"
msgstr ""

#: ../../source/EB.rst:551 1ca1c8d93a56444f9bc6912ad1e9f188
msgid ""
"For state redistribution we implement the weighted state redistribution "
"algorithm as described in Guiliani et al (2021), which is available on "
"`arxiv  <https://arxiv.org/abs/2112.12360>`_ . This is an extension of "
"the original state redistribution algorithm of Berger and Guiliani "
"(2020)."
msgstr ""

#: ../../source/EB.rst:559 c4d45cb197664f3d81f46bf518de3177
msgid "Linear Solvers"
msgstr ""

#: ../../source/EB.rst:561 90dc58c2d23546b1aa3040abe10bcaf6
msgid ""
"Linear solvers for the canonical form (equation :eq:`eqn::abeclap`) have "
"been discussed in chapter :ref:`Chap:LinearSolvers`."
msgstr ""

#: ../../source/EB.rst:564 6bf188aebabf42bab569e5a34436d72f
msgid ""
"AMReX supports multi-level 1) cell-centered solvers with homogeneous "
"Neumann, homogeneous Dirichlet, or inhomogeneous Dirichlet boundary "
"conditions on the EB faces, and 2) nodal solvers with homogeneous Neumann"
" boundary conditions, or inflow velocity conditions on the EB faces."
msgstr ""

#: ../../source/EB.rst:570 82ea27d805f14ba8b181ecb080b41ecc
msgid ""
"To use a cell-centered solver with EB, one builds a linear operator "
":cpp:`MLEBABecLap` with :cpp:`EBFArrayBoxFactory` (instead of a "
":cpp:`MLABecLaplacian`)"
msgstr ""

#: ../../source/EB.rst:583 185134008184430b8db9f38c0fc9df06
msgid ""
"The usage of this EB-specific class is essentially the same as "
":cpp:`MLABecLaplacian`."
msgstr ""

#: ../../source/EB.rst:586 dfa568f9c25b499182db01b43f1adecd
msgid "The default boundary condition on EB faces is homogeneous Neumann."
msgstr ""

#: ../../source/EB.rst:588 11aae1dbdf8446d481fde2b7b58555ed
msgid "To set homogeneous Dirichlet boundary conditions, call"
msgstr ""

#: ../../source/EB.rst:596 ebce04adf19a48acb2570827e912dad1
msgid ""
"where coeff can be a real number (i.e. the value is the same at every "
"cell) or is the MultiFab holding the coefficient of the gradient at each "
"cell with an EB face."
msgstr ""

#: ../../source/EB.rst:599 ede12b19cb46457faa9cf9dda49471b5
msgid "To set inhomogeneous Dirichlet boundary conditions, call"
msgstr ""

#: ../../source/EB.rst:607 95f512d2a7114ca5924dbeae64ecef37
msgid ""
"where phi_on_eb is the MultiFab holding the Dirichlet values in every cut"
" cell, and coeff again is a real number (i.e. the value is the same at "
"every cell) or a MultiFab holding the coefficient of the gradient at each"
" cell with an EB face."
msgstr ""

#: ../../source/EB.rst:611 5139ec7908794717abb85a62e5b21c01
msgid ""
"Currently there are options to define the face-based coefficients on face"
" centers vs face centroids, and to interpret the solution variable as "
"being defined on cell centers vs cell centroids."
msgstr ""

#: ../../source/EB.rst:615 a384e80ee46f4283826886179d952cc2
msgid ""
"The default is for the solution variable to be defined at cell centers; "
"to tell the solver to interpret the solution variable as living at cell "
"centroids, you must set"
msgstr ""

#: ../../source/EB.rst:625 c8a1bf01670b45639fd978d54cd21715
msgid ""
"The default is for the face-based coefficients to be defined at face "
"centers; to tell the that the face-based coefficients should be "
"interpreted as living at face centroids, modify the setBCoeffs command to"
" be"
msgstr ""

#: ../../source/EB.rst:636 3e25fdc12d054bbfb7f3e40d04abaae8
msgid "Tutorials"
msgstr ""

#: ../../source/EB.rst:638 92e04fbebf34416c8a68b283cc219adf
msgid ""
"`EB/CNS`_ is an AMR code for solving compressible Navier-Stokes equations"
" with the embedded boundary approach."
msgstr ""

#: ../../source/EB.rst:641 2693e1dd3b08404d872850715783b0af
msgid ""
"`EB/Poisson`_ is a single-level code that is a proxy for solving the "
"electrostatic Poisson equation for a grounded sphere with a point charge "
"inside."
msgstr ""

#: ../../source/EB.rst:645 a2dc8f12e4464eaab0bd85a86b100b6f
msgid ""
"`EB/MacProj`_ is a single-level code that computes a divergence-free flow"
" field around a sphere.  A MAC projection is performed on an initial "
"velocity field of (1,0,0)."
msgstr ""

