# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/EB.rst:10 51f685a3b3944ed884e443c110b4f36c
msgid "Initializing the Geometric Database"
msgstr "正在初始化几何数据库。"

#: ../../source/EB.rst:12 21e1074c949448878fb4a22729c28a9c
msgid ""
"In AMReX geometric information is stored in a distributed database class that must be initialized at the start of the "
"calculation. The procedure for this goes as follows:"
msgstr "在 AMReX 中，几何信息存储在一个分布式数据库类中，必须在计算开始时进行初始化。其初始化过程如下："

#: ../../source/EB.rst:16 dbc230475d494daa8f79ac165c3b83b9
msgid ""
"Define an implicit function of position which describes the surface of the embedded object. Specifically, the function "
"class must have a public member function that takes a position and returns a negative value if that position is inside "
"the fluid, a positive value in the body, and identically zero at the embedded boundary."
msgstr "请定义一个隐函数，描述嵌入物体的表面。具体而言，该函数类必须具有一个公共成员函数，该函数接受一个位置作为参数，并在该位置在流体内部时返回负值，在物体内部时返回正值，并在嵌入边界处返回零值。"

#: ../../source/EB.rst:28 de7b833a0eb2463fb0dc15b7b7e2cbb3
msgid "Make a :cpp:`EB2::GeometryShop` object using the implicit function."
msgstr "使用隐式函数创建一个 `EB2::GeometryShop` 对象。"

#: ../../source/EB.rst:30 989657236dff412094fe8c955e8de3e5
msgid ""
"Build an :cpp:`EB2::IndexSpace` with the :cpp:`EB2::GeometryShop` object and a :cpp:`Geometry` object that contains the "
"information about the domain and the mesh."
msgstr "使用 `EB2::GeometryShop` 对象和包含有关域和网格信息的 `Geometry` 对象构建一个 `EB2::IndexSpace`。"

#: ../../source/EB.rst:34 1124ade034a24274b37dcc9328ed0aa4
msgid "Here is a simple example of initialize the database for an embedded sphere."
msgstr "这是一个简单的示例，用于初始化嵌入式数据库中的球体。"

#: ../../source/EB.rst:50 138e5d06ccc6438ea60e6cd0958a50c5
msgid ""
"Alternatively, the EB information can be initialized from an STL file specified by a :cpp:`ParmParse` parameter "
"``eb2.stl_file``.  The initialization is done by calling"
msgstr "另外，EB信息也可以从由``ParmParse``参数``eb2.stl_file``指定的STL文件进行初始化。通过调用以下方法进行初始化："

#: ../../source/EB.rst:64 c432051a65cd40ad953be5c6fac47126
msgid ""
"Additionally one can use ``eb2.stl_scale``, ``eb2.stl_center`` and ``eb2.stl_reverse_normal`` to scale, translate and "
"reverse the object, respectively."
msgstr "此外，可以使用``eb2.stl_scale``、``eb2.stl_center``和``eb2.stl_reverse_normal``来分别对对象进行缩放、平移和反转操作。"

#: ../../source/EB.rst:71 28417fe3b56347158c6803d43a39ad0e
msgid "Implicit Function"
msgstr "隐函数"

#: ../../source/EB.rst:73 6f66c0c58efe42d5a0e1ee14d606c58d
msgid ""
"In ``amrex/Src/EB/``, there are a number of predefined implicit function classes for basic shapes. One can use these "
"directly or as template for their own classes."
msgstr "在 ``amrex/Src/EB/`` 目录下，有许多预定义的隐式函数类用于基本形状。可以直接使用这些类，或者将它们作为模板来创建自己的类。"

#: ../../source/EB.rst:77 3d595e1090304d56b542160a1e6cdb18
msgid ":cpp:`AllRegularIF`:  No embedded boundaries at all."
msgstr ":cpp:`AllRegularIF`: 没有任何嵌入边界。"

#: ../../source/EB.rst:79 2b10e196eb054a82bb52bfd4346c0542
msgid ":cpp:`BoxIF`: Box."
msgstr ":cpp:`BoxIF`: 盒子。"

#: ../../source/EB.rst:81 54369537864643988addd943520a1c82
msgid ":cpp:`CylinderIF`: Cylinder."
msgstr ":cpp:`CylinderIF`: 圆柱体。"

#: ../../source/EB.rst:83 7a346eddf7f44db38f6fe91e1582ecb6
msgid ":cpp:`EllipsoidIF`: Ellipsoid."
msgstr ":cpp:`EllipsoidIF`: 椭球体。"

#: ../../source/EB.rst:85 510b3238804648b2b7f300dee8857c9a
msgid ":cpp:`PlaneIF`: Half-space plane."
msgstr ":cpp:`PlaneIF`: 半空间平面。"

#: ../../source/EB.rst:87 9822db206b4643d484078b4f2ba5cf68
msgid ":cpp:`SphereIF`: Sphere."
msgstr ":cpp:`SphereIF`: 球体。"

#: ../../source/EB.rst:89 7156091bd5d54667943362c109133d8f
msgid "AMReX also provides a number of transformation operations to apply to an object."
msgstr "AMReX还提供了许多可以应用于对象的转换操作。"

#: ../../source/EB.rst:91 d6c1f3b8803d4383a64b783bc553f0c8
msgid ":cpp:`makeComplement`: Complement of an object. E.g. a sphere with fluid on outside becomes a sphere with fluid inside."
msgstr ":cpp:`makeComplement`: 对象的补集。例如，外部有流体的球体变成内部有流体的球体。"

#: ../../source/EB.rst:94 32e46a6042c14c589041145f9ab0f527
msgid ":cpp:`makeIntersection`: Intersection of two or more objects."
msgstr ":cpp:`makeIntersection`: 两个或多个对象的交集。"

#: ../../source/EB.rst:96 e0d1cc184fd349608bec5765226653c2
msgid ":cpp:`makeUnion`: Union of two or more objects."
msgstr ":cpp:`makeUnion`: 合并两个或多个对象。"

#: ../../source/EB.rst:98 30482759b73b4609b32a17b2681523c4
msgid ":cpp:`Translate`: Translates an object."
msgstr ":cpp:`Translate`: 翻译一个对象。"

#: ../../source/EB.rst:100 b2c4daf366514610887a50047a183736
msgid ":cpp:`scale`: Scales an object."
msgstr ":cpp:`scale`: 对一个对象进行缩放。"

#: ../../source/EB.rst:102 982bfb29ef284b848b8c28165939cd9f
msgid ":cpp:`rotate`: Rotates an object."
msgstr ":cpp:`rotate`: 旋转一个对象。"

#: ../../source/EB.rst:104 095718e69ec04a7a883d44c5a7d67b13
msgid ":cpp:`lathe`: Creates a surface of revolution by rotating a 2D object around an axis."
msgstr ":cpp:`车床`: 通过围绕轴线旋转二维物体来创建一个旋转曲面。"

#: ../../source/EB.rst:106 7b89f29718b940de8a774ca5c2d1a5f8
msgid "Here are some examples of using these functions."
msgstr "这里是使用这些函数的一些示例。"

#: ../../source/EB.rst:130 ac697a0fa1524fdd8f79710eb8248697
msgid ":cpp:`EB2::GeometryShop`"
msgstr ":cpp:`EB2::GeometryShop`"

#: ../../source/EB.rst:132 c09bbbfec52a4df6964c8237d304528b
msgid "Given an implicit function object, say :cpp:`f`, we can make a :cpp:`GeometryShop` object with"
msgstr "给定一个隐式函数对象，比如 `f`，我们可以使用它来创建一个 `GeometryShop` 对象。"

#: ../../source/EB.rst:142 0acc45673dff40248d017150dfd09084
msgid ":cpp:`EB2::IndexSpace`"
msgstr ":cpp:`EB2::IndexSpace`"

#: ../../source/EB.rst:144 7e705a5a40634e1b8b14925c7625f4e0
msgid "We build :cpp:`EB2::IndexSpace` with a template function"
msgstr "我们使用一个模板函数来构建 `EB2::IndexSpace`。"

#: ../../source/EB.rst:156 90a8da5fdfb7467cb0c943177c14e67b
msgid ""
"Here the template parameter is a :cpp:`EB2::GeometryShop`. :cpp:`Geometry` (see section :ref:`sec:basics:geom`) "
"describes the rectangular problem domain and the mesh on the finest AMR level. Coarse level EB data is generated from "
"coarsening the original fine data. The :cpp:`int required_coarsening_level` parameter specifies the number of "
"coarsening levels required. This is usually set to :math:`N-1`, where :math:`N` is the total number of AMR levels. The "
":cpp:`int max_coarsening_levels` parameter specifies the number of coarsening levels AMReX should try to have. This is "
"usually set to a big number, say 20 if multigrid solvers are used. This essentially tells the build to coarsen as much "
"as it can. If there are no multigrid solvers, the parameter should be set to the same as "
":cpp:`required_coarsening_level`. It should be noted that coarsening could create multi-valued cells even if the fine "
"level does not have any multi-valued cells. This occurs when the embedded boundary cuts a cell in such a way that there "
"is fluid on multiple sides of the boundary within that cell. Because multi-valued cells are not supported, it will "
"cause a runtime error if the required coarsening level generates multi-valued cells. The optional :cpp:`int ngrow` "
"parameter specifies the number of ghost cells outside the domain on required levels. For levels coarser than the "
"required level, no EB data are generated for ghost cells outside the domain."
msgstr ""
"在这里，模板参数是一个 `EB2::GeometryShop`。`Geometry`（参见第 `sec:basics:geom` 节）描述了矩形问题域和最精细的 AMR 层上的网格。粗糙级别的 EB "
"数据是通过对原始精细数据进行粗化生成的。`int required_coarsening_level` 参数指定所需的粗化级别数。通常将其设置为 :math:`N-1`，其中 :math:`N` 是总的 AMR 级别数。`int "
"max_coarsening_levels` 参数指定 AMReX 应尽量拥有的粗化级别数。如果使用多重网格求解器，通常将其设置为一个较大的数，比如 20。这基本上告诉构建系统尽可能多地进行粗化。如果没有多重网格求解器，则该参数应设置为与 "
"`required_coarsening_level` "
"相同。需要注意的是，即使精细级别没有多值单元，粗化也可能创建多值单元。当嵌入边界以某种方式切割单元时，在该单元内边界的多个侧面上存在流体。由于不支持多值单元，如果所需的粗化级别生成多值单元，将会导致运行时错误。可选的 `int "
"ngrow` 参数指定所需级别域外的幽灵单元数。对于比所需级别更粗的级别，不会为域外的幽灵单元生成 EB 数据。"

#: ../../source/EB.rst:176 9fe34cc462e346208f0eb998cabe6cb9
msgid ""
"The newly built :cpp:`EB2::IndexSpace` is pushed on to a stack. Static function :cpp:`EB2::IndexSpace::top()` returns a "
":cpp:`const &` to the new :cpp:`EB2::IndexSpace` object. We usually only need to build one :cpp:`EB2::IndexSpace` "
"object. However, if your application needs multiple :cpp:`EB2::IndexSpace` objects, you can save the pointers for later "
"use. For simplicity, we assume there is only one `EB2::IndexSpace` object for the rest of this chapter."
msgstr ""
"新建的 `EB2::IndexSpace` 被推入堆栈。静态函数 `EB2::IndexSpace::top()` 返回一个对新的 `EB2::IndexSpace` 对象的 `const &` 引用。通常我们只需要构建一个 "
"`EB2::IndexSpace` 对象。然而，如果您的应用程序需要多个 `EB2::IndexSpace` 对象，您可以保存指针以供以后使用。为简单起见，我们假设在本章的其余部分只有一个 `EB2::IndexSpace` 对象。"

#: ../../source/EB.rst:185 f6de501a98624883bd53c106e34ef48e
msgid "EBFArrayBoxFactory"
msgstr "EBFArrayBoxFactory"

#: ../../source/EB.rst:187 4a361907467e43ed9ea99675f2dba02e
msgid ""
"After the EB database is initialized, the next thing we build is :cpp:`EBFArrayBoxFactory`. This object provides access "
"to the EB database in the format of basic AMReX objects such as :cpp:`BaseFab`, :cpp:`FArrayBox`, :cpp:`FabArray`, and "
":cpp:`MultiFab`. We can construct it with"
msgstr ""
"在EB数据库初始化完成后，我们接下来要构建的是：cpp:`EBFArrayBoxFactory`。这个对象以基本的AMReX对象（如cpp:`BaseFab`、cpp:`FArrayBox`、cpp:`FabArray`和cpp:`"
"MultiFab`）的格式提供对EB数据库的访问。我们可以使用以下方式构建它："

#: ../../source/EB.rst:202 f0c7fd2706b247329eb355efb59880f6
msgid "or"
msgstr "或者"

#: ../../source/EB.rst:215 a96aab00bc404c9faa4ea5fd71dab022
msgid ""
"Argument :cpp:`Vector<int> const& a_ngrow` specifies the number of ghost cells we need for EB data at various "
":cpp:`EBSupport` levels, and argument :cpp:`EBSupport a_support` specifies the level of support needed."
msgstr ""
"参数 `cpp:Vector<int> const& a_ngrow` 指定了在不同的 `cpp:EBSupport` 级别下，我们需要为 EB 数据预留的幽灵单元数量。而参数 `cpp:EBSupport a_support` "
"则指定了所需的支持级别。"

#: ../../source/EB.rst:220 049b81e803494aba89960e0b99220070
msgid ":cpp:`EBSupport:basic`:  basic flags for cell types"
msgstr ":cpp:`EBSupport:basic`: 单元类型的基本标志"

#: ../../source/EB.rst:221 7a04165591824757bba843323f23d936
msgid ":cpp:`EBSupport:volume`: basic plus volume fraction and centroid"
msgstr ":cpp:`EBSupport:volume`: 基本加体积分数和质心"

#: ../../source/EB.rst:222 0712b0aa099941099483798458d06643
msgid ":cpp:`EBSupport:full`: volume plus area fraction, boundary centroid and face centroid"
msgstr ":cpp:`EBSupport:full`: 体积加面积分数，边界质心和面质心"

#: ../../source/EB.rst:225 804b5e999924410cac86e9d490a517cd
msgid ""
":cpp:`EBFArrayBoxFactory` is derived from :cpp:`FabFactory<FArrayBox>`. :cpp:`MultiFab` constructors have an optional "
"argument :cpp:`const FabFactory<FArrayBox>&`.  We can use :cpp:`EBFArrayBoxFactory` to build :cpp:`MultiFab`\\ s that "
"carry EB data.  Member function of :cpp:`FabArray`"
msgstr ""
"`EBFArrayBoxFactory`是从`FabFactory<FArrayBox>`派生而来的。`MultiFab`的构造函数有一个可选参数`const "
"FabFactory<FArrayBox>&`。我们可以使用`EBFArrayBoxFactory`来构建携带EB数据的`MultiFab`。这是`FabArray`的成员函数。"

#: ../../source/EB.rst:237 ba3f2a0fcc6f40e5a1688d30517bbbf5
msgid ""
"can then be used to return a reference to the :cpp:`EBFArrayBoxFactory` used for building the :cpp:`MultiFab`. Using "
":cpp:`dynamic_cast`, we can test whether a :cpp:`MultiFab` is built with an :cpp:`EBFArrayBoxFactory`."
msgstr "可以用来返回对用于构建MultiFab的EBFArrayBoxFactory的引用。使用dynamic_cast，我们可以测试一个MultiFab是否是使用EBFArrayBoxFactory构建的。"

#: ../../source/EB.rst:253 1dd218e3c68e4dcc8ff48019eac5f600
msgid "Embedded Boundary Data"
msgstr "嵌入边界数据"

#: ../../source/EB.rst:255 38782495c3f741b2bf94e3152fc172b5
msgid "Through member functions of :cpp:`EBFArrayBoxFactory`, we have access to the following data:"
msgstr "通过 :cpp:`EBFArrayBoxFactory` 的成员函数，我们可以访问以下数据："

#: ../../source/EB.rst:280 d2baf70574764f77aee3bdf8f59a56c0
msgid ""
"**Volume fraction** is in a single-component :cpp:`MultiFab`. Data are in the range of :math:`[0,1]` with zero "
"representing covered cells and one for regular cells."
msgstr "在单组分的 `MultiFab` 中，**体积分数**表示数据的范围在 [0,1] 之间，其中零表示被覆盖的单元格，而一表示常规单元格。"

#: ../../source/EB.rst:284 662a66c95a96411c85089bc60aae975d
msgid ""
"**Volume centroid** (also called cell centroid) is in a :cpp:`MultiCutFab` with ``AMREX_SPACEDIM`` components. Each "
"component of the data is in the range of :math:`[-0.5,0.5]`, based on each cell's local coordinates with respect to the "
"regular cell's center."
msgstr "**体积质心**（也称为单元质心）位于具有``AMREX_SPACEDIM``个分量的:cpp:`MultiCutFab`中。数据的每个分量都在范围:math:`[-0.5,0.5]`内，基于每个单元相对于规则单元中心的局部坐标。"

#: ../../source/EB.rst:289 9deb9bfd909b46c98dda375519e35266
msgid ""
"**Boundary centroid** is also in a :cpp:`MultiCutFab` with ``AMREX_SPACEDIM`` components.  Each component of the data "
"is in the range of :math:`[-0.5,0.5]`, based on each cell's local coordinates with respect to the regular cell's center."
msgstr ""
"**Boundary centroid** 也位于具有 ``AMREX_SPACEDIM`` 维度的 :cpp:`MultiCutFab` 中。数据的每个分量都在 :math:`[-0.5,0.5]` "
"的范围内，基于每个单元格相对于规则单元格中心的局部坐标。"

#: ../../source/EB.rst:294 97c64e39f32d427d85793a0ac43cfd0e
msgid ""
"**Face centroid** is in a :cpp:`MultiCutFab` with ``AMREX_SPACEDIM`` components. Each component of the data is in the "
"range of :math:`[-0.5,0.5]`, based on each cell's local coordinates with respect to the embedded boundary."
msgstr "**面心**位于具有``AMREX_SPACEDIM``个组件的:cpp:`MultiCutFab`中。数据的每个组件都在范围:math:`[-0.5,0.5]`内，基于每个单元格相对于嵌入边界的局部坐标。"

#: ../../source/EB.rst:298 e2c799e8952c4efe89907a6a981b899f
msgid ""
"**Area fractions** are returned in an :cpp:`Array` of :cpp:`MultiCutFab` pointers. For each direction, area fraction is "
"for the face of that direction. Data are in the range of :math:`[0,1]` with zero representing a covered face and one an "
"un-cut face."
msgstr "**面积分数**以 :cpp:`MultiCutFab` 指针的 :cpp:`Array` 形式返回。对于每个方向，面积分数表示该方向的面。数据范围在 :math:`[0,1]` 之间，其中零表示被覆盖的面，而一表示未切割的面。"

#: ../../source/EB.rst:303 da0f50f0e906460db4e22a6028efdf9d
msgid ""
"**Face centroids** are returned in an :cpp:`Array` of :cpp:`MultiCutFab` pointers. There are two components for each "
"direction and the ordering is always the same as the original ordering of the coordinates. For example, for :math:`y` "
"face, the component 0 is for :math:`x` coordinate and 1 for :math:`z`. The coordinates are in each face's local frame "
"normalized to the range of :math:`[-0.5,0.5]`."
msgstr ""
"**面心点**以一个 `Array` 的 `MultiCutFab` 指针返回。每个方向都有两个分量，其顺序与坐标的原始顺序始终相同。例如，对于 `y` 面，分量 0 对应于 `x` 坐标，分量 1 对应于 `z` "
"坐标。这些坐标在每个面的局部坐标系中归一化到范围 `[-0.5, 0.5]`。"

#: ../../source/EB.rst:312 dbc2861b4ff84cf2ab3706a214e13ce8
msgid "Embedded Boundary Data Structures"
msgstr "嵌入式边界数据结构"

#: ../../source/EB.rst:314 e166360a7ef14550af09519dc5e8e960
msgid "A :cpp:`MultiCutFab` is very similar to a :cpp:`MultiFab`. Its data can be accessed with subscript operator"
msgstr "一个 `MultiCutFab` 类非常类似于一个 `MultiFab` 类。它的数据可以通过下标操作符进行访问。"

#: ../../source/EB.rst:323 e1f245b8fc8f44d89d258701b1c0900e
msgid ""
"Here :cpp:`CutFab` is derived from :cpp:`FArrayBox` and can be passed to Fortran just like :cpp:`FArrayBox`. The "
"difference between :cpp:`MultiCutFab` and :cpp:`MultiFab` is that to save memory :cpp:`MultiCutFab` only has data on "
"boxes that contain cut cells. It is an error to call :cpp:`operator[]` if that box does not have cut cells. Thus the "
"call must be in a :cpp:`if` test block (see section :ref:`sec:EB:flag`)."
msgstr ""
"这里，`CutFab` 是从 `FArrayBox` 派生而来的，可以像 `FArrayBox` 一样传递给 Fortran。`MultiCutFab` 和 `MultiFab` 的区别在于为了节省内存，`MultiCutFab` "
"只在包含切割单元的盒子上存储数据。如果该盒子没有切割单元，则调用 `operator[]` 是错误的。因此，该调用必须位于一个 `if` 测试块中（参见第 :ref:`sec:EB:flag` 节）。"

#: ../../source/EB.rst:333 d19ccdfd99a44da0b55b267b4c285f27
msgid ":cpp:`EBCellFlagFab`"
msgstr ":cpp:`EBCellFlagFab`"

#: ../../source/EB.rst:335 00212537ab4c4461a2bddc040d6e5fe9
msgid ":cpp:`EBCellFlagFab` contains information on cell types.  We can use it to determine if a box contains cut cells."
msgstr "`EBCellFlagFab` 包含有关单元格类型的信息。我们可以使用它来确定一个盒子是否包含切割单元。"

#: ../../source/EB.rst:359 d8748aeddaa941358b9013d98750bd8a
msgid ""
":cpp:`EBCellFlagFab` is derived from :cpp:`BaseFab`. Its data are stored in an array of 32-bit integers, and can be "
"used in C++ or passed to Fortran just like an :cpp:`IArrayBox` (section :ref:`sec:basics:fab`). AMReX provides a "
"Fortran module called ``amrex_ebcellflag_module``. This module contains procedures for testing cell types and getting "
"neighbor information. For example"
msgstr ""
"`EBCellFlagFab`是从`BaseFab`派生而来的。它的数据存储在一个32位整数数组中，并且可以像`IArrayBox`一样在C++中使用或传递给Fortran（参见:ref:`sec:basics:fab`"
"节）。AMReX提供了一个名为`amrex_ebcellflag_module`的Fortran模块。该模块包含用于测试单元格类型和获取邻居信息的过程。例如，"

#: ../../source/EB.rst:390 1c78dc37e5b94817b4a9fe807f2974f8
msgid "Small Cell Problem and Redistribution"
msgstr "小区问题和重新分配"

#: ../../source/EB.rst:392 245754aa5f22489fb14261c397cebe6e
msgid ""
"First, we review finite volume discretizations with embedded boundaries as used by AMReX-based applications. Then we "
"illustrate the small cell problem."
msgstr "首先，我们回顾一下AMReX应用程序中使用的带嵌入边界的有限体积离散化方法。然后，我们将说明小单元问题。"

#: ../../source/EB.rst:396 3f5636f6b81f452986351f228dd53657
msgid "Finite Volume Discretizations"
msgstr "有限体积离散化方法"

#: ../../source/EB.rst:398 7bb54c4845cb4872a350b478efe0fdb9
msgid "Consider a system of PDEs to advance a conserved quantity :math:`U` with fluxes :math:`F`:"
msgstr "考虑一个用于推进守恒量 :math:`U` 的偏微分方程系统，其中包含了通量 :math:`F`。"

#: ../../source/EB.rst:401 bc28d0d6509e41e8ad635698b7d084c0
msgid ""
"\\frac{\\partial U}{\\partial t} + \\n"
"abla \\cdot F = 0.\n"
"\n"
msgstr ""
"\\frac{\\partial U}{\\partial t} + \\n"
"abla \\cdot F = 0."

#: ../../source/EB.rst:404 9128389e230d40eebd0f2a3bebf371bb
msgid "A conservative, finite volume discretization starts with the divergence theorm"
msgstr "一个保守的有限体积离散化从散度定理开始。"

#: ../../source/EB.rst:406 c6909ea910454bf1887ab109de9676c1
msgid ""
"\\int_V \\n"
"abla \\cdot F dV = \\int_{\\partial V} F \\cdot n dA.\n"
"\n"
msgstr "在体积V上的散度F的积分等于在V的边界上F与法向量n的点积的积分。"

#: ../../source/EB.rst:408 b4564b48014d494cbaef734e9bea40e1
msgid "In an embedded boundary cell, the \"conservative divergence\" is discretized (as :math:`D^c(F)`) as follows"
msgstr "在嵌入边界单元中，“保守散度”被离散化为 :math:`D^c(F)`，具体如下所示："

#: ../../source/EB.rst:411 214eacbfe29e4e8388601aedecce7900
msgid ""
" D^c(F) = \\frac{1}{\\kappa h} \\left( \\sum^D_{d = 1}\n"
"   (F_{d, \\mathrm{hi}} \\, \\alpha_{d, \\mathrm{hi}} - F_{d, \\mathrm{lo}}\\, \\alpha_{d, \\mathrm{lo}})\n"
"   + F^{EB} \\alpha^{EB} \\right)."
msgstr ""
"D^c(F) = \\frac{1}{\\kappa h} \\left( \\sum^D_{d = 1}\n"
"   (F_{d, \\mathrm{hi}} \\, \\alpha_{d, \\mathrm{hi}} - F_{d, \\mathrm{lo}}\\, \\alpha_{d, \\mathrm{lo}})\n"
"   + F^{EB} \\alpha^{EB} \\right)."

#: ../../source/EB.rst:418 3f6411cad0284a6fab2059353aeefce1
msgid ""
"Geometry is discretely represented by volumes (:math:`V = \\kappa h^d`) and apertures (:math:`A= \\alpha h^{d-1}`), "
"where :math:`h` is the (uniform) mesh spacing at that AMR level, :math:`\\kappa` is the volume fraction and "
":math:`\\alpha` are the area fractions. Without multivalued cells the volume fractions, area fractions and cell and "
"face centroids (see :numref:`fig::volume`) are the only geometric information needed to compute second-order fluxes "
"centered at the face centroids, and to infer the connectivity of the cells. Cells are connected if adjacent on the "
"Cartesian mesh, and only via coordinate-aligned faces on the mesh. If an aperture, :math:`\\alpha = 0`, between two "
"cells, they are not directly connected to each other."
msgstr ""
"几何形状通过体积（:math:`V = \\kappa h^d`）和孔隙（:math:`A= \\alpha h^{d-1}`）离散表示，其中 :math:`h` 是该自适应网格细化层级上的（均匀）网格间距，:math:`\\kappa` "
"是体积分数，:math:`\\alpha` 是面积分数。在没有多值单元的情况下，体积分数、面积分数以及单元和面心（参见 "
":numref:`fig::volume`）是计算以面心为中心的二阶通量和推断单元连接性所需的唯一几何信息。如果在笛卡尔网格上相邻，则单元通过坐标对齐的面连接。如果两个单元之间存在孔隙（:math:`\\alpha = "
"0`），则它们之间没有直接连接。"

#: ../../source/EB.rst:442 49b2fe45909a466c8cfa723d1520d500
msgid "Illustration of embedded boundary cutting a two-dimensional cell."
msgstr "嵌入边界切割二维单元的示意图。"

#: ../../source/EB.rst:446 d26231c0298e48a396c7daad649e4d9f
msgid "|a|"
msgstr "|a|"

#: ../../source/EB.rst:434 3ccf333e62e748719ad70d030ff62dd5
msgid "a"
msgstr "一个"

#: ../../source/EB.rst:446 a171dcf69d3e4650a665eb79b04bcbb6
msgid "|b|"
msgstr "|b|"

#: ../../source/EB.rst:437 5caf6475e79c49bd81f0d6f9034b34f3
msgid "b"
msgstr "b"

#: ../../source/EB.rst 710f09e45b4845b98c6be2bd7c748dc6
msgid "A typical two-dimensional uniform cell that is"
msgstr "一个典型的二维均匀单元，它是"

#: ../../source/EB.rst 6e6a654004e641a8ba79116713bc8ed4
msgid "cut by the embedded boundary. The grey area"
msgstr "被嵌入边界切割的部分。灰色区域。"

#: ../../source/EB.rst 557b5a97e0cf49afaca74b1730cb6cc7
msgid "represents the region excluded from the"
msgstr "代表被排除在外的地区"

#: ../../source/EB.rst d9c261fd67ef4fa097fa0a4b9a31105c
msgid "calculation. The portion of the cell faces"
msgstr "计算。细胞表面的部分。"

#: ../../source/EB.rst 36af5b5032024422890526484dd5442e
msgid "faces (labelled with A) through which fluxes"
msgstr "面（标记为A）通过其中的通量。"

#: ../../source/EB.rst f5639dbade78406eadcad112f75a88ac
msgid "flow are the \"uncovered\" regions of the full"
msgstr "这些是完整区域中的“未覆盖”部分。"

#: ../../source/EB.rst 64fbe6c94f7c45afb86ffda2f48d0d4b
msgid "cell faces. The volume (labelled V) is the"
msgstr "细胞表面。体积（标记为V）是"

#: ../../source/EB.rst bc8ad109e3f84d8481406e4d90586b7b
msgid "uncovered region of the interior."
msgstr "内部的未覆盖区域。"

#: ../../source/EB.rst 5f75c92f088c4ec383c94700a7ce8009
msgid "Fluxes in a cut cell."
msgstr "切割单元中的通量。"

#: ../../source/EB.rst:464 f4e6a4bae7164298bf4afdd2622bc59f
msgid "Small Cells And Stability"
msgstr "小型蜂窝基站和稳定性"

#: ../../source/EB.rst:466 3fb893e993554d39941c2e2ea00ae9f5
msgid ""
"In the context of time-explicit advance methods for, say hyperbolic conservation laws, a naive discretization in time "
"of :eq:`eqn::hypsys` using :eq:`eqn::ebdiv`,"
msgstr "在处理时间显式推进方法时，例如双曲守恒律，使用方程：eq:`eqn::hypsys`的时间离散化方法是朴素的，利用方程：eq:`eqn::ebdiv`进行离散化。"

#: ../../source/EB.rst:470 40cfb1b13ee84cb6b4d644f7cadd1ea5
msgid ""
"U^{n+1} = U^{n} - \\delta t D^c(F)\n"
"\n"
msgstr "U^{n+1} = U^{n} - \\delta t D^c(F)"

#: ../../source/EB.rst:472 97f8c08e044a4b5a90da2895a9db2404
msgid ""
"would have a time step constraint :math:`\\delta t \\sim h \\kappa^{1/D}/V_m`, which goes to zero as the size of the "
"smallest volume fraction :math:`\\kappa` in the calculation. Since EB volume fractions can be arbitrarily small, this "
"presents an unacceptable constraint. This is the so-called \"small cell problem,\" and AMReX-based applications address "
"it with redistribution methods."
msgstr ""
"在计算中，会有一个时间步长约束：math:`\\delta t \\sim h \\kappa^{1/D}/V_m`，其中 :math:`\\kappa` "
"是计算中最小体积分数的大小。随着EB体积分数可以任意小，这个约束是不可接受的。这就是所谓的“小单元问题”，而基于AMReX的应用程序通过重新分配方法来解决这个问题。"

#: ../../source/EB.rst:479 f324da2787b84d4a9b04be4394ed026d
msgid "Flux Redistribution"
msgstr "通量重新分配"

#: ../../source/EB.rst:481 50641072ca164b188651765f0205a9cd
msgid "Consider a conservative update in the form:"
msgstr "请考虑以保守方式进行更新，格式如下："

#: ../../source/EB.rst:483 4e6e777855324c50a92ec48684429bdc
msgid ""
"(\\rho \\phi)_t + \\n"
"abla \\cdot ( \\rho \\phi u) = RHS\n"
"\n"
msgstr "（ρφ）_t + ∇ · (ρφu) = RHS"

#: ../../source/EB.rst:485 c921c5d0ab714566831987bcb210c66a
msgid ""
"For each valid cell in the domain, compute the conservative divergence, :math:`(\\n"
"abla \\cdot F)^c` , of the convective fluxes, :math:`F`"
msgstr ""
"对于定义域中的每个有效单元格，计算传输通量的保守散度 :math:`(\\n"
"abla \\cdot F)^c`，其中 :math:`F` 是对流通量。"

#: ../../source/EB.rst:488 90a6bc80b1c04e9f8f30976b680f0d69
msgid ""
"(\\n"
"abla \\cdot {F})^c_i = \\dfrac{1}{\\mathcal{V}_i} \\sum_{f=1}^{N_f} ({F}_f\\cdot{n}_f) A_f\n"
"\n"
msgstr "（∇ · F）^c_i = 1/𝒱_i ∑_{f=1}^{N_f} (F_f · n_f) A_f"

#: ../../source/EB.rst:490 1f68b23371c14dc5af40322a8480cd70
msgid ""
"Here :math:`N_f` is the number of faces of cell :math:`i`, :math:`\\vec{n}_f` and :math:`A_f` are the unit normal and "
"area of the :math:`f` -th face respectively, and :math:`\\mathcal{V}_i` is the volume of cell :math:`i` given by"
msgstr ""
"这里 :math:`N_f` 是单元 :math:`i` 的面数，:math:`\\vec{n}_f` 和 :math:`A_f` 分别是第 :math:`f` 个面的单位法向量和面积，而 :math:`\\mathcal{V}_i` "
"是单元 :math:`i` 的体积，由以下公式给出："

#: ../../source/EB.rst:494 5f07dcc38fbb48f2b44a47742659e109
msgid ""
"\\mathcal{V}_i = (\\Delta x \\Delta y \\Delta z)\\cdot \\mathcal{K}_i\n"
"\n"
msgstr "\\mathcal{V}_i = (\\Delta x \\Delta y \\Delta z)\\cdot \\mathcal{K}_i"

#: ../../source/EB.rst:496 0718acc0cff64c018461c2a19887739a
msgid "where :math:`\\mathcal{K}_i` is the volume fraction of cell :math:`i` ."
msgstr "其中 :math:`\\mathcal{K}_i` 表示细胞 :math:`i` 的体积分数。"

#: ../../source/EB.rst:498 6f6d4710a74749519754b18870ef4ca7
msgid "Now, a conservative update can be written as"
msgstr "现在，我们可以将保守的更新写成这样。"

#: ../../source/EB.rst:500 57979b6760484181a94396f9dd1ad47d
msgid ""
"\\frac{ \\rho^{n+1} \\phi^{n+1} - \\rho^{n} \\phi^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^c\n"
"\n"
msgstr ""
"根据您的要求，我将为您翻译这条公式。请注意，我会保留原始的格式，不会解释任何概念，只提供翻译。\n"
"\n"
"\\frac{ \\rho^{n+1} \\phi^{n+1} - \\rho^{n} \\phi^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^c\n"
"\n"
"Translated into Simplified Chinese:\n"
"\n"
"\\frac{ \\rho^{n+1} \\phi^{n+1} - \\rho^{n} \\phi^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^c"

#: ../../source/EB.rst:502 1d8f78cfee3f4c16bd2884e4eda86aa8
msgid ""
"For each cell cut by the EB geometry, compute the non-conservative update, :math:`\\n"
"abla \\cdot {F}^{nc}` ,"
msgstr ""
"对于由EB几何切割的每个单元格，计算非守恒更新项 :math:`\\n"
"abla \\cdot {F}^{nc}`。"

#: ../../source/EB.rst:504 6f7ed9ee7a064076afa38595cae94698
msgid ""
"\\n"
"abla\\cdot{F}^{nc}_i = \\dfrac{\\sum\\limits_{j\\in N(i) } \\mathcal{K}_j\\n"
"abla \\cdot {F}^c_j} {\\sum\\limits_{j\\in N(i) } {\\mathcal{K}}_j}\n"
"\n"
msgstr ""
"$\\n"
"abla\\cdot{F}^{nc}_i = \\dfrac{\\sum\\limits_{j\\in N(i) } \\mathcal{K}_j\\n"
"abla \\cdot {F}^c_j} {\\sum\\limits_{j\\in N(i) } {\\mathcal{K}}_j}$"

#: ../../source/EB.rst:506 d5e4e49b33474a5b8203f9fcb7e78795
msgid "where :math:`N(i)` is the index set of cell :math:`i` and its neighbors."
msgstr "其中 :math:`N(i)` 是细胞 :math:`i` 及其邻居的索引集合。"

#: ../../source/EB.rst:508 7d224281b2c042fea163f4f46775e04d
msgid ""
"For each cell cut by the EB geometry, compute the convective update :math:`\\n"
"abla \\cdot{F}^{EB}` follows:"
msgstr ""
"对于由EB几何切割的每个单元格，计算对流更新项 :math:`\\n"
"abla \\cdot{F}^{EB}` 如下："

#: ../../source/EB.rst:510 d8671f74c2654be691fc4aba6ec27f25
msgid ""
"\\n"
"abla \\cdot{F}^{EB}_i = \\mathcal{K}_i\\n"
"abla \\cdot{F}^{c}_i +(1-\\mathcal{K}_i) \\n"
"abla \\cdot \\mathcal{F}^{nc}_i\n"
"\n"
msgstr "∇ · F^(EB)_i = 𝒦_i∇ · F^c_i + (1-𝒦_i) ∇ · 𝒢^(nc)_i"

#: ../../source/EB.rst:512 d238529f02764a91b6c69d945bdf4b68
msgid "For each cell cut by the EB geometry, redistribute its mass loss, :math:`\\delta M_i` , to its neighbors:"
msgstr "对于由EB几何图形切割的每个单元格，将其质量损失 :math:`\\delta M_i` 重新分配给其相邻单元格："

#: ../../source/EB.rst:514 bcaf3b6cb611498b8172b9541a5385ff
msgid ""
"\\n"
"abla \\cdot {F}^{EB}_j :=   \\n"
"abla \\cdot {F}^{EB}_j + w_{ij}\\delta M_i\\, \\qquad \\forall j\\in N(i)\\setminus i\n"
"\n"
msgstr "对于所有的 j∈N(i)\\setminus i，定义 nabla dot F^EB_j 为 nabla dot F^EB_j + w_ij * delta M_i。"

#: ../../source/EB.rst:516 1212152316df4e9485d4a6544d8fe081
msgid "where the mass loss in cell :math:`i` , :math:`\\delta M_i` , is given by"
msgstr "在单元格 :math:`i` 中，质量损失 :math:`\\delta M_i` 的表达式如下："

#: ../../source/EB.rst:518 82960a1fd3bc434b8dce8cef07004e30
msgid ""
"\\delta M_i =  \\mathcal{K}_i(1- \\mathcal{K}_i)[ \\n"
"abla \\cdot {F}^c_i-  \\n"
"abla \\cdot {F}^{nc}_i]\n"
"\n"
msgstr "δMᵢ = 𝒦ᵢ(1 - 𝒦ᵢ)[∇ · Fᶜᵢ - ∇ · Fⁿᶜᵢ]"

#: ../../source/EB.rst:520 bd899748b9b143faafe01e7c5f77524a
msgid "and the weights, :math:`w_{ij}` , are"
msgstr "而权重，:math:`w_{ij}`，是"

#: ../../source/EB.rst:522 03d3840a34df4ed0bc856088f2149279
msgid ""
"w_{ij} = \\dfrac{1}{\\sum\\limits_{j\\in N(i)\\setminus i}  \\mathcal{K}_j}\n"
"\n"
msgstr "w_{ij} = \\dfrac{1}{\\sum\\limits_{j\\in N(i)\\setminus i}  \\mathcal{K}_j}"

#: ../../source/EB.rst:524 f8e3a759851942328cfe07543d795d4c
msgid ""
"Note that :math:`\\n"
"abla \\cdot{F}_i^{EB}` gives an update for :math:`\\rho \\phi` ; i.e.,"
msgstr ""
"请注意，:math:`\\n"
"abla \\cdot{F}_i^{EB}` 对于 :math:`\\rho \\phi` 进行更新；即，"

#: ../../source/EB.rst:526 416ab09c1c9c4c7ebee3c9da10d64c4e
msgid ""
"\\frac{(\\rho \\phi_i)^{n+1} - (\\rho \\phi_i)^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^{EB}_i\n"
"\n"
msgstr ""
"\\frac{(\\rho \\phi_i)^{n+1} - (\\rho \\phi_i)^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^{EB}_i"

#: ../../source/EB.rst:528 3e917e938f544c829c60d4b9aa558f56
msgid ""
"Typically, the redistribution neighborhood for each cell is one that can be reached via a monotonic path in each "
"coordinate direction of unit length (see, e.g., :numref:`fig::redistribution`)"
msgstr "通常情况下，每个单元格的重新分配邻域是通过每个坐标方向上的单调路径以单位长度到达的（参见，例如，:numref:`fig::redistribution`）。"

#: ../../source/EB.rst:541 a34358fab8ac404ca7c36b1f76ceb90a
msgid ": Redistribution illustration. Excess update distributed to neighbor cells."
msgstr "再分配说明。多余的更新分发给相邻单元。"

#: ../../source/EB.rst:549 63f87334723d4184bcbd471b23341949
msgid "State Redistribution"
msgstr "国家再分配"

#: ../../source/EB.rst:551 1ca1c8d93a56444f9bc6912ad1e9f188
msgid ""
"For state redistribution we implement the weighted state redistribution algorithm as described in Guiliani et al "
"(2021), which is available on `arxiv  <https://arxiv.org/abs/2112.12360>`_ . This is an extension of the original state "
"redistribution algorithm of Berger and Guiliani (2020)."
msgstr ""
"为了进行状态重分配，我们采用了Guiliani等人（2021）在`arxiv <https://arxiv.org/abs/2112.12360>`_ "
"上描述的加权状态重分配算法。这是Berger和Guiliani（2020）原始状态重分配算法的扩展。"

#: ../../source/EB.rst:559 c4d45cb197664f3d81f46bf518de3177
msgid "Linear Solvers"
msgstr "线性求解器"

#: ../../source/EB.rst:561 90dc58c2d23546b1aa3040abe10bcaf6
msgid ""
"Linear solvers for the canonical form (equation :eq:`eqn::abeclap`) have been discussed in chapter "
":ref:`Chap:LinearSolvers`."
msgstr "在第 :ref:`Chap:LinearSolvers` 章中已经讨论了用于标准形式方程（方程 :eq:`eqn::abeclap`）的线性求解器。"

#: ../../source/EB.rst:564 6bf188aebabf42bab569e5a34436d72f
msgid ""
"AMReX supports multi-level 1) cell-centered solvers with homogeneous Neumann, homogeneous Dirichlet, or inhomogeneous "
"Dirichlet boundary conditions on the EB faces, and 2) nodal solvers with homogeneous Neumann boundary conditions, or "
"inflow velocity conditions on the EB faces."
msgstr "AMReX支持多层次的1) 以单元为中心的求解器，其边界条件可以是均匀诺依曼、均匀迪里希雷或非均匀迪里希雷条件，并且应用于EB面；以及2) 以节点为中心的求解器，其边界条件可以是均匀诺依曼条件或EB面上的入流速度条件。"

#: ../../source/EB.rst:570 82ea27d805f14ba8b181ecb080b41ecc
msgid ""
"To use a cell-centered solver with EB, one builds a linear operator :cpp:`MLEBABecLap` with :cpp:`EBFArrayBoxFactory` "
"(instead of a :cpp:`MLABecLaplacian`)"
msgstr "使用基于单元格的求解器与EB（Embedded Boundary）一起，需要使用`EBFArrayBoxFactory`（而不是`MLABecLaplacian`）构建一个线性算子`:cpp:`MLEBABecLap`。"

#: ../../source/EB.rst:583 185134008184430b8db9f38c0fc9df06
msgid "The usage of this EB-specific class is essentially the same as :cpp:`MLABecLaplacian`."
msgstr "这个特定于EB的类的使用方法基本上与 `MLABecLaplacian` 类相同。"

#: ../../source/EB.rst:586 dfa568f9c25b499182db01b43f1adecd
msgid "The default boundary condition on EB faces is homogeneous Neumann."
msgstr "EB面的默认边界条件是齐次诺依曼。"

#: ../../source/EB.rst:588 11aae1dbdf8446d481fde2b7b58555ed
msgid "To set homogeneous Dirichlet boundary conditions, call"
msgstr "要设置齐次迪里切特边界条件，请调用"

#: ../../source/EB.rst:596 ebce04adf19a48acb2570827e912dad1
msgid ""
"where coeff can be a real number (i.e. the value is the same at every cell) or is the MultiFab holding the coefficient "
"of the gradient at each cell with an EB face."
msgstr "其中coeff可以是一个实数（即在每个单元格中的值相同），或者是一个MultiFab，其中包含每个单元格的梯度系数和EB面。"

#: ../../source/EB.rst:599 ede12b19cb46457faa9cf9dda49471b5
msgid "To set inhomogeneous Dirichlet boundary conditions, call"
msgstr "要设置不均匀的Dirichlet边界条件，请调用"

#: ../../source/EB.rst:607 95f512d2a7114ca5924dbeae64ecef37
msgid ""
"where phi_on_eb is the MultiFab holding the Dirichlet values in every cut cell, and coeff again is a real number (i.e. "
"the value is the same at every cell) or a MultiFab holding the coefficient of the gradient at each cell with an EB face."
msgstr "phi_on_eb 是一个 MultiFab，其中包含每个切割单元的迪里切特值。coeff 是一个实数（即每个单元的值相同），或者是一个 MultiFab，其中包含每个单元的梯度系数和 EB 面。"

#: ../../source/EB.rst:611 5139ec7908794717abb85a62e5b21c01
msgid ""
"Currently there are options to define the face-based coefficients on face centers vs face centroids, and to interpret "
"the solution variable as being defined on cell centers vs cell centroids."
msgstr "目前有选择在面中心和面质心定义基于面的系数，以及将解变量解释为在单元中心和单元质心定义的选项。"

#: ../../source/EB.rst:615 a384e80ee46f4283826886179d952cc2
msgid ""
"The default is for the solution variable to be defined at cell centers; to tell the solver to interpret the solution "
"variable as living at cell centroids, you must set"
msgstr "默认情况下，解变量被定义在单元格中心；要告诉求解器将解变量解释为位于单元格质心，您必须设置"

#: ../../source/EB.rst:625 c8a1bf01670b45639fd978d54cd21715
msgid ""
"The default is for the face-based coefficients to be defined at face centers; to tell the that the face-based "
"coefficients should be interpreted as living at face centroids, modify the setBCoeffs command to be"
msgstr "默认情况下，基于面的系数被定义在面的中心位置；若要指示基于面的系数应被解释为位于面的质心位置，请修改setBCoeffs命令为："

#: ../../source/EB.rst:636 3e25fdc12d054bbfb7f3e40d04abaae8
msgid "Tutorials"
msgstr "教程"

#: ../../source/EB.rst:638 92e04fbebf34416c8a68b283cc219adf
msgid "`EB/CNS`_ is an AMR code for solving compressible Navier-Stokes equations with the embedded boundary approach."
msgstr "`EB/CNS`_ 是一种使用嵌入边界方法求解可压缩Navier-Stokes方程的AMR（自适应网格细化）代码。"

#: ../../source/EB.rst:641 2693e1dd3b08404d872850715783b0af
msgid ""
"`EB/Poisson`_ is a single-level code that is a proxy for solving the electrostatic Poisson equation for a grounded "
"sphere with a point charge inside."
msgstr "`EB/Poisson`_ 是一个单层代码，用于求解带有一个点电荷的接地球的静电泊松方程的代理。"

#: ../../source/EB.rst:645 a2dc8f12e4464eaab0bd85a86b100b6f
msgid ""
"`EB/MacProj`_ is a single-level code that computes a divergence-free flow field around a sphere.  A MAC projection is "
"performed on an initial velocity field of (1,0,0)."
msgstr "`EB/MacProj`_ 是一个单层代码，用于计算围绕球体的无散流场。对一个初始速度场 (1,0,0) 进行了 MAC 投影。"
