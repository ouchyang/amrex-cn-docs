# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/EB.rst:10 51f685a3b3944ed884e443c110b4f36c
msgid "Initializing the Geometric Database"
msgstr "æ­£åœ¨åˆå§‹åŒ–å‡ ä½•æ•°æ®åº“ã€‚"

#: ../../source/EB.rst:12 21e1074c949448878fb4a22729c28a9c
msgid ""
"In AMReX geometric information is stored in a distributed database class that must be initialized at the start of the "
"calculation. The procedure for this goes as follows:"
msgstr "åœ¨ AMReX ä¸­ï¼Œå‡ ä½•ä¿¡æ¯å­˜å‚¨åœ¨ä¸€ä¸ªåˆ†å¸ƒå¼æ•°æ®åº“ç±»ä¸­ï¼Œå¿…é¡»åœ¨è®¡ç®—å¼€å§‹æ—¶è¿›è¡Œåˆå§‹åŒ–ã€‚å…¶åˆå§‹åŒ–è¿‡ç¨‹å¦‚ä¸‹ï¼š"

#: ../../source/EB.rst:16 dbc230475d494daa8f79ac165c3b83b9
msgid ""
"Define an implicit function of position which describes the surface of the embedded object. Specifically, the function "
"class must have a public member function that takes a position and returns a negative value if that position is inside "
"the fluid, a positive value in the body, and identically zero at the embedded boundary."
msgstr "è¯·å®šä¹‰ä¸€ä¸ªéšå‡½æ•°ï¼Œæè¿°åµŒå…¥ç‰©ä½“çš„è¡¨é¢ã€‚å…·ä½“è€Œè¨€ï¼Œè¯¥å‡½æ•°ç±»å¿…é¡»å…·æœ‰ä¸€ä¸ªå…¬å…±æˆå‘˜å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªä½ç½®ä½œä¸ºå‚æ•°ï¼Œå¹¶åœ¨è¯¥ä½ç½®åœ¨æµä½“å†…éƒ¨æ—¶è¿”å›è´Ÿå€¼ï¼Œåœ¨ç‰©ä½“å†…éƒ¨æ—¶è¿”å›æ­£å€¼ï¼Œå¹¶åœ¨åµŒå…¥è¾¹ç•Œå¤„è¿”å›é›¶å€¼ã€‚"

#: ../../source/EB.rst:28 de7b833a0eb2463fb0dc15b7b7e2cbb3
msgid "Make a :cpp:`EB2::GeometryShop` object using the implicit function."
msgstr "ä½¿ç”¨éšå¼å‡½æ•°åˆ›å»ºä¸€ä¸ª `EB2::GeometryShop` å¯¹è±¡ã€‚"

#: ../../source/EB.rst:30 989657236dff412094fe8c955e8de3e5
msgid ""
"Build an :cpp:`EB2::IndexSpace` with the :cpp:`EB2::GeometryShop` object and a :cpp:`Geometry` object that contains the "
"information about the domain and the mesh."
msgstr "ä½¿ç”¨ `EB2::GeometryShop` å¯¹è±¡å’ŒåŒ…å«æœ‰å…³åŸŸå’Œç½‘æ ¼ä¿¡æ¯çš„ `Geometry` å¯¹è±¡æ„å»ºä¸€ä¸ª `EB2::IndexSpace`ã€‚"

#: ../../source/EB.rst:34 1124ade034a24274b37dcc9328ed0aa4
msgid "Here is a simple example of initialize the database for an embedded sphere."
msgstr "è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œç”¨äºåˆå§‹åŒ–åµŒå…¥å¼æ•°æ®åº“ä¸­çš„çƒä½“ã€‚"

#: ../../source/EB.rst:50 138e5d06ccc6438ea60e6cd0958a50c5
msgid ""
"Alternatively, the EB information can be initialized from an STL file specified by a :cpp:`ParmParse` parameter "
"``eb2.stl_file``.  The initialization is done by calling"
msgstr "å¦å¤–ï¼ŒEBä¿¡æ¯ä¹Ÿå¯ä»¥ä»ç”±``ParmParse``å‚æ•°``eb2.stl_file``æŒ‡å®šçš„STLæ–‡ä»¶è¿›è¡Œåˆå§‹åŒ–ã€‚é€šè¿‡è°ƒç”¨ä»¥ä¸‹æ–¹æ³•è¿›è¡Œåˆå§‹åŒ–ï¼š"

#: ../../source/EB.rst:64 c432051a65cd40ad953be5c6fac47126
msgid ""
"Additionally one can use ``eb2.stl_scale``, ``eb2.stl_center`` and ``eb2.stl_reverse_normal`` to scale, translate and "
"reverse the object, respectively."
msgstr "æ­¤å¤–ï¼Œå¯ä»¥ä½¿ç”¨``eb2.stl_scale``ã€``eb2.stl_center``å’Œ``eb2.stl_reverse_normal``æ¥åˆ†åˆ«å¯¹å¯¹è±¡è¿›è¡Œç¼©æ”¾ã€å¹³ç§»å’Œåè½¬æ“ä½œã€‚"

#: ../../source/EB.rst:71 28417fe3b56347158c6803d43a39ad0e
msgid "Implicit Function"
msgstr "éšå‡½æ•°"

#: ../../source/EB.rst:73 6f66c0c58efe42d5a0e1ee14d606c58d
msgid ""
"In ``amrex/Src/EB/``, there are a number of predefined implicit function classes for basic shapes. One can use these "
"directly or as template for their own classes."
msgstr "åœ¨ ``amrex/Src/EB/`` ç›®å½•ä¸‹ï¼Œæœ‰è®¸å¤šé¢„å®šä¹‰çš„éšå¼å‡½æ•°ç±»ç”¨äºåŸºæœ¬å½¢çŠ¶ã€‚å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™äº›ç±»ï¼Œæˆ–è€…å°†å®ƒä»¬ä½œä¸ºæ¨¡æ¿æ¥åˆ›å»ºè‡ªå·±çš„ç±»ã€‚"

#: ../../source/EB.rst:77 3d595e1090304d56b542160a1e6cdb18
msgid ":cpp:`AllRegularIF`:  No embedded boundaries at all."
msgstr ":cpp:`AllRegularIF`: æ²¡æœ‰ä»»ä½•åµŒå…¥è¾¹ç•Œã€‚"

#: ../../source/EB.rst:79 2b10e196eb054a82bb52bfd4346c0542
msgid ":cpp:`BoxIF`: Box."
msgstr ":cpp:`BoxIF`: ç›’å­ã€‚"

#: ../../source/EB.rst:81 54369537864643988addd943520a1c82
msgid ":cpp:`CylinderIF`: Cylinder."
msgstr ":cpp:`CylinderIF`: åœ†æŸ±ä½“ã€‚"

#: ../../source/EB.rst:83 7a346eddf7f44db38f6fe91e1582ecb6
msgid ":cpp:`EllipsoidIF`: Ellipsoid."
msgstr ":cpp:`EllipsoidIF`: æ¤­çƒä½“ã€‚"

#: ../../source/EB.rst:85 510b3238804648b2b7f300dee8857c9a
msgid ":cpp:`PlaneIF`: Half-space plane."
msgstr ":cpp:`PlaneIF`: åŠç©ºé—´å¹³é¢ã€‚"

#: ../../source/EB.rst:87 9822db206b4643d484078b4f2ba5cf68
msgid ":cpp:`SphereIF`: Sphere."
msgstr ":cpp:`SphereIF`: çƒä½“ã€‚"

#: ../../source/EB.rst:89 7156091bd5d54667943362c109133d8f
msgid "AMReX also provides a number of transformation operations to apply to an object."
msgstr "AMReXè¿˜æä¾›äº†è®¸å¤šå¯ä»¥åº”ç”¨äºå¯¹è±¡çš„è½¬æ¢æ“ä½œã€‚"

#: ../../source/EB.rst:91 d6c1f3b8803d4383a64b783bc553f0c8
msgid ":cpp:`makeComplement`: Complement of an object. E.g. a sphere with fluid on outside becomes a sphere with fluid inside."
msgstr ":cpp:`makeComplement`: å¯¹è±¡çš„è¡¥é›†ã€‚ä¾‹å¦‚ï¼Œå¤–éƒ¨æœ‰æµä½“çš„çƒä½“å˜æˆå†…éƒ¨æœ‰æµä½“çš„çƒä½“ã€‚"

#: ../../source/EB.rst:94 32e46a6042c14c589041145f9ab0f527
msgid ":cpp:`makeIntersection`: Intersection of two or more objects."
msgstr ":cpp:`makeIntersection`: ä¸¤ä¸ªæˆ–å¤šä¸ªå¯¹è±¡çš„äº¤é›†ã€‚"

#: ../../source/EB.rst:96 e0d1cc184fd349608bec5765226653c2
msgid ":cpp:`makeUnion`: Union of two or more objects."
msgstr ":cpp:`makeUnion`: åˆå¹¶ä¸¤ä¸ªæˆ–å¤šä¸ªå¯¹è±¡ã€‚"

#: ../../source/EB.rst:98 30482759b73b4609b32a17b2681523c4
msgid ":cpp:`Translate`: Translates an object."
msgstr ":cpp:`Translate`: ç¿»è¯‘ä¸€ä¸ªå¯¹è±¡ã€‚"

#: ../../source/EB.rst:100 b2c4daf366514610887a50047a183736
msgid ":cpp:`scale`: Scales an object."
msgstr ":cpp:`scale`: å¯¹ä¸€ä¸ªå¯¹è±¡è¿›è¡Œç¼©æ”¾ã€‚"

#: ../../source/EB.rst:102 982bfb29ef284b848b8c28165939cd9f
msgid ":cpp:`rotate`: Rotates an object."
msgstr ":cpp:`rotate`: æ—‹è½¬ä¸€ä¸ªå¯¹è±¡ã€‚"

#: ../../source/EB.rst:104 095718e69ec04a7a883d44c5a7d67b13
msgid ":cpp:`lathe`: Creates a surface of revolution by rotating a 2D object around an axis."
msgstr ":cpp:`è½¦åºŠ`: é€šè¿‡å›´ç»•è½´çº¿æ—‹è½¬äºŒç»´ç‰©ä½“æ¥åˆ›å»ºä¸€ä¸ªæ—‹è½¬æ›²é¢ã€‚"

#: ../../source/EB.rst:106 7b89f29718b940de8a774ca5c2d1a5f8
msgid "Here are some examples of using these functions."
msgstr "è¿™é‡Œæ˜¯ä½¿ç”¨è¿™äº›å‡½æ•°çš„ä¸€äº›ç¤ºä¾‹ã€‚"

#: ../../source/EB.rst:130 ac697a0fa1524fdd8f79710eb8248697
msgid ":cpp:`EB2::GeometryShop`"
msgstr ":cpp:`EB2::GeometryShop`"

#: ../../source/EB.rst:132 c09bbbfec52a4df6964c8237d304528b
msgid "Given an implicit function object, say :cpp:`f`, we can make a :cpp:`GeometryShop` object with"
msgstr "ç»™å®šä¸€ä¸ªéšå¼å‡½æ•°å¯¹è±¡ï¼Œæ¯”å¦‚ `f`ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥åˆ›å»ºä¸€ä¸ª `GeometryShop` å¯¹è±¡ã€‚"

#: ../../source/EB.rst:142 0acc45673dff40248d017150dfd09084
msgid ":cpp:`EB2::IndexSpace`"
msgstr ":cpp:`EB2::IndexSpace`"

#: ../../source/EB.rst:144 7e705a5a40634e1b8b14925c7625f4e0
msgid "We build :cpp:`EB2::IndexSpace` with a template function"
msgstr "æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªæ¨¡æ¿å‡½æ•°æ¥æ„å»º `EB2::IndexSpace`ã€‚"

#: ../../source/EB.rst:156 90a8da5fdfb7467cb0c943177c14e67b
msgid ""
"Here the template parameter is a :cpp:`EB2::GeometryShop`. :cpp:`Geometry` (see section :ref:`sec:basics:geom`) "
"describes the rectangular problem domain and the mesh on the finest AMR level. Coarse level EB data is generated from "
"coarsening the original fine data. The :cpp:`int required_coarsening_level` parameter specifies the number of "
"coarsening levels required. This is usually set to :math:`N-1`, where :math:`N` is the total number of AMR levels. The "
":cpp:`int max_coarsening_levels` parameter specifies the number of coarsening levels AMReX should try to have. This is "
"usually set to a big number, say 20 if multigrid solvers are used. This essentially tells the build to coarsen as much "
"as it can. If there are no multigrid solvers, the parameter should be set to the same as "
":cpp:`required_coarsening_level`. It should be noted that coarsening could create multi-valued cells even if the fine "
"level does not have any multi-valued cells. This occurs when the embedded boundary cuts a cell in such a way that there "
"is fluid on multiple sides of the boundary within that cell. Because multi-valued cells are not supported, it will "
"cause a runtime error if the required coarsening level generates multi-valued cells. The optional :cpp:`int ngrow` "
"parameter specifies the number of ghost cells outside the domain on required levels. For levels coarser than the "
"required level, no EB data are generated for ghost cells outside the domain."
msgstr ""
"åœ¨è¿™é‡Œï¼Œæ¨¡æ¿å‚æ•°æ˜¯ä¸€ä¸ª `EB2::GeometryShop`ã€‚`Geometry`ï¼ˆå‚è§ç¬¬ `sec:basics:geom` èŠ‚ï¼‰æè¿°äº†çŸ©å½¢é—®é¢˜åŸŸå’Œæœ€ç²¾ç»†çš„ AMR å±‚ä¸Šçš„ç½‘æ ¼ã€‚ç²—ç³™çº§åˆ«çš„ EB "
"æ•°æ®æ˜¯é€šè¿‡å¯¹åŸå§‹ç²¾ç»†æ•°æ®è¿›è¡Œç²—åŒ–ç”Ÿæˆçš„ã€‚`int required_coarsening_level` å‚æ•°æŒ‡å®šæ‰€éœ€çš„ç²—åŒ–çº§åˆ«æ•°ã€‚é€šå¸¸å°†å…¶è®¾ç½®ä¸º :math:`N-1`ï¼Œå…¶ä¸­ :math:`N` æ˜¯æ€»çš„ AMR çº§åˆ«æ•°ã€‚`int "
"max_coarsening_levels` å‚æ•°æŒ‡å®š AMReX åº”å°½é‡æ‹¥æœ‰çš„ç²—åŒ–çº§åˆ«æ•°ã€‚å¦‚æœä½¿ç”¨å¤šé‡ç½‘æ ¼æ±‚è§£å™¨ï¼Œé€šå¸¸å°†å…¶è®¾ç½®ä¸ºä¸€ä¸ªè¾ƒå¤§çš„æ•°ï¼Œæ¯”å¦‚ 20ã€‚è¿™åŸºæœ¬ä¸Šå‘Šè¯‰æ„å»ºç³»ç»Ÿå°½å¯èƒ½å¤šåœ°è¿›è¡Œç²—åŒ–ã€‚å¦‚æœæ²¡æœ‰å¤šé‡ç½‘æ ¼æ±‚è§£å™¨ï¼Œåˆ™è¯¥å‚æ•°åº”è®¾ç½®ä¸ºä¸ "
"`required_coarsening_level` "
"ç›¸åŒã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿ç²¾ç»†çº§åˆ«æ²¡æœ‰å¤šå€¼å•å…ƒï¼Œç²—åŒ–ä¹Ÿå¯èƒ½åˆ›å»ºå¤šå€¼å•å…ƒã€‚å½“åµŒå…¥è¾¹ç•Œä»¥æŸç§æ–¹å¼åˆ‡å‰²å•å…ƒæ—¶ï¼Œåœ¨è¯¥å•å…ƒå†…è¾¹ç•Œçš„å¤šä¸ªä¾§é¢ä¸Šå­˜åœ¨æµä½“ã€‚ç”±äºä¸æ”¯æŒå¤šå€¼å•å…ƒï¼Œå¦‚æœæ‰€éœ€çš„ç²—åŒ–çº§åˆ«ç”Ÿæˆå¤šå€¼å•å…ƒï¼Œå°†ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯ã€‚å¯é€‰çš„ `int "
"ngrow` å‚æ•°æŒ‡å®šæ‰€éœ€çº§åˆ«åŸŸå¤–çš„å¹½çµå•å…ƒæ•°ã€‚å¯¹äºæ¯”æ‰€éœ€çº§åˆ«æ›´ç²—çš„çº§åˆ«ï¼Œä¸ä¼šä¸ºåŸŸå¤–çš„å¹½çµå•å…ƒç”Ÿæˆ EB æ•°æ®ã€‚"

#: ../../source/EB.rst:176 9fe34cc462e346208f0eb998cabe6cb9
msgid ""
"The newly built :cpp:`EB2::IndexSpace` is pushed on to a stack. Static function :cpp:`EB2::IndexSpace::top()` returns a "
":cpp:`const &` to the new :cpp:`EB2::IndexSpace` object. We usually only need to build one :cpp:`EB2::IndexSpace` "
"object. However, if your application needs multiple :cpp:`EB2::IndexSpace` objects, you can save the pointers for later "
"use. For simplicity, we assume there is only one `EB2::IndexSpace` object for the rest of this chapter."
msgstr ""
"æ–°å»ºçš„ `EB2::IndexSpace` è¢«æ¨å…¥å †æ ˆã€‚é™æ€å‡½æ•° `EB2::IndexSpace::top()` è¿”å›ä¸€ä¸ªå¯¹æ–°çš„ `EB2::IndexSpace` å¯¹è±¡çš„ `const &` å¼•ç”¨ã€‚é€šå¸¸æˆ‘ä»¬åªéœ€è¦æ„å»ºä¸€ä¸ª "
"`EB2::IndexSpace` å¯¹è±¡ã€‚ç„¶è€Œï¼Œå¦‚æœæ‚¨çš„åº”ç”¨ç¨‹åºéœ€è¦å¤šä¸ª `EB2::IndexSpace` å¯¹è±¡ï¼Œæ‚¨å¯ä»¥ä¿å­˜æŒ‡é’ˆä»¥ä¾›ä»¥åä½¿ç”¨ã€‚ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾åœ¨æœ¬ç« çš„å…¶ä½™éƒ¨åˆ†åªæœ‰ä¸€ä¸ª `EB2::IndexSpace` å¯¹è±¡ã€‚"

#: ../../source/EB.rst:185 f6de501a98624883bd53c106e34ef48e
msgid "EBFArrayBoxFactory"
msgstr "EBFArrayBoxFactory"

#: ../../source/EB.rst:187 4a361907467e43ed9ea99675f2dba02e
msgid ""
"After the EB database is initialized, the next thing we build is :cpp:`EBFArrayBoxFactory`. This object provides access "
"to the EB database in the format of basic AMReX objects such as :cpp:`BaseFab`, :cpp:`FArrayBox`, :cpp:`FabArray`, and "
":cpp:`MultiFab`. We can construct it with"
msgstr ""
"åœ¨EBæ•°æ®åº“åˆå§‹åŒ–å®Œæˆåï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥è¦æ„å»ºçš„æ˜¯ï¼šcpp:`EBFArrayBoxFactory`ã€‚è¿™ä¸ªå¯¹è±¡ä»¥åŸºæœ¬çš„AMReXå¯¹è±¡ï¼ˆå¦‚cpp:`BaseFab`ã€cpp:`FArrayBox`ã€cpp:`FabArray`å’Œcpp:`"
"MultiFab`ï¼‰çš„æ ¼å¼æä¾›å¯¹EBæ•°æ®åº“çš„è®¿é—®ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹å¼æ„å»ºå®ƒï¼š"

#: ../../source/EB.rst:202 f0c7fd2706b247329eb355efb59880f6
msgid "or"
msgstr "æˆ–è€…"

#: ../../source/EB.rst:215 a96aab00bc404c9faa4ea5fd71dab022
msgid ""
"Argument :cpp:`Vector<int> const& a_ngrow` specifies the number of ghost cells we need for EB data at various "
":cpp:`EBSupport` levels, and argument :cpp:`EBSupport a_support` specifies the level of support needed."
msgstr ""
"å‚æ•° `cpp:Vector<int> const& a_ngrow` æŒ‡å®šäº†åœ¨ä¸åŒçš„ `cpp:EBSupport` çº§åˆ«ä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ä¸º EB æ•°æ®é¢„ç•™çš„å¹½çµå•å…ƒæ•°é‡ã€‚è€Œå‚æ•° `cpp:EBSupport a_support` "
"åˆ™æŒ‡å®šäº†æ‰€éœ€çš„æ”¯æŒçº§åˆ«ã€‚"

#: ../../source/EB.rst:220 049b81e803494aba89960e0b99220070
msgid ":cpp:`EBSupport:basic`:  basic flags for cell types"
msgstr ":cpp:`EBSupport:basic`: å•å…ƒç±»å‹çš„åŸºæœ¬æ ‡å¿—"

#: ../../source/EB.rst:221 7a04165591824757bba843323f23d936
msgid ":cpp:`EBSupport:volume`: basic plus volume fraction and centroid"
msgstr ":cpp:`EBSupport:volume`: åŸºæœ¬åŠ ä½“ç§¯åˆ†æ•°å’Œè´¨å¿ƒ"

#: ../../source/EB.rst:222 0712b0aa099941099483798458d06643
msgid ":cpp:`EBSupport:full`: volume plus area fraction, boundary centroid and face centroid"
msgstr ":cpp:`EBSupport:full`: ä½“ç§¯åŠ é¢ç§¯åˆ†æ•°ï¼Œè¾¹ç•Œè´¨å¿ƒå’Œé¢è´¨å¿ƒ"

#: ../../source/EB.rst:225 804b5e999924410cac86e9d490a517cd
msgid ""
":cpp:`EBFArrayBoxFactory` is derived from :cpp:`FabFactory<FArrayBox>`. :cpp:`MultiFab` constructors have an optional "
"argument :cpp:`const FabFactory<FArrayBox>&`.  We can use :cpp:`EBFArrayBoxFactory` to build :cpp:`MultiFab`\\ s that "
"carry EB data.  Member function of :cpp:`FabArray`"
msgstr ""
"`EBFArrayBoxFactory`æ˜¯ä»`FabFactory<FArrayBox>`æ´¾ç”Ÿè€Œæ¥çš„ã€‚`MultiFab`çš„æ„é€ å‡½æ•°æœ‰ä¸€ä¸ªå¯é€‰å‚æ•°`const "
"FabFactory<FArrayBox>&`ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`EBFArrayBoxFactory`æ¥æ„å»ºæºå¸¦EBæ•°æ®çš„`MultiFab`ã€‚è¿™æ˜¯`FabArray`çš„æˆå‘˜å‡½æ•°ã€‚"

#: ../../source/EB.rst:237 ba3f2a0fcc6f40e5a1688d30517bbbf5
msgid ""
"can then be used to return a reference to the :cpp:`EBFArrayBoxFactory` used for building the :cpp:`MultiFab`. Using "
":cpp:`dynamic_cast`, we can test whether a :cpp:`MultiFab` is built with an :cpp:`EBFArrayBoxFactory`."
msgstr "å¯ä»¥ç”¨æ¥è¿”å›å¯¹ç”¨äºæ„å»ºMultiFabçš„EBFArrayBoxFactoryçš„å¼•ç”¨ã€‚ä½¿ç”¨dynamic_castï¼Œæˆ‘ä»¬å¯ä»¥æµ‹è¯•ä¸€ä¸ªMultiFabæ˜¯å¦æ˜¯ä½¿ç”¨EBFArrayBoxFactoryæ„å»ºçš„ã€‚"

#: ../../source/EB.rst:253 1dd218e3c68e4dcc8ff48019eac5f600
msgid "Embedded Boundary Data"
msgstr "åµŒå…¥è¾¹ç•Œæ•°æ®"

#: ../../source/EB.rst:255 38782495c3f741b2bf94e3152fc172b5
msgid "Through member functions of :cpp:`EBFArrayBoxFactory`, we have access to the following data:"
msgstr "é€šè¿‡ :cpp:`EBFArrayBoxFactory` çš„æˆå‘˜å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®ä»¥ä¸‹æ•°æ®ï¼š"

#: ../../source/EB.rst:280 d2baf70574764f77aee3bdf8f59a56c0
msgid ""
"**Volume fraction** is in a single-component :cpp:`MultiFab`. Data are in the range of :math:`[0,1]` with zero "
"representing covered cells and one for regular cells."
msgstr "åœ¨å•ç»„åˆ†çš„ `MultiFab` ä¸­ï¼Œ**ä½“ç§¯åˆ†æ•°**è¡¨ç¤ºæ•°æ®çš„èŒƒå›´åœ¨ [0,1] ä¹‹é—´ï¼Œå…¶ä¸­é›¶è¡¨ç¤ºè¢«è¦†ç›–çš„å•å…ƒæ ¼ï¼Œè€Œä¸€è¡¨ç¤ºå¸¸è§„å•å…ƒæ ¼ã€‚"

#: ../../source/EB.rst:284 662a66c95a96411c85089bc60aae975d
msgid ""
"**Volume centroid** (also called cell centroid) is in a :cpp:`MultiCutFab` with ``AMREX_SPACEDIM`` components. Each "
"component of the data is in the range of :math:`[-0.5,0.5]`, based on each cell's local coordinates with respect to the "
"regular cell's center."
msgstr "**ä½“ç§¯è´¨å¿ƒ**ï¼ˆä¹Ÿç§°ä¸ºå•å…ƒè´¨å¿ƒï¼‰ä½äºå…·æœ‰``AMREX_SPACEDIM``ä¸ªåˆ†é‡çš„:cpp:`MultiCutFab`ä¸­ã€‚æ•°æ®çš„æ¯ä¸ªåˆ†é‡éƒ½åœ¨èŒƒå›´:math:`[-0.5,0.5]`å†…ï¼ŒåŸºäºæ¯ä¸ªå•å…ƒç›¸å¯¹äºè§„åˆ™å•å…ƒä¸­å¿ƒçš„å±€éƒ¨åæ ‡ã€‚"

#: ../../source/EB.rst:289 9deb9bfd909b46c98dda375519e35266
msgid ""
"**Boundary centroid** is also in a :cpp:`MultiCutFab` with ``AMREX_SPACEDIM`` components.  Each component of the data "
"is in the range of :math:`[-0.5,0.5]`, based on each cell's local coordinates with respect to the regular cell's center."
msgstr ""
"**Boundary centroid** ä¹Ÿä½äºå…·æœ‰ ``AMREX_SPACEDIM`` ç»´åº¦çš„ :cpp:`MultiCutFab` ä¸­ã€‚æ•°æ®çš„æ¯ä¸ªåˆ†é‡éƒ½åœ¨ :math:`[-0.5,0.5]` "
"çš„èŒƒå›´å†…ï¼ŒåŸºäºæ¯ä¸ªå•å…ƒæ ¼ç›¸å¯¹äºè§„åˆ™å•å…ƒæ ¼ä¸­å¿ƒçš„å±€éƒ¨åæ ‡ã€‚"

#: ../../source/EB.rst:294 97c64e39f32d427d85793a0ac43cfd0e
msgid ""
"**Face centroid** is in a :cpp:`MultiCutFab` with ``AMREX_SPACEDIM`` components. Each component of the data is in the "
"range of :math:`[-0.5,0.5]`, based on each cell's local coordinates with respect to the embedded boundary."
msgstr "**é¢å¿ƒ**ä½äºå…·æœ‰``AMREX_SPACEDIM``ä¸ªç»„ä»¶çš„:cpp:`MultiCutFab`ä¸­ã€‚æ•°æ®çš„æ¯ä¸ªç»„ä»¶éƒ½åœ¨èŒƒå›´:math:`[-0.5,0.5]`å†…ï¼ŒåŸºäºæ¯ä¸ªå•å…ƒæ ¼ç›¸å¯¹äºåµŒå…¥è¾¹ç•Œçš„å±€éƒ¨åæ ‡ã€‚"

#: ../../source/EB.rst:298 e2c799e8952c4efe89907a6a981b899f
msgid ""
"**Area fractions** are returned in an :cpp:`Array` of :cpp:`MultiCutFab` pointers. For each direction, area fraction is "
"for the face of that direction. Data are in the range of :math:`[0,1]` with zero representing a covered face and one an "
"un-cut face."
msgstr "**é¢ç§¯åˆ†æ•°**ä»¥ :cpp:`MultiCutFab` æŒ‡é’ˆçš„ :cpp:`Array` å½¢å¼è¿”å›ã€‚å¯¹äºæ¯ä¸ªæ–¹å‘ï¼Œé¢ç§¯åˆ†æ•°è¡¨ç¤ºè¯¥æ–¹å‘çš„é¢ã€‚æ•°æ®èŒƒå›´åœ¨ :math:`[0,1]` ä¹‹é—´ï¼Œå…¶ä¸­é›¶è¡¨ç¤ºè¢«è¦†ç›–çš„é¢ï¼Œè€Œä¸€è¡¨ç¤ºæœªåˆ‡å‰²çš„é¢ã€‚"

#: ../../source/EB.rst:303 da0f50f0e906460db4e22a6028efdf9d
msgid ""
"**Face centroids** are returned in an :cpp:`Array` of :cpp:`MultiCutFab` pointers. There are two components for each "
"direction and the ordering is always the same as the original ordering of the coordinates. For example, for :math:`y` "
"face, the component 0 is for :math:`x` coordinate and 1 for :math:`z`. The coordinates are in each face's local frame "
"normalized to the range of :math:`[-0.5,0.5]`."
msgstr ""
"**é¢å¿ƒç‚¹**ä»¥ä¸€ä¸ª `Array` çš„ `MultiCutFab` æŒ‡é’ˆè¿”å›ã€‚æ¯ä¸ªæ–¹å‘éƒ½æœ‰ä¸¤ä¸ªåˆ†é‡ï¼Œå…¶é¡ºåºä¸åæ ‡çš„åŸå§‹é¡ºåºå§‹ç»ˆç›¸åŒã€‚ä¾‹å¦‚ï¼Œå¯¹äº `y` é¢ï¼Œåˆ†é‡ 0 å¯¹åº”äº `x` åæ ‡ï¼Œåˆ†é‡ 1 å¯¹åº”äº `z` "
"åæ ‡ã€‚è¿™äº›åæ ‡åœ¨æ¯ä¸ªé¢çš„å±€éƒ¨åæ ‡ç³»ä¸­å½’ä¸€åŒ–åˆ°èŒƒå›´ `[-0.5, 0.5]`ã€‚"

#: ../../source/EB.rst:312 dbc2861b4ff84cf2ab3706a214e13ce8
msgid "Embedded Boundary Data Structures"
msgstr "åµŒå…¥å¼è¾¹ç•Œæ•°æ®ç»“æ„"

#: ../../source/EB.rst:314 e166360a7ef14550af09519dc5e8e960
msgid "A :cpp:`MultiCutFab` is very similar to a :cpp:`MultiFab`. Its data can be accessed with subscript operator"
msgstr "ä¸€ä¸ª `MultiCutFab` ç±»éå¸¸ç±»ä¼¼äºä¸€ä¸ª `MultiFab` ç±»ã€‚å®ƒçš„æ•°æ®å¯ä»¥é€šè¿‡ä¸‹æ ‡æ“ä½œç¬¦è¿›è¡Œè®¿é—®ã€‚"

#: ../../source/EB.rst:323 e1f245b8fc8f44d89d258701b1c0900e
msgid ""
"Here :cpp:`CutFab` is derived from :cpp:`FArrayBox` and can be passed to Fortran just like :cpp:`FArrayBox`. The "
"difference between :cpp:`MultiCutFab` and :cpp:`MultiFab` is that to save memory :cpp:`MultiCutFab` only has data on "
"boxes that contain cut cells. It is an error to call :cpp:`operator[]` if that box does not have cut cells. Thus the "
"call must be in a :cpp:`if` test block (see section :ref:`sec:EB:flag`)."
msgstr ""
"è¿™é‡Œï¼Œ`CutFab` æ˜¯ä» `FArrayBox` æ´¾ç”Ÿè€Œæ¥çš„ï¼Œå¯ä»¥åƒ `FArrayBox` ä¸€æ ·ä¼ é€’ç»™ Fortranã€‚`MultiCutFab` å’Œ `MultiFab` çš„åŒºåˆ«åœ¨äºä¸ºäº†èŠ‚çœå†…å­˜ï¼Œ`MultiCutFab` "
"åªåœ¨åŒ…å«åˆ‡å‰²å•å…ƒçš„ç›’å­ä¸Šå­˜å‚¨æ•°æ®ã€‚å¦‚æœè¯¥ç›’å­æ²¡æœ‰åˆ‡å‰²å•å…ƒï¼Œåˆ™è°ƒç”¨ `operator[]` æ˜¯é”™è¯¯çš„ã€‚å› æ­¤ï¼Œè¯¥è°ƒç”¨å¿…é¡»ä½äºä¸€ä¸ª `if` æµ‹è¯•å—ä¸­ï¼ˆå‚è§ç¬¬ :ref:`sec:EB:flag` èŠ‚ï¼‰ã€‚"

#: ../../source/EB.rst:333 d19ccdfd99a44da0b55b267b4c285f27
msgid ":cpp:`EBCellFlagFab`"
msgstr ":cpp:`EBCellFlagFab`"

#: ../../source/EB.rst:335 00212537ab4c4461a2bddc040d6e5fe9
msgid ":cpp:`EBCellFlagFab` contains information on cell types.  We can use it to determine if a box contains cut cells."
msgstr "`EBCellFlagFab` åŒ…å«æœ‰å…³å•å…ƒæ ¼ç±»å‹çš„ä¿¡æ¯ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥ç¡®å®šä¸€ä¸ªç›’å­æ˜¯å¦åŒ…å«åˆ‡å‰²å•å…ƒã€‚"

#: ../../source/EB.rst:359 d8748aeddaa941358b9013d98750bd8a
msgid ""
":cpp:`EBCellFlagFab` is derived from :cpp:`BaseFab`. Its data are stored in an array of 32-bit integers, and can be "
"used in C++ or passed to Fortran just like an :cpp:`IArrayBox` (section :ref:`sec:basics:fab`). AMReX provides a "
"Fortran module called ``amrex_ebcellflag_module``. This module contains procedures for testing cell types and getting "
"neighbor information. For example"
msgstr ""
"`EBCellFlagFab`æ˜¯ä»`BaseFab`æ´¾ç”Ÿè€Œæ¥çš„ã€‚å®ƒçš„æ•°æ®å­˜å‚¨åœ¨ä¸€ä¸ª32ä½æ•´æ•°æ•°ç»„ä¸­ï¼Œå¹¶ä¸”å¯ä»¥åƒ`IArrayBox`ä¸€æ ·åœ¨C++ä¸­ä½¿ç”¨æˆ–ä¼ é€’ç»™Fortranï¼ˆå‚è§:ref:`sec:basics:fab`"
"èŠ‚ï¼‰ã€‚AMReXæä¾›äº†ä¸€ä¸ªåä¸º`amrex_ebcellflag_module`çš„Fortranæ¨¡å—ã€‚è¯¥æ¨¡å—åŒ…å«ç”¨äºæµ‹è¯•å•å…ƒæ ¼ç±»å‹å’Œè·å–é‚»å±…ä¿¡æ¯çš„è¿‡ç¨‹ã€‚ä¾‹å¦‚ï¼Œ"

#: ../../source/EB.rst:390 1c78dc37e5b94817b4a9fe807f2974f8
msgid "Small Cell Problem and Redistribution"
msgstr "å°åŒºé—®é¢˜å’Œé‡æ–°åˆ†é…"

#: ../../source/EB.rst:392 245754aa5f22489fb14261c397cebe6e
msgid ""
"First, we review finite volume discretizations with embedded boundaries as used by AMReX-based applications. Then we "
"illustrate the small cell problem."
msgstr "é¦–å…ˆï¼Œæˆ‘ä»¬å›é¡¾ä¸€ä¸‹AMReXåº”ç”¨ç¨‹åºä¸­ä½¿ç”¨çš„å¸¦åµŒå…¥è¾¹ç•Œçš„æœ‰é™ä½“ç§¯ç¦»æ•£åŒ–æ–¹æ³•ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†è¯´æ˜å°å•å…ƒé—®é¢˜ã€‚"

#: ../../source/EB.rst:396 3f5636f6b81f452986351f228dd53657
msgid "Finite Volume Discretizations"
msgstr "æœ‰é™ä½“ç§¯ç¦»æ•£åŒ–æ–¹æ³•"

#: ../../source/EB.rst:398 7bb54c4845cb4872a350b478efe0fdb9
msgid "Consider a system of PDEs to advance a conserved quantity :math:`U` with fluxes :math:`F`:"
msgstr "è€ƒè™‘ä¸€ä¸ªç”¨äºæ¨è¿›å®ˆæ’é‡ :math:`U` çš„åå¾®åˆ†æ–¹ç¨‹ç³»ç»Ÿï¼Œå…¶ä¸­åŒ…å«äº†é€šé‡ :math:`F`ã€‚"

#: ../../source/EB.rst:401 bc28d0d6509e41e8ad635698b7d084c0
msgid ""
"\\frac{\\partial U}{\\partial t} + \\n"
"abla \\cdot F = 0.\n"
"\n"
msgstr ""
"\\frac{\\partial U}{\\partial t} + \\n"
"abla \\cdot F = 0."

#: ../../source/EB.rst:404 9128389e230d40eebd0f2a3bebf371bb
msgid "A conservative, finite volume discretization starts with the divergence theorm"
msgstr "ä¸€ä¸ªä¿å®ˆçš„æœ‰é™ä½“ç§¯ç¦»æ•£åŒ–ä»æ•£åº¦å®šç†å¼€å§‹ã€‚"

#: ../../source/EB.rst:406 c6909ea910454bf1887ab109de9676c1
msgid ""
"\\int_V \\n"
"abla \\cdot F dV = \\int_{\\partial V} F \\cdot n dA.\n"
"\n"
msgstr "åœ¨ä½“ç§¯Vä¸Šçš„æ•£åº¦Fçš„ç§¯åˆ†ç­‰äºåœ¨Vçš„è¾¹ç•Œä¸ŠFä¸æ³•å‘é‡nçš„ç‚¹ç§¯çš„ç§¯åˆ†ã€‚"

#: ../../source/EB.rst:408 b4564b48014d494cbaef734e9bea40e1
msgid "In an embedded boundary cell, the \"conservative divergence\" is discretized (as :math:`D^c(F)`) as follows"
msgstr "åœ¨åµŒå…¥è¾¹ç•Œå•å…ƒä¸­ï¼Œâ€œä¿å®ˆæ•£åº¦â€è¢«ç¦»æ•£åŒ–ä¸º :math:`D^c(F)`ï¼Œå…·ä½“å¦‚ä¸‹æ‰€ç¤ºï¼š"

#: ../../source/EB.rst:411 214eacbfe29e4e8388601aedecce7900
msgid ""
" D^c(F) = \\frac{1}{\\kappa h} \\left( \\sum^D_{d = 1}\n"
"   (F_{d, \\mathrm{hi}} \\, \\alpha_{d, \\mathrm{hi}} - F_{d, \\mathrm{lo}}\\, \\alpha_{d, \\mathrm{lo}})\n"
"   + F^{EB} \\alpha^{EB} \\right)."
msgstr ""
"D^c(F) = \\frac{1}{\\kappa h} \\left( \\sum^D_{d = 1}\n"
"   (F_{d, \\mathrm{hi}} \\, \\alpha_{d, \\mathrm{hi}} - F_{d, \\mathrm{lo}}\\, \\alpha_{d, \\mathrm{lo}})\n"
"   + F^{EB} \\alpha^{EB} \\right)."

#: ../../source/EB.rst:418 3f6411cad0284a6fab2059353aeefce1
msgid ""
"Geometry is discretely represented by volumes (:math:`V = \\kappa h^d`) and apertures (:math:`A= \\alpha h^{d-1}`), "
"where :math:`h` is the (uniform) mesh spacing at that AMR level, :math:`\\kappa` is the volume fraction and "
":math:`\\alpha` are the area fractions. Without multivalued cells the volume fractions, area fractions and cell and "
"face centroids (see :numref:`fig::volume`) are the only geometric information needed to compute second-order fluxes "
"centered at the face centroids, and to infer the connectivity of the cells. Cells are connected if adjacent on the "
"Cartesian mesh, and only via coordinate-aligned faces on the mesh. If an aperture, :math:`\\alpha = 0`, between two "
"cells, they are not directly connected to each other."
msgstr ""
"å‡ ä½•å½¢çŠ¶é€šè¿‡ä½“ç§¯ï¼ˆ:math:`V = \\kappa h^d`ï¼‰å’Œå­”éš™ï¼ˆ:math:`A= \\alpha h^{d-1}`ï¼‰ç¦»æ•£è¡¨ç¤ºï¼Œå…¶ä¸­ :math:`h` æ˜¯è¯¥è‡ªé€‚åº”ç½‘æ ¼ç»†åŒ–å±‚çº§ä¸Šçš„ï¼ˆå‡åŒ€ï¼‰ç½‘æ ¼é—´è·ï¼Œ:math:`\\kappa` "
"æ˜¯ä½“ç§¯åˆ†æ•°ï¼Œ:math:`\\alpha` æ˜¯é¢ç§¯åˆ†æ•°ã€‚åœ¨æ²¡æœ‰å¤šå€¼å•å…ƒçš„æƒ…å†µä¸‹ï¼Œä½“ç§¯åˆ†æ•°ã€é¢ç§¯åˆ†æ•°ä»¥åŠå•å…ƒå’Œé¢å¿ƒï¼ˆå‚è§ "
":numref:`fig::volume`ï¼‰æ˜¯è®¡ç®—ä»¥é¢å¿ƒä¸ºä¸­å¿ƒçš„äºŒé˜¶é€šé‡å’Œæ¨æ–­å•å…ƒè¿æ¥æ€§æ‰€éœ€çš„å”¯ä¸€å‡ ä½•ä¿¡æ¯ã€‚å¦‚æœåœ¨ç¬›å¡å°”ç½‘æ ¼ä¸Šç›¸é‚»ï¼Œåˆ™å•å…ƒé€šè¿‡åæ ‡å¯¹é½çš„é¢è¿æ¥ã€‚å¦‚æœä¸¤ä¸ªå•å…ƒä¹‹é—´å­˜åœ¨å­”éš™ï¼ˆ:math:`\\alpha = "
"0`ï¼‰ï¼Œåˆ™å®ƒä»¬ä¹‹é—´æ²¡æœ‰ç›´æ¥è¿æ¥ã€‚"

#: ../../source/EB.rst:442 49b2fe45909a466c8cfa723d1520d500
msgid "Illustration of embedded boundary cutting a two-dimensional cell."
msgstr "åµŒå…¥è¾¹ç•Œåˆ‡å‰²äºŒç»´å•å…ƒçš„ç¤ºæ„å›¾ã€‚"

#: ../../source/EB.rst:446 d26231c0298e48a396c7daad649e4d9f
msgid "|a|"
msgstr "|a|"

#: ../../source/EB.rst:434 3ccf333e62e748719ad70d030ff62dd5
msgid "a"
msgstr "ä¸€ä¸ª"

#: ../../source/EB.rst:446 a171dcf69d3e4650a665eb79b04bcbb6
msgid "|b|"
msgstr "|b|"

#: ../../source/EB.rst:437 5caf6475e79c49bd81f0d6f9034b34f3
msgid "b"
msgstr "b"

#: ../../source/EB.rst 710f09e45b4845b98c6be2bd7c748dc6
msgid "A typical two-dimensional uniform cell that is"
msgstr "ä¸€ä¸ªå…¸å‹çš„äºŒç»´å‡åŒ€å•å…ƒï¼Œå®ƒæ˜¯"

#: ../../source/EB.rst 6e6a654004e641a8ba79116713bc8ed4
msgid "cut by the embedded boundary. The grey area"
msgstr "è¢«åµŒå…¥è¾¹ç•Œåˆ‡å‰²çš„éƒ¨åˆ†ã€‚ç°è‰²åŒºåŸŸã€‚"

#: ../../source/EB.rst 557b5a97e0cf49afaca74b1730cb6cc7
msgid "represents the region excluded from the"
msgstr "ä»£è¡¨è¢«æ’é™¤åœ¨å¤–çš„åœ°åŒº"

#: ../../source/EB.rst d9c261fd67ef4fa097fa0a4b9a31105c
msgid "calculation. The portion of the cell faces"
msgstr "è®¡ç®—ã€‚ç»†èƒè¡¨é¢çš„éƒ¨åˆ†ã€‚"

#: ../../source/EB.rst 36af5b5032024422890526484dd5442e
msgid "faces (labelled with A) through which fluxes"
msgstr "é¢ï¼ˆæ ‡è®°ä¸ºAï¼‰é€šè¿‡å…¶ä¸­çš„é€šé‡ã€‚"

#: ../../source/EB.rst f5639dbade78406eadcad112f75a88ac
msgid "flow are the \"uncovered\" regions of the full"
msgstr "è¿™äº›æ˜¯å®Œæ•´åŒºåŸŸä¸­çš„â€œæœªè¦†ç›–â€éƒ¨åˆ†ã€‚"

#: ../../source/EB.rst 64fbe6c94f7c45afb86ffda2f48d0d4b
msgid "cell faces. The volume (labelled V) is the"
msgstr "ç»†èƒè¡¨é¢ã€‚ä½“ç§¯ï¼ˆæ ‡è®°ä¸ºVï¼‰æ˜¯"

#: ../../source/EB.rst bc8ad109e3f84d8481406e4d90586b7b
msgid "uncovered region of the interior."
msgstr "å†…éƒ¨çš„æœªè¦†ç›–åŒºåŸŸã€‚"

#: ../../source/EB.rst 5f75c92f088c4ec383c94700a7ce8009
msgid "Fluxes in a cut cell."
msgstr "åˆ‡å‰²å•å…ƒä¸­çš„é€šé‡ã€‚"

#: ../../source/EB.rst:464 f4e6a4bae7164298bf4afdd2622bc59f
msgid "Small Cells And Stability"
msgstr "å°å‹èœ‚çªåŸºç«™å’Œç¨³å®šæ€§"

#: ../../source/EB.rst:466 3fb893e993554d39941c2e2ea00ae9f5
msgid ""
"In the context of time-explicit advance methods for, say hyperbolic conservation laws, a naive discretization in time "
"of :eq:`eqn::hypsys` using :eq:`eqn::ebdiv`,"
msgstr "åœ¨å¤„ç†æ—¶é—´æ˜¾å¼æ¨è¿›æ–¹æ³•æ—¶ï¼Œä¾‹å¦‚åŒæ›²å®ˆæ’å¾‹ï¼Œä½¿ç”¨æ–¹ç¨‹ï¼šeq:`eqn::hypsys`çš„æ—¶é—´ç¦»æ•£åŒ–æ–¹æ³•æ˜¯æœ´ç´ çš„ï¼Œåˆ©ç”¨æ–¹ç¨‹ï¼šeq:`eqn::ebdiv`è¿›è¡Œç¦»æ•£åŒ–ã€‚"

#: ../../source/EB.rst:470 40cfb1b13ee84cb6b4d644f7cadd1ea5
msgid ""
"U^{n+1} = U^{n} - \\delta t D^c(F)\n"
"\n"
msgstr "U^{n+1} = U^{n} - \\delta t D^c(F)"

#: ../../source/EB.rst:472 97f8c08e044a4b5a90da2895a9db2404
msgid ""
"would have a time step constraint :math:`\\delta t \\sim h \\kappa^{1/D}/V_m`, which goes to zero as the size of the "
"smallest volume fraction :math:`\\kappa` in the calculation. Since EB volume fractions can be arbitrarily small, this "
"presents an unacceptable constraint. This is the so-called \"small cell problem,\" and AMReX-based applications address "
"it with redistribution methods."
msgstr ""
"åœ¨è®¡ç®—ä¸­ï¼Œä¼šæœ‰ä¸€ä¸ªæ—¶é—´æ­¥é•¿çº¦æŸï¼šmath:`\\delta t \\sim h \\kappa^{1/D}/V_m`ï¼Œå…¶ä¸­ :math:`\\kappa` "
"æ˜¯è®¡ç®—ä¸­æœ€å°ä½“ç§¯åˆ†æ•°çš„å¤§å°ã€‚éšç€EBä½“ç§¯åˆ†æ•°å¯ä»¥ä»»æ„å°ï¼Œè¿™ä¸ªçº¦æŸæ˜¯ä¸å¯æ¥å—çš„ã€‚è¿™å°±æ˜¯æ‰€è°“çš„â€œå°å•å…ƒé—®é¢˜â€ï¼Œè€ŒåŸºäºAMReXçš„åº”ç”¨ç¨‹åºé€šè¿‡é‡æ–°åˆ†é…æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚"

#: ../../source/EB.rst:479 f324da2787b84d4a9b04be4394ed026d
msgid "Flux Redistribution"
msgstr "é€šé‡é‡æ–°åˆ†é…"

#: ../../source/EB.rst:481 50641072ca164b188651765f0205a9cd
msgid "Consider a conservative update in the form:"
msgstr "è¯·è€ƒè™‘ä»¥ä¿å®ˆæ–¹å¼è¿›è¡Œæ›´æ–°ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š"

#: ../../source/EB.rst:483 4e6e777855324c50a92ec48684429bdc
msgid ""
"(\\rho \\phi)_t + \\n"
"abla \\cdot ( \\rho \\phi u) = RHS\n"
"\n"
msgstr "ï¼ˆÏÏ†ï¼‰_t + âˆ‡ Â· (ÏÏ†u) = RHS"

#: ../../source/EB.rst:485 c921c5d0ab714566831987bcb210c66a
msgid ""
"For each valid cell in the domain, compute the conservative divergence, :math:`(\\n"
"abla \\cdot F)^c` , of the convective fluxes, :math:`F`"
msgstr ""
"å¯¹äºå®šä¹‰åŸŸä¸­çš„æ¯ä¸ªæœ‰æ•ˆå•å…ƒæ ¼ï¼Œè®¡ç®—ä¼ è¾“é€šé‡çš„ä¿å®ˆæ•£åº¦ :math:`(\\n"
"abla \\cdot F)^c`ï¼Œå…¶ä¸­ :math:`F` æ˜¯å¯¹æµé€šé‡ã€‚"

#: ../../source/EB.rst:488 90a6bc80b1c04e9f8f30976b680f0d69
msgid ""
"(\\n"
"abla \\cdot {F})^c_i = \\dfrac{1}{\\mathcal{V}_i} \\sum_{f=1}^{N_f} ({F}_f\\cdot{n}_f) A_f\n"
"\n"
msgstr "ï¼ˆâˆ‡ Â· Fï¼‰^c_i = 1/ğ’±_i âˆ‘_{f=1}^{N_f} (F_f Â· n_f) A_f"

#: ../../source/EB.rst:490 1f68b23371c14dc5af40322a8480cd70
msgid ""
"Here :math:`N_f` is the number of faces of cell :math:`i`, :math:`\\vec{n}_f` and :math:`A_f` are the unit normal and "
"area of the :math:`f` -th face respectively, and :math:`\\mathcal{V}_i` is the volume of cell :math:`i` given by"
msgstr ""
"è¿™é‡Œ :math:`N_f` æ˜¯å•å…ƒ :math:`i` çš„é¢æ•°ï¼Œ:math:`\\vec{n}_f` å’Œ :math:`A_f` åˆ†åˆ«æ˜¯ç¬¬ :math:`f` ä¸ªé¢çš„å•ä½æ³•å‘é‡å’Œé¢ç§¯ï¼Œè€Œ :math:`\\mathcal{V}_i` "
"æ˜¯å•å…ƒ :math:`i` çš„ä½“ç§¯ï¼Œç”±ä»¥ä¸‹å…¬å¼ç»™å‡ºï¼š"

#: ../../source/EB.rst:494 5f07dcc38fbb48f2b44a47742659e109
msgid ""
"\\mathcal{V}_i = (\\Delta x \\Delta y \\Delta z)\\cdot \\mathcal{K}_i\n"
"\n"
msgstr "\\mathcal{V}_i = (\\Delta x \\Delta y \\Delta z)\\cdot \\mathcal{K}_i"

#: ../../source/EB.rst:496 0718acc0cff64c018461c2a19887739a
msgid "where :math:`\\mathcal{K}_i` is the volume fraction of cell :math:`i` ."
msgstr "å…¶ä¸­ :math:`\\mathcal{K}_i` è¡¨ç¤ºç»†èƒ :math:`i` çš„ä½“ç§¯åˆ†æ•°ã€‚"

#: ../../source/EB.rst:498 6f6d4710a74749519754b18870ef4ca7
msgid "Now, a conservative update can be written as"
msgstr "ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¿å®ˆçš„æ›´æ–°å†™æˆè¿™æ ·ã€‚"

#: ../../source/EB.rst:500 57979b6760484181a94396f9dd1ad47d
msgid ""
"\\frac{ \\rho^{n+1} \\phi^{n+1} - \\rho^{n} \\phi^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^c\n"
"\n"
msgstr ""
"æ ¹æ®æ‚¨çš„è¦æ±‚ï¼Œæˆ‘å°†ä¸ºæ‚¨ç¿»è¯‘è¿™æ¡å…¬å¼ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä¼šä¿ç•™åŸå§‹çš„æ ¼å¼ï¼Œä¸ä¼šè§£é‡Šä»»ä½•æ¦‚å¿µï¼Œåªæä¾›ç¿»è¯‘ã€‚\n"
"\n"
"\\frac{ \\rho^{n+1} \\phi^{n+1} - \\rho^{n} \\phi^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^c\n"
"\n"
"Translated into Simplified Chinese:\n"
"\n"
"\\frac{ \\rho^{n+1} \\phi^{n+1} - \\rho^{n} \\phi^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^c"

#: ../../source/EB.rst:502 1d8f78cfee3f4c16bd2884e4eda86aa8
msgid ""
"For each cell cut by the EB geometry, compute the non-conservative update, :math:`\\n"
"abla \\cdot {F}^{nc}` ,"
msgstr ""
"å¯¹äºç”±EBå‡ ä½•åˆ‡å‰²çš„æ¯ä¸ªå•å…ƒæ ¼ï¼Œè®¡ç®—éå®ˆæ’æ›´æ–°é¡¹ :math:`\\n"
"abla \\cdot {F}^{nc}`ã€‚"

#: ../../source/EB.rst:504 6f7ed9ee7a064076afa38595cae94698
msgid ""
"\\n"
"abla\\cdot{F}^{nc}_i = \\dfrac{\\sum\\limits_{j\\in N(i) } \\mathcal{K}_j\\n"
"abla \\cdot {F}^c_j} {\\sum\\limits_{j\\in N(i) } {\\mathcal{K}}_j}\n"
"\n"
msgstr ""
"$\\n"
"abla\\cdot{F}^{nc}_i = \\dfrac{\\sum\\limits_{j\\in N(i) } \\mathcal{K}_j\\n"
"abla \\cdot {F}^c_j} {\\sum\\limits_{j\\in N(i) } {\\mathcal{K}}_j}$"

#: ../../source/EB.rst:506 d5e4e49b33474a5b8203f9fcb7e78795
msgid "where :math:`N(i)` is the index set of cell :math:`i` and its neighbors."
msgstr "å…¶ä¸­ :math:`N(i)` æ˜¯ç»†èƒ :math:`i` åŠå…¶é‚»å±…çš„ç´¢å¼•é›†åˆã€‚"

#: ../../source/EB.rst:508 7d224281b2c042fea163f4f46775e04d
msgid ""
"For each cell cut by the EB geometry, compute the convective update :math:`\\n"
"abla \\cdot{F}^{EB}` follows:"
msgstr ""
"å¯¹äºç”±EBå‡ ä½•åˆ‡å‰²çš„æ¯ä¸ªå•å…ƒæ ¼ï¼Œè®¡ç®—å¯¹æµæ›´æ–°é¡¹ :math:`\\n"
"abla \\cdot{F}^{EB}` å¦‚ä¸‹ï¼š"

#: ../../source/EB.rst:510 d8671f74c2654be691fc4aba6ec27f25
msgid ""
"\\n"
"abla \\cdot{F}^{EB}_i = \\mathcal{K}_i\\n"
"abla \\cdot{F}^{c}_i +(1-\\mathcal{K}_i) \\n"
"abla \\cdot \\mathcal{F}^{nc}_i\n"
"\n"
msgstr "âˆ‡ Â· F^(EB)_i = ğ’¦_iâˆ‡ Â· F^c_i + (1-ğ’¦_i) âˆ‡ Â· ğ’¢^(nc)_i"

#: ../../source/EB.rst:512 d238529f02764a91b6c69d945bdf4b68
msgid "For each cell cut by the EB geometry, redistribute its mass loss, :math:`\\delta M_i` , to its neighbors:"
msgstr "å¯¹äºç”±EBå‡ ä½•å›¾å½¢åˆ‡å‰²çš„æ¯ä¸ªå•å…ƒæ ¼ï¼Œå°†å…¶è´¨é‡æŸå¤± :math:`\\delta M_i` é‡æ–°åˆ†é…ç»™å…¶ç›¸é‚»å•å…ƒæ ¼ï¼š"

#: ../../source/EB.rst:514 bcaf3b6cb611498b8172b9541a5385ff
msgid ""
"\\n"
"abla \\cdot {F}^{EB}_j :=   \\n"
"abla \\cdot {F}^{EB}_j + w_{ij}\\delta M_i\\, \\qquad \\forall j\\in N(i)\\setminus i\n"
"\n"
msgstr "å¯¹äºæ‰€æœ‰çš„ jâˆˆN(i)\\setminus iï¼Œå®šä¹‰ nabla dot F^EB_j ä¸º nabla dot F^EB_j + w_ij * delta M_iã€‚"

#: ../../source/EB.rst:516 1212152316df4e9485d4a6544d8fe081
msgid "where the mass loss in cell :math:`i` , :math:`\\delta M_i` , is given by"
msgstr "åœ¨å•å…ƒæ ¼ :math:`i` ä¸­ï¼Œè´¨é‡æŸå¤± :math:`\\delta M_i` çš„è¡¨è¾¾å¼å¦‚ä¸‹ï¼š"

#: ../../source/EB.rst:518 82960a1fd3bc434b8dce8cef07004e30
msgid ""
"\\delta M_i =  \\mathcal{K}_i(1- \\mathcal{K}_i)[ \\n"
"abla \\cdot {F}^c_i-  \\n"
"abla \\cdot {F}^{nc}_i]\n"
"\n"
msgstr "Î´Máµ¢ = ğ’¦áµ¢(1 - ğ’¦áµ¢)[âˆ‡ Â· Fá¶œáµ¢ - âˆ‡ Â· Fâ¿á¶œáµ¢]"

#: ../../source/EB.rst:520 bd899748b9b143faafe01e7c5f77524a
msgid "and the weights, :math:`w_{ij}` , are"
msgstr "è€Œæƒé‡ï¼Œ:math:`w_{ij}`ï¼Œæ˜¯"

#: ../../source/EB.rst:522 03d3840a34df4ed0bc856088f2149279
msgid ""
"w_{ij} = \\dfrac{1}{\\sum\\limits_{j\\in N(i)\\setminus i}  \\mathcal{K}_j}\n"
"\n"
msgstr "w_{ij} = \\dfrac{1}{\\sum\\limits_{j\\in N(i)\\setminus i}  \\mathcal{K}_j}"

#: ../../source/EB.rst:524 f8e3a759851942328cfe07543d795d4c
msgid ""
"Note that :math:`\\n"
"abla \\cdot{F}_i^{EB}` gives an update for :math:`\\rho \\phi` ; i.e.,"
msgstr ""
"è¯·æ³¨æ„ï¼Œ:math:`\\n"
"abla \\cdot{F}_i^{EB}` å¯¹äº :math:`\\rho \\phi` è¿›è¡Œæ›´æ–°ï¼›å³ï¼Œ"

#: ../../source/EB.rst:526 416ab09c1c9c4c7ebee3c9da10d64c4e
msgid ""
"\\frac{(\\rho \\phi_i)^{n+1} - (\\rho \\phi_i)^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^{EB}_i\n"
"\n"
msgstr ""
"\\frac{(\\rho \\phi_i)^{n+1} - (\\rho \\phi_i)^{n} }{\\Delta t} = - \\n"
"abla \\cdot{F}^{EB}_i"

#: ../../source/EB.rst:528 3e917e938f544c829c60d4b9aa558f56
msgid ""
"Typically, the redistribution neighborhood for each cell is one that can be reached via a monotonic path in each "
"coordinate direction of unit length (see, e.g., :numref:`fig::redistribution`)"
msgstr "é€šå¸¸æƒ…å†µä¸‹ï¼Œæ¯ä¸ªå•å…ƒæ ¼çš„é‡æ–°åˆ†é…é‚»åŸŸæ˜¯é€šè¿‡æ¯ä¸ªåæ ‡æ–¹å‘ä¸Šçš„å•è°ƒè·¯å¾„ä»¥å•ä½é•¿åº¦åˆ°è¾¾çš„ï¼ˆå‚è§ï¼Œä¾‹å¦‚ï¼Œ:numref:`fig::redistribution`ï¼‰ã€‚"

#: ../../source/EB.rst:541 a34358fab8ac404ca7c36b1f76ceb90a
msgid ": Redistribution illustration. Excess update distributed to neighbor cells."
msgstr "å†åˆ†é…è¯´æ˜ã€‚å¤šä½™çš„æ›´æ–°åˆ†å‘ç»™ç›¸é‚»å•å…ƒã€‚"

#: ../../source/EB.rst:549 63f87334723d4184bcbd471b23341949
msgid "State Redistribution"
msgstr "å›½å®¶å†åˆ†é…"

#: ../../source/EB.rst:551 1ca1c8d93a56444f9bc6912ad1e9f188
msgid ""
"For state redistribution we implement the weighted state redistribution algorithm as described in Guiliani et al "
"(2021), which is available on `arxiv  <https://arxiv.org/abs/2112.12360>`_ . This is an extension of the original state "
"redistribution algorithm of Berger and Guiliani (2020)."
msgstr ""
"ä¸ºäº†è¿›è¡ŒçŠ¶æ€é‡åˆ†é…ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†Guilianiç­‰äººï¼ˆ2021ï¼‰åœ¨`arxiv <https://arxiv.org/abs/2112.12360>`_ "
"ä¸Šæè¿°çš„åŠ æƒçŠ¶æ€é‡åˆ†é…ç®—æ³•ã€‚è¿™æ˜¯Bergerå’ŒGuilianiï¼ˆ2020ï¼‰åŸå§‹çŠ¶æ€é‡åˆ†é…ç®—æ³•çš„æ‰©å±•ã€‚"

#: ../../source/EB.rst:559 c4d45cb197664f3d81f46bf518de3177
msgid "Linear Solvers"
msgstr "çº¿æ€§æ±‚è§£å™¨"

#: ../../source/EB.rst:561 90dc58c2d23546b1aa3040abe10bcaf6
msgid ""
"Linear solvers for the canonical form (equation :eq:`eqn::abeclap`) have been discussed in chapter "
":ref:`Chap:LinearSolvers`."
msgstr "åœ¨ç¬¬ :ref:`Chap:LinearSolvers` ç« ä¸­å·²ç»è®¨è®ºäº†ç”¨äºæ ‡å‡†å½¢å¼æ–¹ç¨‹ï¼ˆæ–¹ç¨‹ :eq:`eqn::abeclap`ï¼‰çš„çº¿æ€§æ±‚è§£å™¨ã€‚"

#: ../../source/EB.rst:564 6bf188aebabf42bab569e5a34436d72f
msgid ""
"AMReX supports multi-level 1) cell-centered solvers with homogeneous Neumann, homogeneous Dirichlet, or inhomogeneous "
"Dirichlet boundary conditions on the EB faces, and 2) nodal solvers with homogeneous Neumann boundary conditions, or "
"inflow velocity conditions on the EB faces."
msgstr "AMReXæ”¯æŒå¤šå±‚æ¬¡çš„1) ä»¥å•å…ƒä¸ºä¸­å¿ƒçš„æ±‚è§£å™¨ï¼Œå…¶è¾¹ç•Œæ¡ä»¶å¯ä»¥æ˜¯å‡åŒ€è¯ºä¾æ›¼ã€å‡åŒ€è¿ªé‡Œå¸Œé›·æˆ–éå‡åŒ€è¿ªé‡Œå¸Œé›·æ¡ä»¶ï¼Œå¹¶ä¸”åº”ç”¨äºEBé¢ï¼›ä»¥åŠ2) ä»¥èŠ‚ç‚¹ä¸ºä¸­å¿ƒçš„æ±‚è§£å™¨ï¼Œå…¶è¾¹ç•Œæ¡ä»¶å¯ä»¥æ˜¯å‡åŒ€è¯ºä¾æ›¼æ¡ä»¶æˆ–EBé¢ä¸Šçš„å…¥æµé€Ÿåº¦æ¡ä»¶ã€‚"

#: ../../source/EB.rst:570 82ea27d805f14ba8b181ecb080b41ecc
msgid ""
"To use a cell-centered solver with EB, one builds a linear operator :cpp:`MLEBABecLap` with :cpp:`EBFArrayBoxFactory` "
"(instead of a :cpp:`MLABecLaplacian`)"
msgstr "ä½¿ç”¨åŸºäºå•å…ƒæ ¼çš„æ±‚è§£å™¨ä¸EBï¼ˆEmbedded Boundaryï¼‰ä¸€èµ·ï¼Œéœ€è¦ä½¿ç”¨`EBFArrayBoxFactory`ï¼ˆè€Œä¸æ˜¯`MLABecLaplacian`ï¼‰æ„å»ºä¸€ä¸ªçº¿æ€§ç®—å­`:cpp:`MLEBABecLap`ã€‚"

#: ../../source/EB.rst:583 185134008184430b8db9f38c0fc9df06
msgid "The usage of this EB-specific class is essentially the same as :cpp:`MLABecLaplacian`."
msgstr "è¿™ä¸ªç‰¹å®šäºEBçš„ç±»çš„ä½¿ç”¨æ–¹æ³•åŸºæœ¬ä¸Šä¸ `MLABecLaplacian` ç±»ç›¸åŒã€‚"

#: ../../source/EB.rst:586 dfa568f9c25b499182db01b43f1adecd
msgid "The default boundary condition on EB faces is homogeneous Neumann."
msgstr "EBé¢çš„é»˜è®¤è¾¹ç•Œæ¡ä»¶æ˜¯é½æ¬¡è¯ºä¾æ›¼ã€‚"

#: ../../source/EB.rst:588 11aae1dbdf8446d481fde2b7b58555ed
msgid "To set homogeneous Dirichlet boundary conditions, call"
msgstr "è¦è®¾ç½®é½æ¬¡è¿ªé‡Œåˆ‡ç‰¹è¾¹ç•Œæ¡ä»¶ï¼Œè¯·è°ƒç”¨"

#: ../../source/EB.rst:596 ebce04adf19a48acb2570827e912dad1
msgid ""
"where coeff can be a real number (i.e. the value is the same at every cell) or is the MultiFab holding the coefficient "
"of the gradient at each cell with an EB face."
msgstr "å…¶ä¸­coeffå¯ä»¥æ˜¯ä¸€ä¸ªå®æ•°ï¼ˆå³åœ¨æ¯ä¸ªå•å…ƒæ ¼ä¸­çš„å€¼ç›¸åŒï¼‰ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªMultiFabï¼Œå…¶ä¸­åŒ…å«æ¯ä¸ªå•å…ƒæ ¼çš„æ¢¯åº¦ç³»æ•°å’ŒEBé¢ã€‚"

#: ../../source/EB.rst:599 ede12b19cb46457faa9cf9dda49471b5
msgid "To set inhomogeneous Dirichlet boundary conditions, call"
msgstr "è¦è®¾ç½®ä¸å‡åŒ€çš„Dirichletè¾¹ç•Œæ¡ä»¶ï¼Œè¯·è°ƒç”¨"

#: ../../source/EB.rst:607 95f512d2a7114ca5924dbeae64ecef37
msgid ""
"where phi_on_eb is the MultiFab holding the Dirichlet values in every cut cell, and coeff again is a real number (i.e. "
"the value is the same at every cell) or a MultiFab holding the coefficient of the gradient at each cell with an EB face."
msgstr "phi_on_eb æ˜¯ä¸€ä¸ª MultiFabï¼Œå…¶ä¸­åŒ…å«æ¯ä¸ªåˆ‡å‰²å•å…ƒçš„è¿ªé‡Œåˆ‡ç‰¹å€¼ã€‚coeff æ˜¯ä¸€ä¸ªå®æ•°ï¼ˆå³æ¯ä¸ªå•å…ƒçš„å€¼ç›¸åŒï¼‰ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ª MultiFabï¼Œå…¶ä¸­åŒ…å«æ¯ä¸ªå•å…ƒçš„æ¢¯åº¦ç³»æ•°å’Œ EB é¢ã€‚"

#: ../../source/EB.rst:611 5139ec7908794717abb85a62e5b21c01
msgid ""
"Currently there are options to define the face-based coefficients on face centers vs face centroids, and to interpret "
"the solution variable as being defined on cell centers vs cell centroids."
msgstr "ç›®å‰æœ‰é€‰æ‹©åœ¨é¢ä¸­å¿ƒå’Œé¢è´¨å¿ƒå®šä¹‰åŸºäºé¢çš„ç³»æ•°ï¼Œä»¥åŠå°†è§£å˜é‡è§£é‡Šä¸ºåœ¨å•å…ƒä¸­å¿ƒå’Œå•å…ƒè´¨å¿ƒå®šä¹‰çš„é€‰é¡¹ã€‚"

#: ../../source/EB.rst:615 a384e80ee46f4283826886179d952cc2
msgid ""
"The default is for the solution variable to be defined at cell centers; to tell the solver to interpret the solution "
"variable as living at cell centroids, you must set"
msgstr "é»˜è®¤æƒ…å†µä¸‹ï¼Œè§£å˜é‡è¢«å®šä¹‰åœ¨å•å…ƒæ ¼ä¸­å¿ƒï¼›è¦å‘Šè¯‰æ±‚è§£å™¨å°†è§£å˜é‡è§£é‡Šä¸ºä½äºå•å…ƒæ ¼è´¨å¿ƒï¼Œæ‚¨å¿…é¡»è®¾ç½®"

#: ../../source/EB.rst:625 c8a1bf01670b45639fd978d54cd21715
msgid ""
"The default is for the face-based coefficients to be defined at face centers; to tell the that the face-based "
"coefficients should be interpreted as living at face centroids, modify the setBCoeffs command to be"
msgstr "é»˜è®¤æƒ…å†µä¸‹ï¼ŒåŸºäºé¢çš„ç³»æ•°è¢«å®šä¹‰åœ¨é¢çš„ä¸­å¿ƒä½ç½®ï¼›è‹¥è¦æŒ‡ç¤ºåŸºäºé¢çš„ç³»æ•°åº”è¢«è§£é‡Šä¸ºä½äºé¢çš„è´¨å¿ƒä½ç½®ï¼Œè¯·ä¿®æ”¹setBCoeffså‘½ä»¤ä¸ºï¼š"

#: ../../source/EB.rst:636 3e25fdc12d054bbfb7f3e40d04abaae8
msgid "Tutorials"
msgstr "æ•™ç¨‹"

#: ../../source/EB.rst:638 92e04fbebf34416c8a68b283cc219adf
msgid "`EB/CNS`_ is an AMR code for solving compressible Navier-Stokes equations with the embedded boundary approach."
msgstr "`EB/CNS`_ æ˜¯ä¸€ç§ä½¿ç”¨åµŒå…¥è¾¹ç•Œæ–¹æ³•æ±‚è§£å¯å‹ç¼©Navier-Stokesæ–¹ç¨‹çš„AMRï¼ˆè‡ªé€‚åº”ç½‘æ ¼ç»†åŒ–ï¼‰ä»£ç ã€‚"

#: ../../source/EB.rst:641 2693e1dd3b08404d872850715783b0af
msgid ""
"`EB/Poisson`_ is a single-level code that is a proxy for solving the electrostatic Poisson equation for a grounded "
"sphere with a point charge inside."
msgstr "`EB/Poisson`_ æ˜¯ä¸€ä¸ªå•å±‚ä»£ç ï¼Œç”¨äºæ±‚è§£å¸¦æœ‰ä¸€ä¸ªç‚¹ç”µè·çš„æ¥åœ°çƒçš„é™ç”µæ³Šæ¾æ–¹ç¨‹çš„ä»£ç†ã€‚"

#: ../../source/EB.rst:645 a2dc8f12e4464eaab0bd85a86b100b6f
msgid ""
"`EB/MacProj`_ is a single-level code that computes a divergence-free flow field around a sphere.  A MAC projection is "
"performed on an initial velocity field of (1,0,0)."
msgstr "`EB/MacProj`_ æ˜¯ä¸€ä¸ªå•å±‚ä»£ç ï¼Œç”¨äºè®¡ç®—å›´ç»•çƒä½“çš„æ— æ•£æµåœºã€‚å¯¹ä¸€ä¸ªåˆå§‹é€Ÿåº¦åœº (1,0,0) è¿›è¡Œäº† MAC æŠ•å½±ã€‚"
