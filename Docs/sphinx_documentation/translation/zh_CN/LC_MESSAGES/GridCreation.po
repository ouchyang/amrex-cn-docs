# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/GridCreation.rst:10 b3c056f33e314c00a6d1888bcd2f0102
msgid "Grid Creation"
msgstr "网格创建"

#: ../../source/GridCreation.rst:12 62560f8f22e34d4ca4766d21baeb05fe
msgid ""
"To run an AMReX-based application you must specify the domain size by specifying :cpp:`n_cell` -- this is the number of "
"cells spanning the domain in each coordinate direction at level 0."
msgstr "要运行基于AMReX的应用程序，您必须通过指定:cpp:`n_cell`来指定域的大小 - 这是在每个坐标方向上跨越域的单元格数，位于0级别。"

#: ../../source/GridCreation.rst:16 a6f86eaebe764015b9cf68052128cc8a
msgid ""
"Users often specify :cpp:`max_grid_size` as well. The default load balancing algorithm then divides the domain in every "
"direction so that each grid is no longer than :cpp:`max_grid_size` in that direction. If not specified by the user, "
":cpp:`max_grid_size` defaults to 128 in 2D and 32 in 3D (in each coordinate direction)."
msgstr ""
"用户通常还会指定 `max_grid_size`。默认的负载平衡算法会根据指定的 `max_grid_size` 在每个方向上划分域，以确保每个网格在该方向上的长度不超过 "
"`max_grid_size`。如果用户没有指定，`max_grid_size` 在二维情况下默认为128，在三维情况下默认为32（在每个坐标方向上）。"

#: ../../source/GridCreation.rst:20 cd12a9bf8048491d9823a67b999cc06c
msgid ""
"Another popular input is :cpp:`blocking_factor`.  The value of :cpp:`blocking_factor` constrains grid creation in that "
"in that each grid must be divisible by :cpp:`blocking_factor`. Note that both the domain (at each level) and "
":cpp:`max_grid_size` must be divisible by :cpp:`blocking_factor`, and that :cpp:`blocking_factor` must be either 1 or a "
"power of 2 (otherwise the gridding algorithm would not in fact create grids divisible by  :cpp:`blocking_factor` "
"because of how  :cpp:`blocking_factor` is used in the gridding algorithm)."
msgstr ""
"另一个常用的输入是 `blocking_factor`。`blocking_factor` 的值限制了网格的创建，每个网格必须能被 `blocking_factor` 整除。请注意，无论是域（每个层级）还是 `max_grid_size` "
"都必须能被 `blocking_factor` 整除，并且 `blocking_factor` 必须是1或2的幂次方（否则，由于 `blocking_factor` 在网格算法中的使用方式，网格算法实际上无法创建能被 "
"`blocking_factor` 整除的网格）。"

#: ../../source/GridCreation.rst:27 34f87fee689a48488adb5a3ddced744e
msgid ""
"If not specified by the user, :cpp:`blocking_factor` defaults to 8 in each coordinate direction. The typical purpose of "
":cpp:`blocking_factor` is to ensure that the grids will be sufficiently coarsenable for good multigrid performance."
msgstr "如果用户没有指定，`:cpp:`blocking_factor`在每个坐标方向上默认为8。`:cpp:`blocking_factor`的典型目的是确保网格在多重网格性能良好的情况下可以足够粗化。"

#: ../../source/GridCreation.rst:31 467fa7e9cc8741969af50cf69ff1cb56
msgid ""
"There is one more default behavior to be aware of.  There is a boolean :cpp:`refine_grid_layout` that defaults to true "
"but can be over-ridden at run-time. If :cpp:`refine_grid_layout` is true and the number of grids created is less than "
"the number of processors (Ngrids < Nprocs), then grids will be further subdivided until Ngrids >= Nprocs."
msgstr ""
"还有一个默认行为需要注意。有一个布尔值变量 `refine_grid_layout`，默认为 `true`，但可以在运行时进行覆盖。如果 `refine_grid_layout` 为 "
"`true`，且创建的网格数量小于处理器数量（Ngrids < Nprocs），则会进一步细分网格，直到 Ngrids >= Nprocs。"

#: ../../source/GridCreation.rst:36 6cdc171230f54a0e8255efd2f3dd5129
msgid ""
"Caveat: if subdividing the grids to achieve Ngrids >= Nprocs would violate the :cpp:`blocking_factor` criterion then "
"additional grids are not created and the number of grids will remain less than the number of processors"
msgstr "注意：如果将网格细分以实现 Ngrids >= Nprocs 会违反 blocking_factor 的条件，则不会创建额外的网格，网格的数量将保持小于处理器的数量。"

#: ../../source/GridCreation.rst:40 a1808405dd9e4230986633d165fa8443
msgid "Note that :cpp:`n_cell` must be given as three separate integers, one for each coordinate direction."
msgstr "请注意：cpp中的`n_cell`必须以三个独立的整数形式提供，分别表示每个坐标方向上的值。"

#: ../../source/GridCreation.rst:42 d5a376c5af53426d8e8d6a6018e48642
msgid ""
"However, :cpp:`max_grid_size` and :cpp:`blocking_factor` can be specified as a single value applying to all coordinate "
"directions, or as separate values for each direction."
msgstr "然而，:cpp:`max_grid_size` 和 :cpp:`blocking_factor` 可以作为适用于所有坐标方向的单个值进行指定，也可以作为每个方向的单独值进行指定。"

#: ../../source/GridCreation.rst:45 103a46a4a0a448b6a6eb92f172ddf92a
msgid ""
"If :cpp:`max_grid_size` (or :cpp:`blocking_factor`) is specified as multiple integers then the first integer applies to "
"level 0, the second to level 1, etc.  If you don't specify as many integers as there are levels, the final value will "
"be used for the remaining levels."
msgstr "如果 `max_grid_size`（或 `blocking_factor`）被指定为多个整数，则第一个整数适用于级别 0，第二个整数适用于级别 1，依此类推。如果您没有指定与级别数量相等的整数，则最后一个值将用于剩余的级别。"

#: ../../source/GridCreation.rst:49 9c225873c6a14b69933ed60495c9c8cf
msgid ""
"If different values of :cpp:`max_grid_size` (or :cpp:`blocking_factor`) are wanted for each coordinate direction, then "
":cpp:`max_grid_size_x`, :cpp:`max_grid_size_y` and :cpp:`max_grid_size_z` (or :cpp:`blocking_factor_x`, "
":cpp:`blocking_factor_y` and :cpp:`blocking_factor_z`) must be used. If you don't specify as many integers as there are "
"levels, the final value will be used for the remaining levels."
msgstr ""
"如果希望每个坐标方向使用不同的 `max_grid_size`（或 `blocking_factor`）值，则必须使用 `max_grid_size_x`、`max_grid_size_y` 和 `max_grid_size_z`（或 "
"`blocking_factor_x`、`blocking_factor_y` 和 `blocking_factor_z`）。如果您没有指定与级别数量相同的整数，则最后一个值将用于剩余的级别。"

#: ../../source/GridCreation.rst:54 2d7bb94526154657a9911cd9f4e94291
msgid "Additional notes:"
msgstr ""
"Thank you for the additional notes. I will keep them in mind while translating your incoming ENGLISH messages into "
"SIMPLIFIED CHINESE. Please feel free to send your messages for translation."

#: ../../source/GridCreation.rst:56 c29462c3ff874f51ac04daf98464f5bc
msgid ""
"To create identical grids of a specific size, e.g. of length *m* in each direction, then set :cpp:`max_grid_size` = *m* "
"and :cpp:`blocking_factor` = *m*."
msgstr "要创建具有特定大小的相同网格，例如在每个方向上长度为*m*，然后设置:cpp:`max_grid_size` = *m*和:cpp:`blocking_factor` = *m*。"

#: ../../source/GridCreation.rst:59 c42082810348448fbfe8813bee843e72
msgid ""
"Note that :cpp:`max_grid_size` is just an upper bound; with :cpp:`n_cell = 48` and :cpp:`max_grid_size = 32`, we will "
"typically have one grid of length 32 and one of length 16."
msgstr "请注意：`max_grid_size`仅为一个上限；当`n_cell = 48`且`max_grid_size = 32`时，通常会有一个长度为32的网格和一个长度为16的网格。"

#: ../../source/GridCreation.rst:62 9d19dbac38554bfb9733bf7e82afcc36
msgid "The grid creation process at level 0 proceeds as follows (if not using the KD-tree approach):"
msgstr "如果不使用KD树方法，级别0的网格创建过程如下所示："

#: ../../source/GridCreation.rst:64 d4e692cbe4444d29b459e5893744a933
msgid "The domain is initially defined by a single grid of size :cpp:`n_cell`."
msgstr "该域最初由一个大小为 `n_cell` 的单一网格定义。"

#: ../../source/GridCreation.rst:66 325f6a74a08445fba3436b033ffede30
msgid ""
"If :cpp:`n_cell` is greater than :cpp:`max_grid_size` then the grids are subdivided until each grid is no longer than  "
":cpp:`max_grid_size` cells on each side.  The :cpp:`blocking_factor` criterion (ie that the length of each side of each "
"grid is divisible by :cpp:`blocking_factor` in that direction) is satisfied during this process."
msgstr ""
"如果 `n_cell` 大于 `max_grid_size`，则将网格细分，直到每个网格的每边的单元数不超过 `max_grid_size`。在此过程中，满足 `blocking_factor` 准则（即每个网格的每个方向的边长可被 "
"`blocking_factor` 整除）。"

#: ../../source/GridCreation.rst:71 fd129c39c06f4acaa3c9bbfbf3c7048c
msgid ""
"Next, if :cpp:`refine_grid_layout = true` and there are more processors than grids at this level, then the grids at "
"this level are further divided until Ngrids >= Nprocs (unless doing so would violate the :cpp:`blocking_factor` "
"criterion)."
msgstr ""
"如果 `refine_grid_layout = true`，并且在这个层级上处理器的数量多于网格的数量，那么会进一步划分这个层级上的网格，直到 Ngrids >= Nprocs（除非这样做会违反 `blocking_factor` "
"的条件）。"

#: ../../source/GridCreation.rst:75 c451209ded384ab9ae4ceb8c5daada5d
msgid ""
"The creation of grids at levels > 0 begins by tagging cells at the coarser level and follows the Berger-Rigoutsos "
"clustering algorithm with the additional constraints of satisfying the :cpp:`blocking_factor` and :cpp:`max_grid_size` "
"criteria.  An additional parameter becomes relevant here: the \"grid efficiency\", specified as :cpp:`amr.grid_eff` in "
"the inputs file. This threshold value, which defaults to 0.7 (or 70%), is used to ensure that grids do not contain too "
"large a fraction of un-tagged cells.   We note that the grid creation process attempts to satisfy the "
":cpp:`amr.grid_eff` constraint but will not do so if it means violating the :cpp:`blocking_factor` criterion."
msgstr ""
"在级别大于0的情况下，网格的创建始于对较粗级别的单元进行标记，并遵循Berger-Rigoutsos聚类算法，同时满足cpp:`blocking_factor`和cpp:`max_grid_size`"
"的约束条件。在这里，还涉及到一个额外的参数：网格效率，该参数在输入文件中以cpp:`amr.grid_eff`的形式进行指定。默认情况下，该阈值为0.7（或70%"
"），用于确保网格不包含过大比例的未标记单元。需要注意的是，网格创建过程会尽力满足cpp:`amr.grid_eff`的约束条件，但如果违反cpp:`blocking_factor`的准则，则不会这样做。"

#: ../../source/GridCreation.rst:84 fae97b2200434bd99ec09615d4fedf2b
msgid ""
"Users often like to ensure that coarse/fine boundaries are not too close to tagged cells; the way to do this is to set "
":cpp:`amr.n_error_buf` to a large integer value (the default is 1). This parameter is used to increase the number of "
"tagged cells before the grids are defined; if cell \"*(i,j,k)*\" satisfies the tagging criteria, then, for example, if "
":cpp:`amr.n_error_buf` is 3, all cells in the 7x7x7 box from lower corner \"*(i-3,j-3,k-3)*\" to \"*(i+3,j+3,k+3)*\" "
"will be tagged."
msgstr ""
"用户通常喜欢确保粗细边界与标记单元之间的距离不要太近；实现这一点的方法是将 `amr.n_error_buf` 设置为一个较大的整数值（默认值为1）。该参数用于在定义网格之前增加标记单元的数量；例如，如果单元格 \"*(i,j,k)*\" "
"满足标记条件，并且 `amr.n_error_buf` 设置为3，则从较低角落 \"*(i-3,j-3,k-3)*\" 到 \"*(i+3,j+3,k+3)*\" 的 7x7x7 盒子中的所有单元格都将被标记。"
