# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/AmrCore.rst:28 0dfc472a23c24eec8112f36a0e97c964
msgid ""
"Time sequence (:math:`t=0,0.5,1,1.5,2` s) of advection of a Gaussian "
"profile using the SingleVortex tutorial. The analytic velocity field "
"distorts the profile, and then restores the profile to the original "
"configuration.  The red, green, and blue boxes indicate grids at AMR "
"levels :math:`\\ell=0,1`, and :math:`2`."
msgstr ""

#: ../../source/AmrCore.rst:32 93c248140f6046df94dc0fd59747b38e
msgid "|a|"
msgstr ""

#: ../../source/AmrCore.rst:11 187ed74f3eb343c6bf32f9a4cb244ae4
msgid "a"
msgstr ""

#: ../../source/AmrCore.rst:32 eb3d7dcf267e4cb4a91cae7a3d832506
msgid "|b|"
msgstr ""

#: ../../source/AmrCore.rst:14 3d2a1e034b624116a5ceacdfedeaa3e4
msgid "b"
msgstr ""

#: ../../source/AmrCore.rst:32 776dd8cc94614e5bb964fc47264984a5
msgid "|c|"
msgstr ""

#: ../../source/AmrCore.rst:17 8a47a61a0e18465c91c5836c727d99ad
msgid "c"
msgstr ""

#: ../../source/AmrCore.rst:32 b7550308420a43c89f90914d9afa5fd2
msgid "|d|"
msgstr ""

#: ../../source/AmrCore.rst:20 cbd743acda454cc580c3a4a3aaf07ffa
msgid "d"
msgstr ""

#: ../../source/AmrCore.rst:32 953d83cf75154decb70f48b61df09f1a
msgid "|e|"
msgstr ""

#: ../../source/AmrCore.rst:23 cfe9fc18b66640b1be6707b9c47f2364
msgid "e"
msgstr ""

#: ../../source/AmrCore.rst:42 810cc0d2b95d4b229aa758d3ccb56b58
msgid "AmrCore Source Code: Details"
msgstr ""

#: ../../source/AmrCore.rst:44 595a474a6e6f4e7f855f51ef0e715757
msgid ""
"Here we provide more information about the source code in "
"``amrex/Src/AmrCore``."
msgstr ""

#: ../../source/AmrCore.rst:47 75d241305bfa4cf9af155f52b7cffe11
msgid "AmrMesh and AmrCore"
msgstr ""

#: ../../source/AmrCore.rst:49 8b1aa2c2c3554a5493d66a84f2d9bc7e
msgid ""
"For single-level simulations (see e.g., ``amrex-"
"tutorials/ExampleCodes/Basic/HeatEquation_EX1_C/main.cpp``) the user "
"needs to build :cpp:`Geometry`, :cpp:`DistributionMapping`, and "
":cpp:`BoxArray` objects associated with the simulation. For simulations "
"with multiple levels of refinement, the :cpp:`AmrMesh` class can be "
"thought of as a container to store arrays of these objects (one for each "
"level), and information about the current grid structure."
msgstr ""

#: ../../source/AmrCore.rst:57 9f8b94dab43c4180981a1b1c436823e2
msgid ""
"``amrex/Src/AmrCore/AMReX_AmrMesh.cpp/H`` contains the :cpp:`AmrMesh` "
"class. The protected data members are:"
msgstr ""

#: ../../source/AmrCore.rst:87 aa955311062147b1bfcd42400395cab4
msgid ""
"The following parameters are frequently set via the inputs file or the "
"command line. Their usage is described in the section on "
":ref:`sec:grid_creation`"
msgstr ""

#: ../../source/AmrCore.rst:96 552766239c504dd3831de8431586ad1b
msgid "AmrCore parameters"
msgstr ""

#: ../../source/AmrCore.rst:99 625701c550c14e23a486ec357fca3b23
msgid "Variable"
msgstr ""

#: ../../source/AmrCore.rst:99 f5a7f883ecb04dec8908803cc598e3d2
msgid "Value"
msgstr ""

#: ../../source/AmrCore.rst:99 6dd13fca592f4b9e9cc37ccedb217d5d
msgid "Default"
msgstr ""

#: ../../source/AmrCore.rst:101 e9c0858c6d024f5aa9037c3efb48ea02
msgid "amr.verbose"
msgstr ""

#: ../../source/AmrCore.rst:101 ../../source/AmrCore.rst:103
#: ../../source/AmrCore.rst:107 ../../source/AmrCore.rst:111
#: ../../source/AmrCore.rst:113 ../../source/AmrCore.rst:115
#: 3ec38fb0140d4adf9c5f1f26d0d0fc71 589e7f7bdf55405dae88942e8c16de44
#: 7b0c9472dcaf4c7f83499a3bf6b39d8f 941be44df2f345d7a2ccf1d0c527c85a
#: d435589ac13946b188e840ce60027a63 eab350c19c8a442294a4408c9d25a0ef
msgid "int"
msgstr ""

#: ../../source/AmrCore.rst:101 dec7e60cf93b42cf9dab97e3782bdbed
msgid "0"
msgstr ""

#: ../../source/AmrCore.rst:103 169910581ef24f8db5e67d04e9050e28
msgid "amr.max_level"
msgstr ""

#: ../../source/AmrCore.rst:103 b20019b5c704433eac7e98016f157cf8
msgid "none"
msgstr ""

#: ../../source/AmrCore.rst:105 5c0a92b2a57440bca91d85088bc54393
msgid "amr.max_grid_size"
msgstr ""

#: ../../source/AmrCore.rst:105 b48266227ee846ac9de06a1f6d67feb4
msgid "ints"
msgstr ""

#: ../../source/AmrCore.rst:105 7b6182b377234b4e8dc782019cb05346
msgid "32 in 3D, 128 in 2D"
msgstr ""

#: ../../source/AmrCore.rst:107 2bae8aee9f8d48ad9464ce8a00f00330
msgid "amr.n_proper"
msgstr ""

#: ../../source/AmrCore.rst:107 ../../source/AmrCore.rst:111
#: 38779d2cf1de406c831d3bf3e5e49d09 92855c6ebc5e4bbfa24cd0f117acd8c9
msgid "1"
msgstr ""

#: ../../source/AmrCore.rst:109 4860e50689be4e87a5ac4ad7fec0c447
msgid "amr.grid_eff"
msgstr ""

#: ../../source/AmrCore.rst:109 50c41151a382442abf1d1134976dd753
msgid "Real"
msgstr ""

#: ../../source/AmrCore.rst:109 56fb1d626dbb4c1aacb8e5f06c4c6674
msgid "0.7"
msgstr ""

#: ../../source/AmrCore.rst:111 7d7514f8a43e4f60bc70a6c17be4d8a6
msgid "amr.n_error_buf"
msgstr ""

#: ../../source/AmrCore.rst:113 a2866f90905f4671bb1fd0aed7306f4f
msgid "amr.blocking_factor"
msgstr ""

#: ../../source/AmrCore.rst:113 1817a002b8da4a4591a039c0e4365d3a
msgid "8"
msgstr ""

#: ../../source/AmrCore.rst:115 d237d1a8ef2a4620b6ef151f4fac31f3
msgid "amr.refine_grid_layout"
msgstr ""

#: ../../source/AmrCore.rst:115 7bfd740fee96428f83599671f60d79d8
msgid "true"
msgstr ""

#: ../../source/AmrCore.rst:122 760e8cb303fb4a50b5241852214fbd8a
msgid ""
"AMReX_AmrCore.cpp/H contains the pure virtual class :cpp:`AmrCore`, which"
" is derived from the :cpp:`AmrMesh` class. AmrCore does not actually have"
" any data members, just additional member functions, some of which "
"override the base class AmrMesh."
msgstr ""

#: ../../source/AmrCore.rst:127 19962f500f5f4aa09ba762c36b24b655
msgid ""
"There are no pure virtual functions in :cpp:`AmrMesh`, but there are 5 "
"pure virtual functions in the :cpp:`AmrCore` class. Any applications you "
"create must implement these functions. The tutorial code "
"Amr/Advection_AmrCore provides sample implementation in the derived class"
" :cpp:`AmrCoreAdv`."
msgstr ""

#: ../../source/AmrCore.rst:159 9e79a5e160d944a2803b822714ebe3eb
msgid ""
"Refer to the :cpp:`AmrCoreAdv` class in the ``amrex-"
"tutorials/ExampleCodes/Amr/AmrCore_Advection/Source`` code for a sample "
"implementation."
msgstr ""

#: ../../source/AmrCore.rst:164 60ce76d97f584f5db0ae2d4844c608bb
msgid "TagBox, and Cluster"
msgstr ""

#: ../../source/AmrCore.rst:166 586f12ec42dd41c98c9eb25848dc937e
msgid ""
"These classes are used in the grid generation process. The :cpp:`TagBox` "
"class is essentially a data structure that marks which cells are "
"\"tagged\" for refinement. :cpp:`Cluster` (and :cpp:`ClusterList` "
"contained within the same file) are classes that help sort tagged cells "
"and generate a grid structure that contains all the tagged cells. These "
"classes and their member functions are largely hidden from any "
"application codes through simple interfaces such as :cpp:`regrid` and "
":cpp:`ErrorEst` (a routine for tagging cells for refinement)."
msgstr ""

#: ../../source/AmrCore.rst:179 7636c5e2cf2f43ed94571125be6ceb0b
msgid "FillPatchUtil and Interpolater"
msgstr ""

#: ../../source/AmrCore.rst:193 4d22af3eca574ae69ee577ce13d4a46a
msgid ""
"Many codes, including the Advection_AmrCore example, contain an array of "
"MultiFabs (one for each level of refinement), and then use \"fillpatch\" "
"operations to fill temporary MultiFabs that may include a different "
"number of ghost cells. Fillpatch operations fill all cells, valid and "
"ghost, from actual valid data at that level, space-time interpolated data"
" from the next-coarser level, neighboring grids at the same level, and "
"domain boundary conditions (for examples that have non-periodic boundary "
"conditions). Note that at the coarsest level, the interior and domain "
"boundary (which can be periodic or prescribed based on physical "
"considerations) need to be filled. At the non-coarsest level, the ghost "
"cells can also be interior or domain, but can also be at coarse-fine "
"interfaces away from the domain boundary. "
":cpp:`AMReX_FillPatchUtil.cpp/H` contains two primary functions of "
"interest."
msgstr ""

#: ../../source/AmrCore.rst:205 c8a98fd1713143f8ac1ef6d6a91ccace
msgid ""
":cpp:`FillPatchSingleLevel()` fills a :cpp:`MultiFab` and its ghost "
"region at a single level of refinement. The routine is flexible enough to"
" interpolate in time between two MultiFabs associated with different "
"times."
msgstr ""

#: ../../source/AmrCore.rst:209 6ab8ef9b96564fd7bf7a620838325587
msgid ""
":cpp:`FillPatchTwoLevels()` fills a :cpp:`MultiFab` and its ghost region "
"at a single level of refinement, assuming there is an underlying coarse "
"level. This routine is flexible enough to interpolate the coarser level "
"in time first using :cpp:`FillPatchSingleLevel()`."
msgstr ""

#: ../../source/AmrCore.rst:213 e676fe5815fe4adab5f3dadae6784881
msgid ""
"Note that :cpp:`FillPatchSingleLevel()` and :cpp:`FillPatchTwoLevels()` "
"call the single-level routines :cpp:`MultiFab::FillBoundary` and "
":cpp:`FillDomainBoundary()` to fill interior, periodic, and physical "
"boundary ghost cells.  In principle, you can write a single-level "
"application that calls :cpp:`FillPatchSingleLevel()` instead of using "
":cpp:`MultiFab::FillBoundary` and :cpp:`FillDomainBoundary()`."
msgstr ""

#: ../../source/AmrCore.rst:219 bce2efba54c6437392f3e13a6162efa4
msgid ""
"A :cpp:`FillPatchUtil` uses an :cpp:`Interpolator`. This is largely "
"hidden from application codes. AMReX_Interpolater.cpp/H contains the "
"virtual base class :cpp:`Interpolater`, which provides an interface for "
"coarse-to-fine spatial interpolation operators. The fillpatch routines "
"described above require an Interpolater for FillPatchTwoLevels(). Within "
"AMReX_Interpolater.cpp/H are the derived classes:"
msgstr ""

#: ../../source/AmrCore.rst:225 8be80104e003484ea077f40cf6c9e1e7
msgid ":cpp:`NodeBilinear`"
msgstr ""

#: ../../source/AmrCore.rst:227 184ad8846a8247cc80ad86042a7362ea
msgid ":cpp:`CellBilinear`"
msgstr ""

#: ../../source/AmrCore.rst:229 3ca2bb94a45b434e81b463a821644f60
msgid ":cpp:`CellConservativeLinear`"
msgstr ""

#: ../../source/AmrCore.rst:231 6aacf80dcb9f48d8a59b730e2fafd5fa
msgid ":cpp:`CellConservativeProtected`"
msgstr ""

#: ../../source/AmrCore.rst:233 1b4f4c79585a4f41880e11560c0c0661
msgid ":cpp:`CellConservativeQuartic`"
msgstr ""

#: ../../source/AmrCore.rst:235 cb518e69160e40d88677f7ea91f4a647
msgid ":cpp:`CellQuadratic`"
msgstr ""

#: ../../source/AmrCore.rst:237 ddd44d0148b6460ca6944418e4565c49
msgid ":cpp:`PCInterp`"
msgstr ""

#: ../../source/AmrCore.rst:239 3096ae5aaf954474a827d7e5666c26d2
msgid ":cpp:`FaceLinear`"
msgstr ""

#: ../../source/AmrCore.rst:241 e46a43dc5040466192cc2729a516f80f
msgid ""
":cpp:`FaceDivFree`: This is more accurately a divergence-preserving "
"interpolation on face centered data, i.e., it ensures the divergence of "
"the fine ghost cells match the value of the divergence of the underlying "
"coarse cell. All fine cells overlying a given coarse cell will have the "
"same divergence, even when the coarse grid divergence is spatially "
"varying. Note that when using this with :cpp:`FillPatch` for time sub-"
"cycling, the coarse grid times may not match the fine grid time, in which"
" case :cpp:`FillPatch` will create coarse values at the fine time before "
"calling this interpolation and the result of the :cpp:`FillPatch` is "
"*not* guaranteed to preserve the original divergence."
msgstr ""

#: ../../source/AmrCore.rst:243 1edfc41784ba4c8480a17bbfe49278ed
msgid ""
"These Interpolaters can be executed on CPU or GPU, with certain "
"limitations:"
msgstr ""

#: ../../source/AmrCore.rst:245 55b654448ac34792878323eede42b2d4
msgid ":cpp:`CellConservativeProtected` only works in 2D and 3D."
msgstr ""

#: ../../source/AmrCore.rst:247 7f50fdca58be4c11858aa82b2027e7f4
msgid ":cpp:`CellQuadratic` only works in 2D and 3D."
msgstr ""

#: ../../source/AmrCore.rst:249 09dc0d10704147798bab8bb8d04945b5
msgid ":cpp:`CellConservativeQuartic` only works with a refinement ratio of 2."
msgstr ""

#: ../../source/AmrCore.rst:251 0f83144d17a34abd8acd8a3c9e051838
msgid ""
":cpp:`FaceDivFree` only works in 2D and 3D and with a refinement ratio of"
" 2."
msgstr ""

#: ../../source/AmrCore.rst:256 cfa125291ca646afb0c3fb7df71fff1e
msgid "Using FluxRegisters"
msgstr ""

#: ../../source/AmrCore.rst:258 3bb339abe7e84ca0a15e778c5dd71057
msgid ""
"AMReX_FluxRegister.cpp/H contains the class :cpp:`FluxRegister`, which is"
" derived from the class :cpp:`BndryRegister` (in "
"``amrex/Src/Boundary/AMReX_BndryRegister``). In the most general terms, a"
" FluxRegister is a special type of BndryRegister that stores and "
"manipulates data (most often fluxes) at coarse-fine interfaces. A simple "
"usage scenario comes from a conservative discretization of a hyperbolic "
"system:"
msgstr ""

#: ../../source/AmrCore.rst:265 6b5321f4865f43bf838fe39ca1afe16f
msgid ""
"\\frac{\\partial\\phi}{\\partial t} = \\nabla\\cdot{\\bf F}\n"
"\\rightarrow\n"
"\\frac{\\phi_{i,\\,j}^{n+1}-\\phi_{i,\\,j}^n}{\\Delta t} = "
"\\frac{F_{i+^1\\!/_2,\\,j}-F_{i-^1\\!/_2,\\,j}}{\\Delta x} + "
"\\frac{F_{i,\\,j+^1\\!/_2} - F_{i,\\,j-^1\\!/_2}}{\\Delta y}."
msgstr ""

#: ../../source/AmrCore.rst:271 9849e7596c2d4b8d84c82340599a2132
msgid ""
"Consider a two-level, two-dimensional simulation. A standard methodology "
"for advancing the solution in time is to first advance the coarse grid "
"solution ignoring the fine level, and then advance the fine grid solution"
" using the coarse level only to supply boundary conditions. At the "
"coarse-fine interface, the area-weighted fluxes from the fine grid "
"advance do not in general match the underlying flux from the coarse grid "
"face, resulting in a lack of global conservation. Note that for "
"subcycling-in-time algorithms (where for each coarse grid advance, the "
"fine grid is advanced :math:`r` times using a coarse grid time step "
"reduced by a factor of :math:`r`, where :math:`r` is the refinement "
"ratio), the coarse grid flux must be compared to the area *and* time-"
"weighted fine grid fluxes. A :cpp:`FluxRegister` accumulates and "
"ultimately stores the net difference in fluxes between the coarse grid "
"and fine grid advance over each face over a given coarse time step. The "
"simplest possible synchronization step is to modify the coarse grid "
"solution in coarse cells immediately adjacent to the coarse-fine "
"interface are updated to account for the mismatch stored in the "
"FluxRegister. This can be done \"simply\" by taking the coarse-level "
"divergence of the data in the FluxRegister using the :cpp:`reflux` "
"function."
msgstr ""

#: ../../source/AmrCore.rst:289 c0a6c78f3bc24c53be7f7e0dd5cd2af7
msgid ""
"The Fortran routines that perform the actual floating point work "
"associated with incrementing data in a :cpp:`FluxRegister` are contained "
"in the files AMReX_FLUXREG_F.H and AMReX_FLUXREG_xD.F."
msgstr ""

#: ../../source/AmrCore.rst:294 aeb1e261565c4377919a8940ca270a55
msgid "AmrParticles and AmrParGDB"
msgstr ""

#: ../../source/AmrCore.rst:296 d9c2e82561504aaf9498731a02b463fb
msgid ""
"The AmrCore/ directory contains derived classes for dealing with "
"particles in a multi-level framework. The description of the base classes"
" are given in the chapter on :ref:`Chap:Particles`."
msgstr ""

#: ../../source/AmrCore.rst:300 50dc0ee2f9e74d51908150697eea3414
msgid ""
"AMReX_AmrParticles.cpp/H contains the classes :cpp:`AmrParticleContainer`"
" and :cpp:`AmrTracerParticleContainer`, which are derived from the "
"classes :cpp:`ParticleContainer` (in "
"``amrex/Src/Particle/AMReX_Particles``) and "
":cpp:`TracerParticleContainer` (in "
"``amrex/Src/Particle/AMReX_TracerParticles``)."
msgstr ""

#: ../../source/AmrCore.rst:305 7059ec9ddb154984b14b5c1a8c5aa1d1
msgid ""
"AMReX_AmrParGDB.cpp/H contains the class :cpp:`AmrParGDB`, which is "
"derived from the class :cpp:`ParGDBBase` (in "
"``amrex/Src/Particle/AMReX_ParGDB``)."
msgstr ""

#: ../../source/AmrCore.rst:309 6683e1c923e0474891d9b6b47af667d1
msgid "Example: Advection_AmrCore"
msgstr ""

#: ../../source/AmrCore.rst:312 a1063f8f3ed44a0ba81f6a99dc9702d2
msgid "The Advection Equation"
msgstr ""

#: ../../source/AmrCore.rst:314 43ad61ad785e438199117a0a6e5105c7
msgid ""
"We seek to solve the advection equation on a multi-level, adaptive grid "
"structure:"
msgstr ""

#: ../../source/AmrCore.rst:316 159a9910169a4e72ab65258d9adc309f
msgid ""
"\\frac{\\partial\\phi}{\\partial t} = -\\nabla\\cdot(\\phi{\\bf U}).\n"
"\n"
msgstr ""

#: ../../source/AmrCore.rst:318 9e13c8622659458d98edbcd9b3f49e8a
msgid ""
"The velocity field is a specified divergence-free (so the flow field is "
"incompressible) function of space and time. The initial scalar field is a"
" Gaussian profile. To integrate these equations on a given level, we use "
"a simple conservative update,"
msgstr ""

#: ../../source/AmrCore.rst:322 aa39199e6adf4c13be5ebc91ffbf5e78
msgid ""
"\\frac{\\phi_{i,\\,j}^{n+1}-\\phi_{i,\\,j}^n}{\\Delta t} = \\frac{(\\phi "
"u)_{i+^1\\!/_2,\\,j}^{n+^1\\!/_2}-(\\phi "
"u)_{i-^1\\!/_2,\\,j}^{n+^1\\!/_2}}{\\Delta x} + \\frac{(\\phi "
"v)_{i,\\,j+^1\\!/_2}^{n+^1\\!/_2} - (\\phi "
"v)_{i,\\,j-^1\\!/_2}^{n+^1\\!/_2}}{\\Delta y},\n"
"\n"
msgstr ""

#: ../../source/AmrCore.rst:324 5d8b5727c6c84d24b9855abf9397b48a
msgid ""
"where the velocities on faces are prescribed functions of space and time,"
" and the scalars on faces are computed using a Godunov advection "
"integration scheme. The fluxes in this case are the face-centered, time-"
"centered \":math:`\\phi u`\" and \":math:`\\phi v`\" terms."
msgstr ""

#: ../../source/AmrCore.rst:328 922c5cb18faf4a71a5d1a0eeae991522
msgid ""
"We use a subcycling-in-time approach where finer levels are advanced with"
" smaller time steps than coarser levels, and then synchronization is "
"later performed between levels. More specifically, the multi-level "
"procedure can most easily be thought of as a recursive algorithm in "
"which, to advance level :math:`\\ell`, :math:`0\\le\\ell\\le\\ell_{\\rm "
"max}`, the following steps are taken:"
msgstr ""

#: ../../source/AmrCore.rst:334 8555331d8bcc4d0aa80f8eade2347bcb
msgid ""
"Advance level :math:`\\ell` in time by one time step, :math:`\\Delta "
"t^{\\ell}`, as if it is the only level. If :math:`\\ell>0`, obtain "
"boundary data (i.e. fill the level :math:`\\ell` ghost cells) using "
"space- and time-interpolated data from the grids at :math:`\\ell-1` where"
" appropriate."
msgstr ""

#: ../../source/AmrCore.rst:338 6dd910fd34c6449c8685997de3a94b65
msgid "If :math:`\\ell<\\ell_{\\rm max}`"
msgstr ""

#: ../../source/AmrCore.rst:340 9df8f14825f7498d976cb5275c9bcf90
msgid ""
"Advance level :math:`(\\ell+1)` for :math:`r` time steps with "
":math:`\\Delta t^{\\ell+1} = \\frac{1}{r}\\Delta t^{\\ell}`."
msgstr ""

#: ../../source/AmrCore.rst:342 532063ac1395440f83e2cf756e8bc3f8
msgid "Synchronize the data between levels :math:`\\ell` and :math:`\\ell+1`."
msgstr ""

#: ../../source/AmrCore.rst:353 efe0a85f3292473188f93158feeb2aa3
msgid "Schematic of subcycling-in-time algorithm."
msgstr ""

#: ../../source/AmrCore.rst:359 c5e7706b32cc470e9edb5f3b26ec5420
msgid ""
"Specifically, for a 3-level simulation, depicted graphically in the "
"figure showing the :ref:`fig:subcycling` above:"
msgstr ""

#: ../../source/AmrCore.rst:362 e5961716165a4af9bb7ecc64aed81bf3
msgid "Integrate :math:`\\ell=0` over :math:`\\Delta t`."
msgstr ""

#: ../../source/AmrCore.rst:364 ../../source/AmrCore.rst:372
#: 47aa31e0f3db4660a35d044d2e54bda7 f27f0d30def9415a8587c7fe7ebd0c1b
msgid "Integrate :math:`\\ell=1` over :math:`\\Delta t/2`."
msgstr ""

#: ../../source/AmrCore.rst:366 ../../source/AmrCore.rst:368
#: ../../source/AmrCore.rst:374 ../../source/AmrCore.rst:376
#: 11259209f9cb49a3b984e8e885994f01 7a11375d04e3429c826eab1b499fc419
#: a20767e18de44d37a81e80709e5edb1a b47dd5ec1f794705b08d95280233935a
msgid "Integrate :math:`\\ell=2` over :math:`\\Delta t/4`."
msgstr ""

#: ../../source/AmrCore.rst:370 ../../source/AmrCore.rst:378
#: 1598079b073841ddac956affae6eccde ee39184225f9497e821201b2d4888df9
msgid "Synchronize levels :math:`\\ell=1,2`."
msgstr ""

#: ../../source/AmrCore.rst:380 1b2a4bfb237340a5b0586b9be7d177c4
msgid "Synchronize levels :math:`\\ell=0,1`."
msgstr ""

#: ../../source/AmrCore.rst:384 cc7498c5eecd4bd8862ec2394fb7b0dd
msgid ""
"For the scalar field, we keep track volume and time-weighted fluxes at "
"coarse-fine interfaces. We accumulate area and time-weighted fluxes in "
":cpp:`FluxRegister` objects, which can be thought of as special boundary "
"FABsets associated with coarse-fine interfaces. Since the fluxes are area"
" and time-weighted (and sign-weighted, depending on whether they come "
"from the coarse or fine level), the flux registers essentially store the "
"extent by which the solution does not maintain conservation. Conservation"
" only happens if the sum of the (area and time-weighted) fine fluxes "
"equals the coarse flux, which in general is not true."
msgstr ""

#: ../../source/AmrCore.rst:393 2e4040a5af1649d291cd03108c4db96a
msgid ""
"The idea behind the level :math:`\\ell/(\\ell+1)` synchronization step is"
" to correct for sources of mismatch in the composite solution:"
msgstr ""

#: ../../source/AmrCore.rst:396 54895856a0f54dfab4193e94fea9f164
msgid ""
"The data at level :math:`\\ell` that underlie the level :math:`\\ell+1` "
"data are not synchronized with the level :math:`\\ell+1` data. This is "
"simply corrected by overwriting covered coarse cells to be the average of"
" the overlying fine cells."
msgstr ""

#: ../../source/AmrCore.rst:399 075131f64c864194902612c932fbb4a9
msgid ""
"The area and time-weighted fluxes from the level :math:`\\ell` faces and "
"the level :math:`\\ell+1` faces do not agree at the "
":math:`\\ell/(\\ell+1)` interface, resulting in a loss of conservation. "
"The remedy is to modify the solution in the coarse cells immediately next"
" to the coarse-fine interface to account for the mismatch stored in the "
"flux register (computed by taking the coarse-level divergence of the flux"
" register data)."
msgstr ""

#: ../../source/AmrCore.rst:406 14178e28f9ff469d875b8ff8044162aa
msgid "Code Structure"
msgstr ""

#: ../../source/AmrCore.rst:413 031a4b7e0f274cd5986b4c9db8db2aca
msgid "Source code tree for the AmrAdvection_AmrCore example."
msgstr ""

#: ../../source/AmrCore.rst:416 0a88559c9c294671a3b729a86e17947f
msgid "The figure shows the :ref:`fig:AmrAdvection_AmrCore_flowchart`"
msgstr ""

#: ../../source/AmrCore.rst:419 70acb480f2324fba8ec777916e3819e1
msgid "amrex/Src/"
msgstr ""

#: ../../source/AmrCore.rst:421 e364f98aa9cf407289403fd1f6605892
msgid "Base/ Base amrex library."
msgstr ""

#: ../../source/AmrCore.rst:423 1dd706d0378a4517a6ab97533b4d0895
msgid "Boundary/ An assortment of classes for handling boundary data."
msgstr ""

#: ../../source/AmrCore.rst:425 33a91272743d4a659c9ee96655e23bef
msgid "AmrCore/ AMR data management classes, described in more detail above."
msgstr ""

#: ../../source/AmrCore.rst:428 c6d586cc49fe497c8df1bb65188e67ee
msgid ""
"``Advection_AmrCore/Src`` Source code specific to this example. Most "
"notably is the :cpp:`AmrCoreAdv` class, which is derived from "
":cpp:`AmrCore`. The subdirectories ``Src_2d`` and ``Src_3d`` contain "
"dimension specific routines. ``Src_nd`` contains dimension-independent "
"routines."
msgstr ""

#: ../../source/AmrCore.rst:433 9b3644a0636d484abb4be997d6a33aee
msgid ""
"Exec Contains a makefile so a user can write other examples besides "
"SingleVortex."
msgstr ""

#: ../../source/AmrCore.rst:436 740743f2c45747b88f1e8626f7bc9881
msgid ""
"SingleVortex Build the code here by editing the GNUmakefile and running "
"make. There is also problem-specific source code here used for "
"initialization or specifying the velocity field used in this simulation."
msgstr ""

#: ../../source/AmrCore.rst:440 01a1f9c80e7841d5a9fac7e46fbd6f9d
msgid "Here is a high-level pseudo-code of the flow of the program:"
msgstr ""

#: ../../source/AmrCore.rst:487 dd1953301de549e9b1f2c85674d8bc07
msgid "The AmrCoreAdv Class"
msgstr ""

#: ../../source/AmrCore.rst:489 768367020ece483dbce51fd667f2db81
msgid ""
"This example uses the class :cpp:`AmrCoreAdv`, which is derived from the "
"class :cpp:`AmrCore` (which is derived from :cpp:`AmrMesh`). The function"
" definitions/implementations are given in AmrCoreAdv.H/cpp."
msgstr ""

#: ../../source/AmrCore.rst:494 ccc5f570818d4c3c95776b5215cac8f0
msgid "FluxRegisters"
msgstr ""

#: ../../source/AmrCore.rst:496 3d64932238c84ef89fe92d84a7c6ab93
msgid ""
"The function :cpp:`AmrCoreAdv::Advance()` calls the Fortran subroutine, "
":fortran:`advect` (in ``./Src_xd/Adv_xd.f90``). :fortran:`advect` "
"computes and returns the time-advanced state as well as the fluxes used "
"to update the state. These fluxes are used to set or increment the flux "
"registers."
msgstr ""

#: ../../source/AmrCore.rst:526 92595533152340788ff0096ff9292313
msgid ""
"The synchronization is performed at the end of "
":cpp:`AmrCoreAdv::timeStep`:"
msgstr ""

#: ../../source/AmrCore.rst:545 eab0a2d3a11644e29de6ec1083ef422e
msgid "Regridding"
msgstr ""

#: ../../source/AmrCore.rst:547 b56d3c01094341da81ced7cd50999337
msgid ""
"The regrid function belongs to the :cpp:`AmrCore` class (it is virtual --"
" in this tutorial we use the instance in :cpp:`AmrCore`)."
msgstr ""

#: ../../source/AmrCore.rst:550 bb761082f66841cbbc3a057e169c043a
msgid ""
"At the beginning of each time step, we check whether we need to regrid. "
"In this example, we use a :cpp:`regrid_int` and keep track of how many "
"times each level has been advanced. When any given particular level "
":math:`\\ell<\\ell_{\\rm max}` has been advanced a multiple of "
":cpp:`regrid_int`, we call the :cpp:`regrid` function."
msgstr ""

#: ../../source/AmrCore.rst:583 dd3ed30ec87b49c4b2f55a583b2c002b
msgid ""
"Central to the regridding process is the concept of \"tagging\" which "
"cells need refinement. :cpp:`ErrorEst` is a pure virtual function of "
":cpp:`AmrCore`, so each application code must contain an implementation. "
"In AmrCoreAdv.cpp the ErrorEst function is essentially an interface to a "
"Fortran routine that tags cells (in this case, :fortran:`state_error` in "
"``Src_nd/Tagging_nd.f90``). Note that this code uses tiling."
msgstr ""

#: ../../source/AmrCore.rst:665 a8868bb1127e4d5f9a1d1ade5cef1e55
msgid ""
"The :fortran:`state_error` subroutine in ``Src_nd/Tagging_nd.f90`` in "
"this example is simple:"
msgstr ""

#: ../../source/AmrCore.rst:711 fa4f4c61d8674d2b962b1a153fe12f3d
msgid "FillPatch"
msgstr ""

#: ../../source/AmrCore.rst:713 7877d13f895542e5870cc7a342cd7e5b
msgid ""
"This example has two functions, :cpp:`AmrCoreAdv::FillPatch` and "
":cpp:`AmrCoreAdv::CoarseFillPatch`, that make use of functions in "
"AmrCore/AMReX_FillPatchUtil."
msgstr ""

#: ../../source/AmrCore.rst:716 f38d12d3c1ac49dd87409a32c474417c
msgid ""
"In :cpp:`AmrCoreAdv::Advance`, we create a temporary :cpp:`MultiFab` "
"called :cpp:`Sborder`, which is essentially :math:`\\phi` but with ghost "
"cells filled in. The valid and ghost cells are filled in from actual "
"valid data at that level, space-time interpolated data from the next-"
"coarser level, neighboring grids at the same level, or domain boundary "
"conditions (for examples that have non-periodic boundary conditions)."
msgstr ""

#: ../../source/AmrCore.rst:729 93598268c0794c62ba1c1860d92d683a
msgid ""
"Several other calls to fillpatch routines are hidden from the user in the"
" regridding process."
msgstr ""

