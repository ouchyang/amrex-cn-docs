# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-20123, AMReX Team
# This file is distributed under the same license as the amrex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: amrex 23.00-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-02 14:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/AmrLevel.rst:8 b67fab3dd07440ad90c1ad6b5c349cbf
msgid "Amr Class"
msgstr "Amr 班级"

#: ../../source/AmrLevel.rst:10 89dfe4bf66424a2aa66e96ad0c4a4fc9
msgid ""
"The :cpp:`Amr` class is designed to manage parts of the computation which do not belong on a single level, like "
"establishing and updating the hierarchy of levels, global timestepping, and managing the different :cpp:`AmrLevel`\\ s. "
"Most likely you will not need to derive any classes from :cpp:`Amr`. Our mature application codes use this base class "
"without any derived classes."
msgstr "`Amr` 类的设计目的是管理不属于单个层级的计算部分，例如建立和更新层级的层次结构、全局时间步进以及管理不同的 `AmrLevel`。您很可能不需要从 `Amr` 派生任何类。我们成熟的应用程序代码使用这个基类而没有任何派生类。"

#: ../../source/AmrLevel.rst:16 7d3555ce296543b9abdc958477166569
msgid ""
"One of the most important data members is an array of :cpp:`AmrLevel`\\ s - the :cpp:`Amr` class calls many functions "
"from the :cpp:`AmrLevel` class to do things like advance the solution on a level, compute a time step to be used for a "
"level, etc."
msgstr "其中最重要的数据成员之一是一个 :cpp:`AmrLevel` 数组 - :cpp:`Amr` 类会调用 :cpp:`AmrLevel` 类的许多函数来执行诸如在某个层级上推进解、计算该层级上要使用的时间步长等操作。"

#: ../../source/AmrLevel.rst:22 5220b88f33b84dd4835c771eff218d4b
msgid "AmrLevel Class"
msgstr "AmrLevel 类"

#: ../../source/AmrLevel.rst:24 e9d2ab511a844ef7a76a76056e73d7f4
msgid "Pure virtual functions include:"
msgstr "纯虚函数包括："

#: ../../source/AmrLevel.rst:26 0ccc5108a7744682bad4dc04e2ccd995
msgid ""
":cpp:`computeInitialDt` Compute an array of time steps for each level of refinement. Called at the beginning of the "
"simulation."
msgstr ":cpp:`computeInitialDt` 在模拟开始时计算每个细化级别的时间步长数组。"

#: ../../source/AmrLevel.rst:29 fbba9c5b9a2649d0b2223a940ce89215
msgid ""
":cpp:`computeNewDt` Compute an array of time steps for each level of refinement. Called at the end of a coarse level "
"advance."
msgstr ":cpp:`computeNewDt` 在每个细化级别上计算时间步长的数组。在粗级别推进结束时调用。"

#: ../../source/AmrLevel.rst:32 79102ed6d5fc404792a9f4220a96a815
msgid ":cpp:`advance` Advance the grids at a level."
msgstr ":cpp:`advance` 在一个级别上推进网格。"

#: ../../source/AmrLevel.rst:34 39bf9da3082244d1a61cc18eacba8bcb
msgid ":cpp:`post_timestep` Work after at time step at a given level. In this tutorial we do the AMR synchronization here."
msgstr ":cpp:`post_timestep` 在给定层级上进行时间步后的工作。在本教程中，我们在这里进行AMR同步。"

#: ../../source/AmrLevel.rst:37 94d61a2826f44bb68ee43586b3779223
msgid ":cpp:`post_regrid` Work after regridding. In this tutorial we redistribute particles."
msgstr ":cpp:`post_regrid` 在重新网格化之后工作。在本教程中，我们对粒子进行重新分布。"

#: ../../source/AmrLevel.rst:40 e6eb220d507c49ea8b8d7f967c77719f
msgid ":cpp:`post_init` Work after initialization. In this tutorial we perform AMR synchronization."
msgstr ":cpp:`post_init` 在初始化之后工作。在本教程中，我们执行 AMR 同步操作。"

#: ../../source/AmrLevel.rst:43 31f222db43fe419c9c45f448c7821da4
msgid ":cpp:`initData` Initialize the data on a given level at the beginning of the simulation."
msgstr ":cpp:`initData` 在模拟开始时初始化给定级别的数据。"

#: ../../source/AmrLevel.rst:46 d586cfdcc15e426891084cd342ed1bad
msgid ""
":cpp:`init` There are two versions of this function used to initialize data on a level during regridding. One version "
"is specifically for the case where the level did not previously exist (a newly created refined level)."
msgstr ":cpp:`init` 这个函数有两个版本，用于在重新网格化期间初始化层级上的数据。其中一个版本专门用于层级之前不存在的情况（新创建的细化层级）。"

#: ../../source/AmrLevel.rst:51 90151c7ec9c14a65a406297cbdb893bc
msgid ":cpp:`errorEst` Perform the tagging at a level for refinement."
msgstr ":cpp:`errorEst` 在细化层面上执行标记。"

#: ../../source/AmrLevel.rst:54 05c5cd8a41334764bf13915fd654596f
msgid "StateData"
msgstr "州数据"

#: ../../source/AmrLevel.rst:56 1615bea815fa48a2ba3fc7c0d0d1024e
msgid ""
"The most important data managed by the :cpp:`AmrLevel` is an array of :cpp:`StateData`, which holds the scalar fields, "
"etc., in the boxes that together make up the level."
msgstr "由 :cpp:`AmrLevel` 管理的最重要的数据是一个 :cpp:`StateData` 数组，它在一起构成了该层中的盒子中的标量场等。"

#: ../../source/AmrLevel.rst:60 4b6519e341d94ccb9b7e20753d8f9585
msgid ""
":cpp:`StateData` is a class that essentially holds a pair of MultiFabs: one at the old time and one at the new time. "
"AMReX knows how to interpolate in time between these states to get data at any intermediate point in time. The main "
"data that we care about in our applications codes (such as the fluid state) will be stored as :cpp:`StateData`.  "
"Essentially, data is made :cpp:`StateData` if we need it to be stored in checkpoints/plotfiles, and/or we want it to be "
"automatically interpolated when we refine.  An :cpp:`AmrLevel` stores an array of :cpp:`StateData` (in a C++ array "
"called :cpp:`state`). We index this array using integer keys (defined via an :cpp:`enum` in, e.g., ``AmrLevelAdv.H``):"
msgstr ""
"`StateData` 是一个类，主要用于保存一对 MultiFabs：一个是旧时间点的数据，另一个是新时间点的数据。AMReX "
"能够在这些状态之间进行时间插值，以获取任意中间时间点的数据。在我们的应用程序代码中，我们关心的主要数据（如流体状态）将被存储为 "
"`StateData`。如果我们需要将数据存储在检查点/绘图文件中，并且/或者希望在细化时自动进行插值，那么我们将其定义为 `StateData`。`AmrLevel` 存储了一组 `StateData`（在一个名为 `state` 的 "
"C++ 数组中）。我们使用整数键来索引这个数组（通过在例如 `AmrLevelAdv.H` 中定义的 `enum`）。"

#: ../../source/AmrLevel.rst:77 9f609933a456402b8731900a1086640a
msgid ""
"In our tutorial code, we use the function :cpp:`AmrLevelAdv::variableSetUp` to tell our simulation about the "
":cpp:`StateData` (e.g., how many variables, ghost cells, nodality, etc.). Note that if you have more than one "
":cpp:`StateType`, each of the different :cpp:`StateData` carried in the state array can have different numbers of "
"components, ghost cells, boundary conditions, etc. This is the main reason we separate all this data into separate "
":cpp:`StateData` objects collected together in an indexable array."
msgstr ""
"在我们的教程代码中，我们使用函数 `AmrLevelAdv::variableSetUp` 来告诉我们的模拟关于 `StateData`（例如，变量的数量、幽灵单元、节点性质等）。请注意，如果你有多个 "
"`StateType`，则状态数组中携带的每个不同的 `StateData` 可以具有不同数量的分量、幽灵单元、边界条件等。这是我们将所有这些数据分开存储在可索引数组中的主要原因。"

#: ../../source/AmrLevel.rst:86 e7c2f9d6758d4682980d5d020b53e959
msgid "LevelBld Class"
msgstr "楼层建筑课程"

#: ../../source/AmrLevel.rst:88 df4f92ba523a4ec9bdbd6bdac632d328
msgid ""
"The :cpp:`LevelBld` class is a pure virtual class for defining variable types and attributes. To more easily understand "
"its usage, refer to the derived class, :cpp:`LevelBldAdv` in the tutorial. The :cpp:`variableSetUp` and "
":cpp:`variableCleanUp` are implemented, and in this tutorial call routines in the :cpp:`AmrLevelAdv` class, e.g.,"
msgstr ""
"`LevelBld`类是一个纯虚类，用于定义变量类型和属性。为了更容易理解其用法，请参考派生类`LevelBldAdv`在教程中的使用。`variableSetUp`和`variableCleanUp`已经实现，并在本教程中调用了`"
"AmrLevelAdv`类中的例程，例如："

#: ../../source/AmrLevel.rst:125 e330c3c024c24f6bafb7b432558d5603
msgid ""
"We see how to define the :cpp:`StateType`, including nodality, whether or not we want the variable to represent a point "
"in time or an interval over time (useful for returning the time associated with data), the number of ghost cells, "
"number of components, and the interlevel interpolation (See AMReX_Interpolator for various interpolation types). We "
"also see how to specify physical boundary functions by providing a function (in this case, :cpp:`nullfill` since we are "
"not using physical boundary conditions), where :cpp:`nullfill` is defined in ``Src/bc_nullfill.cpp`` in the tutorial "
"source code."
msgstr ""
"我们看到如何定义 `StateType`，包括节点性质，变量是表示时间点还是时间间隔（对于返回与数据相关的时间很有用），幽灵单元的数量，分量的数量以及层间插值（参见 AMReX_Interpolator "
"以获取不同的插值类型）。我们还看到如何通过提供一个函数来指定物理边界函数（在这种情况下，使用 `nullfill` 函数，因为我们没有使用物理边界条件），其中 `nullfill` 在教程源代码的 "
"``Src/bc_nullfill.cpp`` 中定义。"

#: ../../source/AmrLevel.rst:136 60776181b4f14584ab4159ea58f9e6a1
msgid "Example: Advection_AmrLevel"
msgstr "示例：Advection_AmrLevel"

#: ../../source/AmrLevel.rst:138 43b8e8922fb943d180f772dd72a71e18
msgid ""
"The Advection_AmrLevel example is documented in detail `here "
"<https://amrex-codes.github.io/amrex/tutorials_html/AMR_Tutorial.html#advection-amrlevel>`__ in the AMReX tutorial "
"documentation."
msgstr ""
"Advection_AmrLevel示例在AMReX教程文档的这里详细记录了：[链接](https://amrex-codes.github.io/amrex/tutorials_html/AMR_Tutorial.html#"
"advection-amrlevel)。"

#: ../../source/AmrLevel.rst:142 93af1e0ce5b2435fabf6131a305792b0
msgid ""
"The ``Src`` subdirectory contains source code that is specific to this example. Most notably is the :cpp:`AmrLevelAdv` "
"class, which is derived from the base :cpp:`AmrLevel` class, and the :cpp:`LevelBldAdv` class, derived from the base "
":cpp:`LevelBld` class as described above. The subdirectory ``Src/Src_K`` contain GPU kernels."
msgstr ""
"``Src``子目录包含特定于此示例的源代码。最重要的是：:cpp:`AmrLevelAdv`类，它是从基类:cpp:`AmrLevel`派生的；以及:cpp:`LevelBldAdv`类，它是从基类:cpp:`LevelBld`"
"派生的，如上所述。子目录``Src/Src_K``包含GPU内核。"

#: ../../source/AmrLevel.rst:146 cfd674f2781046ba8e4458a9fdf263e8
msgid ""
"The ``Exec`` subdirectory contains two examples: ``SingleVortex`` and ``UniformVelocity``. Each subdirectory contains "
"problem-specific source code used for initialization using a Fortran subroutine (``Prob.f90``) and specifying the "
"velocity fields used in this simulation (``face_velocity_2d_K.H`` and ``face_velocity_3d_K.H`` for the 2-D and 3-D "
"problem, respectively). Build the code here by editing the ``GNUmakefile`` and running ``make``."
msgstr ""
"``Exec``子目录包含两个示例：``SingleVortex``和``UniformVelocity``。每个子目录都包含用于初始化的问题特定源代码，使用Fortran子程序（``Prob.f90``"
"）进行初始化，并指定在此模拟中使用的速度场（对于2D问题是``face_velocity_2d_K.H``，对于3D问题是``face_velocity_3d_K.H``）。通过编辑``GNUmakefile``并运行``make``"
"来在此处构建代码。"

#: ../../source/AmrLevel.rst:154 89aa37b582f04a0d9ecc47a538d1ca1e
msgid "The pseudocode for the main program is given below."
msgstr "以下是主程序的伪代码。"

#: ../../source/AmrLevel.rst:177 bfa5a70e7ee445e295e7f59c442e41af
msgid "Particles"
msgstr "粒子"

#: ../../source/AmrLevel.rst:179 dcfff6c66a3e465db2111e30d0fdacbf
msgid ""
"There is an option to turn on passively advected particles. In the ``GNUmakefile``, add the line ``USE_PARTICLES = "
"TRUE`` and build the code (do a ``make realclean first``). In the inputs file, add the line ``adv.do_tracers = 1``. "
"When you run the code, within each plotfile directory there will be a subdirectory called \"Tracer\"."
msgstr ""
"有一个选项可以开启被动追踪的粒子。在``GNUmakefile``文件中添加一行``USE_PARTICLES = TRUE``，然后编译代码（首先执行``make "
"realclean``）。在输入文件中添加一行``adv.do_tracers = 1``。当你运行代码时，在每个绘图文件目录下会有一个名为\"Tracer\"的子目录。"

#: ../../source/AmrLevel.rst:186 6ab74048d0b149f3b041834ddb7bbc7e
msgid "Copy the files from ``amrex/Tools/Py_util/amrex_particles_to_vtp`` into the run directory and type, e.g.,"
msgstr "将文件从``amrex/Tools/Py_util/amrex_particles_to_vtp``复制到运行目录中，并键入，例如，"

#: ../../source/AmrLevel.rst:195 81fd658a0e074da7bd1ce3090702a629
msgid "To generate a vtp file you can open with ParaView (Refer to the chapter on :ref:`Chap:Visualization`)."
msgstr "要生成一个可以在ParaView中打开的vtp文件（请参考:ref:`Chap:Visualization`章节）。"
